
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="go,go语言基础,goroutine," />
  

  
  
    <meta name="description" content="[转]go调度器源码分析" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>[转]go调度器源码分析 [ GeedChin ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="http://geedchin.com/images/logo.png">
    <span class="title">GeedChin</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives/" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories/" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags/" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about/" class="pure-menu-link">关于</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        [转]go调度器源码分析
      </h1>
      <span>
        
        <time class="time" datetime="2019-06-23T14:00:12.000Z">
        2019-06-23
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/goroutine/" rel="tag">goroutine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag">go语言基础</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <!--span class="slash">/</span>
      <span class="read">阅读耗时 </span-->
    </header>

    <div class="post-content">
      <h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>goroutine 在 runtime 中的数据结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]</span></span><br><span class="line"><span class="comment">// 如果从传统内存布局的角度来讲，Go 的栈实际上是分配在 C 语言中的堆区的</span></span><br><span class="line"><span class="comment">// 所以才能比 ulimit -s 的 stack size 还要大(1GB)</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="keyword">uintptr</span></span><br><span class="line">    hi <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 的运行现场</span></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="keyword">uintptr</span>    <span class="comment">// sp 寄存器</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span>    <span class="comment">// pc 寄存器</span></span><br><span class="line">    g    guintptr   <span class="comment">// g 指针</span></span><br><span class="line">    ctxt unsafe.Pointer <span class="comment">// 这个似乎是用来辅助 gc 的</span></span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    lr   <span class="keyword">uintptr</span>    <span class="comment">// 这是在 arm 上用的寄存器，不用关心</span></span><br><span class="line">    bp   <span class="keyword">uintptr</span>    <span class="comment">// 开启 GOEXPERIMENT=framepointer，才会有这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 简单数据结构，lo 和 hi 成员描述了栈的下界和上界内存地址</span></span><br><span class="line">    stack       stack</span><br><span class="line">    <span class="comment">// 在函数的栈增长 prologue 中用 sp 寄存器和 stackguard0 来做比较</span></span><br><span class="line">    <span class="comment">// 如果 sp 比 stackguard0 小(因为栈向低地址方向增长)，那么就触发栈拷贝和调度</span></span><br><span class="line">    <span class="comment">// 正常情况下 stackguard0 = stack.lo + StackGuard</span></span><br><span class="line">    <span class="comment">// 不过 stackguard0 在需要进行调度时，会被修改为 StackPreempt</span></span><br><span class="line">    <span class="comment">// 以触发抢占s</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// stackguard1 是在 C 栈增长 prologue 作对比的对象</span></span><br><span class="line">    <span class="comment">// 在 g0 和 gsignal 栈上，其值为 stack.lo+StackGuard</span></span><br><span class="line">    <span class="comment">// 在其它的栈上这个值是 ~0(按 0 取反)以触发 morestack 调用(并 crash)</span></span><br><span class="line">    stackguard1 <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    _panic         *_panic</span><br><span class="line">    _defer         *_defer</span><br><span class="line">    m              *m             <span class="comment">// 当前与 g 绑定的 m</span></span><br><span class="line">    sched          gobuf          <span class="comment">// goroutine 的现场</span></span><br><span class="line">    syscallsp      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp       <span class="keyword">uintptr</span>        <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    param          unsafe.Pointer <span class="comment">// wakeup 时的传入参数</span></span><br><span class="line">    atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">    stackLock      <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid           <span class="keyword">int64</span>  <span class="comment">// goroutine id</span></span><br><span class="line">    waitsince      <span class="keyword">int64</span>  <span class="comment">// g 被阻塞之后的近似时间</span></span><br><span class="line">    waitreason     <span class="keyword">string</span> <span class="comment">// if status==Gwaiting</span></span><br><span class="line">    schedlink      guintptr</span><br><span class="line">    preempt        <span class="keyword">bool</span>     <span class="comment">// 抢占标记，这个为 true 时，stackguard0 是等于 stackpreempt 的</span></span><br><span class="line">    throwsplit     <span class="keyword">bool</span>     <span class="comment">// must not split stack</span></span><br><span class="line">    raceignore     <span class="keyword">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">    sysblocktraced <span class="keyword">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">    sysexitticks   <span class="keyword">int64</span>    <span class="comment">// syscall 返回之后的 cputicks，用来做 tracing</span></span><br><span class="line">    traceseq       <span class="keyword">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">    tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">    lockedm        muintptr <span class="comment">// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上</span></span><br><span class="line">    sig            <span class="keyword">uint32</span></span><br><span class="line">    writebuf       []<span class="keyword">byte</span></span><br><span class="line">    sigcode0       <span class="keyword">uintptr</span></span><br><span class="line">    sigcode1       <span class="keyword">uintptr</span></span><br><span class="line">    sigpc          <span class="keyword">uintptr</span></span><br><span class="line">    gopc           <span class="keyword">uintptr</span> <span class="comment">// 创建该 goroutine 的语句的指令地址</span></span><br><span class="line">    startpc        <span class="keyword">uintptr</span> <span class="comment">// goroutine 函数的指令地址</span></span><br><span class="line">    racectx        <span class="keyword">uintptr</span></span><br><span class="line">    waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">    cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">    labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">    timer          *timer         <span class="comment">// time.Sleep 缓存的定时器</span></span><br><span class="line">    selectDone     <span class="keyword">uint32</span>         <span class="comment">// 该 g 是否正在参与 select，是否已经有人从 select 中胜出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 g 遇到阻塞，或需要等待的场景时，会被打包成 sudog 这样一个结构。一个 g 可能被打包为多个 sudog 分别挂在不同的等待队列上:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog 代表在等待列表里的 g，比如向 channel 发送/接收内容时</span></span><br><span class="line"><span class="comment">// 之所以需要 sudog 是因为 g 和同步对象之间的关系是多对多的</span></span><br><span class="line"><span class="comment">// 一个 g 可能会在多个等待队列中，所以一个 g 可能被打包为多个 sudog</span></span><br><span class="line"><span class="comment">// 多个 g 也可以等待在同一个同步对象上</span></span><br><span class="line"><span class="comment">// 因此对于一个同步对象就会有很多 sudog 了</span></span><br><span class="line"><span class="comment">// sudog 是从一个特殊的池中进行分配的。用 acquireSudog 和 releaseSudog 来分配和释放 sudog</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的这些字段都是被该 g 所挂在的 channel 中的 hchan.lock 来保护的</span></span><br><span class="line">    <span class="comment">// shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isSelect 表示一个 g 是否正在参与 select 操作</span></span><br><span class="line">    <span class="comment">// 所以 g.selectDone 必须用 CAS 来操作，以胜出唤醒的竞争</span></span><br><span class="line">    isSelect <span class="keyword">bool</span></span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些字段则永远都不会被并发访问</span></span><br><span class="line">    <span class="comment">// 对于 channel 来说，waitlink 只会被 g 访问</span></span><br><span class="line">    <span class="comment">// 对于信号量来说，所有的字段，包括上面的那些字段都只在持有 semaRoot 锁时才可以访问</span></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span></span><br><span class="line">    parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在 runtime 中的结构，对应一个 pthread，pthread 也会对应唯一的内核线程(task_struct):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// 用来执行调度指令的 goroutine</span></span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">    procid        <span class="keyword">uint64</span>       <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    gsignal       *g           <span class="comment">// signal-handling g</span></span><br><span class="line">    goSigStack    gsignalStack <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">    sigmask       sigset       <span class="comment">// storage for saved signal mask</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    curg          *g       <span class="comment">// 当前运行的用户 goroutine</span></span><br><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    id            <span class="keyword">int64</span></span><br><span class="line">    mallocing     <span class="keyword">int32</span></span><br><span class="line">    throwing      <span class="keyword">int32</span></span><br><span class="line">    preemptoff    <span class="keyword">string</span> <span class="comment">// 该字段不等于空字符串的话，要保持 curg 始终在这个 m 上运行</span></span><br><span class="line">    locks         <span class="keyword">int32</span></span><br><span class="line">    softfloat     <span class="keyword">int32</span></span><br><span class="line">    dying         <span class="keyword">int32</span></span><br><span class="line">    profilehz     <span class="keyword">int32</span></span><br><span class="line">    helpgc        <span class="keyword">int32</span></span><br><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// m 失业了，正在积极寻找工作~</span></span><br><span class="line">    blocked       <span class="keyword">bool</span> <span class="comment">// m 正阻塞在 note 上</span></span><br><span class="line">    inwb          <span class="keyword">bool</span> <span class="comment">// m 正在执行 write barrier</span></span><br><span class="line">    newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">    printlock     <span class="keyword">int8</span></span><br><span class="line">    incgo         <span class="keyword">bool</span>   <span class="comment">// m 正在执行 cgo call</span></span><br><span class="line">    freeWait      <span class="keyword">uint32</span> <span class="comment">// if == 0, safe to free g0 and delete m (atomic)</span></span><br><span class="line">    fastrand      [<span class="number">2</span>]<span class="keyword">uint32</span></span><br><span class="line">    needextram    <span class="keyword">bool</span></span><br><span class="line">    traceback     <span class="keyword">uint8</span></span><br><span class="line">    ncgocall      <span class="keyword">uint64</span>      <span class="comment">// cgo 调用总计数</span></span><br><span class="line">    ncgo          <span class="keyword">int32</span>       <span class="comment">// 当前正在执行的 cgo 订单计数</span></span><br><span class="line">    cgoCallersUse <span class="keyword">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">    cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line">    park          note</span><br><span class="line">    alllink       *m <span class="comment">// on allm</span></span><br><span class="line">    schedlink     muintptr</span><br><span class="line">    mcache        *mcache</span><br><span class="line">    lockedg       guintptr</span><br><span class="line">    createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span>    <span class="comment">// stack that created this thread.</span></span><br><span class="line">    freglo        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] lsb and f[i]</span></span><br><span class="line">    freghi        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] msb and f[i+16]</span></span><br><span class="line">    fflag         <span class="keyword">uint32</span>         <span class="comment">// floating point compare flags</span></span><br><span class="line">    lockedExt     <span class="keyword">uint32</span>         <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">    lockedInt     <span class="keyword">uint32</span>         <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">    nextwaitm     muintptr       <span class="comment">// 正在等待锁的下一个 m</span></span><br><span class="line">    waitunlockf   unsafe.Pointer <span class="comment">// todo go func(*g, unsafe.pointer) bool</span></span><br><span class="line">    waitlock      unsafe.Pointer</span><br><span class="line">    waittraceev   <span class="keyword">byte</span></span><br><span class="line">    waittraceskip <span class="keyword">int</span></span><br><span class="line">    startingtrace <span class="keyword">bool</span></span><br><span class="line">    syscalltick   <span class="keyword">uint32</span></span><br><span class="line">    thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line">    freelink      *m      <span class="comment">// on sched.freem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are here because they are too large to be on the stack</span></span><br><span class="line">    <span class="comment">// of low-level NOSPLIT functions.</span></span><br><span class="line">    libcall   libcall</span><br><span class="line">    libcallpc <span class="keyword">uintptr</span> <span class="comment">// for cpu profiler</span></span><br><span class="line">    libcallsp <span class="keyword">uintptr</span></span><br><span class="line">    libcallg  guintptr</span><br><span class="line">    syscall   libcall <span class="comment">// 存储 windows 平台的 syscall 参数</span></span><br><span class="line"></span><br><span class="line">    mOS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象数据结构，可以认为是 processor 的抽象，代表了任务执行时的上下文，m 必须获得 p 才能执行:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// 每次调用 schedule 时会加一</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// 每次系统调用时加一</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// 上次 sysmon 观察到的 tick 时间</span></span><br><span class="line">    m           muintptr   <span class="comment">// 和相关联的 m 的反向指针，如果 p 是 idle 的话，那这个指针是 nil</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">    racectx     <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runnable 状态的 goroutine。访问时是不加锁的</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// runnext 非空时，代表的是一个 runnable 状态的 G，</span></span><br><span class="line">    <span class="comment">// 这个 G 是被 当前 G 修改为 ready 状态的，</span></span><br><span class="line">    <span class="comment">// 并且相比在 runq 中的 G 有更高的优先级</span></span><br><span class="line">    <span class="comment">// 如果当前 G 的还有剩余的可用时间，那么就应该运行这个 G</span></span><br><span class="line">    <span class="comment">// 运行之后，该 G 会继承当前 G 的剩余时间</span></span><br><span class="line">    <span class="comment">// If a set of goroutines is locked in a</span></span><br><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    gfree    *g</span><br><span class="line">    gfreecnt <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">    <span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">    <span class="comment">// has actually been swept.</span></span><br><span class="line">    traceSweep <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">    <span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">    traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-P GC state</span></span><br><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker</span></span><br><span class="line">    gcBgMarkWorker       guintptr</span><br><span class="line">    gcMarkWorkerMode     gcMarkWorkerMode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前标记 worker 的开始时间，单位纳秒</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">    wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">    pad [sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局调度器，全局只有一个 schedt 类型的实例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 下面两个变量需以原子访问访问。保持在 struct 顶部，以使其在 32 位系统上可以对齐</span></span><br><span class="line">    goidgen  <span class="keyword">uint64</span></span><br><span class="line">    lastpoll <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当修改 nmidle，nmidlelocked，nmsys，nmfreed 这些数值时</span></span><br><span class="line">    <span class="comment">// 需要记得调用 checkdead</span></span><br><span class="line"></span><br><span class="line">    midle        muintptr <span class="comment">// idle m's waiting for work</span></span><br><span class="line">    nmidle       <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的空闲 m 计数</span></span><br><span class="line">    nmidlelocked <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的被 lock 的 m 计数</span></span><br><span class="line">    mnext        <span class="keyword">int64</span>    <span class="comment">// 当前预缴创建的 m 数，并且该值会作为下一个创建的 m 的 ID</span></span><br><span class="line">    maxmcount    <span class="keyword">int32</span>    <span class="comment">// 允许创建的最大的 m 数量</span></span><br><span class="line">    nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">    nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">    ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">    pidle      puintptr <span class="comment">// 空闲 p's</span></span><br><span class="line">    npidle     <span class="keyword">uint32</span></span><br><span class="line">    nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局的可运行 g 队列</span></span><br><span class="line">    runqhead guintptr</span><br><span class="line">    runqtail guintptr</span><br><span class="line">    runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dead G 的全局缓存</span></span><br><span class="line">    gflock       mutex</span><br><span class="line">    gfreeStack   *g</span><br><span class="line">    gfreeNoStack *g</span><br><span class="line">    ngfree       <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sudog 结构的集中缓存</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同大小的可用的 defer struct 的集中缓存池</span></span><br><span class="line">    deferlock mutex</span><br><span class="line">    deferpool [<span class="number">5</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被设置了 m.exited 标记之后的 m，这些 m 正在 freem 这个链表上等待被 free</span></span><br><span class="line">    <span class="comment">// 链表用 m.freelink 字段进行链接</span></span><br><span class="line">    freem *m</span><br><span class="line"></span><br><span class="line">    gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run</span></span><br><span class="line">    stopwait   <span class="keyword">int32</span></span><br><span class="line">    stopnote   note</span><br><span class="line">    sysmonwait <span class="keyword">uint32</span></span><br><span class="line">    sysmonnote note</span><br><span class="line"></span><br><span class="line">    <span class="comment">// safepointFn should be called on each P at the next GC</span></span><br><span class="line">    <span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line">    safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span><br><span class="line">    safePointWait <span class="keyword">int32</span></span><br><span class="line">    safePointNote note</span><br><span class="line"></span><br><span class="line">    profilehz <span class="keyword">int32</span> <span class="comment">// cpu profiling rate</span></span><br><span class="line"></span><br><span class="line">    procresizetime <span class="keyword">int64</span> <span class="comment">// 上次修改 gomaxprocs 的纳秒时间</span></span><br><span class="line">    totaltime      <span class="keyword">int64</span> <span class="comment">// ∫gomaxprocs dt up to procresizetime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="g-p-m-的关系"><a href="#g-p-m-的关系" class="headerlink" title="g/p/m 的关系"></a>g/p/m 的关系</h2><p>Go 实现了所谓的 M:N 模型，执行用户代码的 goroutine 可以认为都是对等的 goroutine。不考虑 g0 和 gsignal 的话，我们可以简单地认为调度就是将 m 绑定到 p，然后在 m 中不断循环执行调度函数(runtime.schedule)，寻找可用的 g 来执行，下图为 m 绑定到 p 时，可能得到的 g 的来源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">                                  +---------+</span><br><span class="line">                                  | binded  +-------------+</span><br><span class="line">                                  +----+----+             |</span><br><span class="line">+------------------------------+       |                  v                 +-----------------------------+</span><br><span class="line">|                              |       |       +-------------------------+  |                             |</span><br><span class="line">|         +------------------+ |       |       |                         |  |        +------------------+ |</span><br><span class="line">|         | Local Run Queue  | |       |       |    +------------------+ |  |        | Global Run Queue | |</span><br><span class="line">| other P +-+-+-+-+-+-+-+-+--+ |       |       | P  | Local Run Queue  | |  | schedt +--+-+-+-+-+-+-+---+ |</span><br><span class="line">|           |G|G|G|G|G|G|G|    |       |       |    +-+-+-+-+-+-+-+-+--+ |  |           |G|G|G|G|G|G|     |</span><br><span class="line">|           +-+-+-+-+-+-+-+    |       |       |      |G|G|G|G|G|G|G|    |  |           +-+-+-+-+-+-+     |</span><br><span class="line">|            ^                 |       |       |      +-+-+-+-+-+-+-+    |  |            ^                |</span><br><span class="line">+------------+-----------------+       |       |       ^                 |  +------------+----------------+</span><br><span class="line">             |                         |       +-------+-----------------+               |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         v                              |                  |</span><br><span class="line">      +------+-------+                .-.      +----------------+     |                  |</span><br><span class="line">      |    steal     +---------------( M )-----+    runqget     +-----+                  |</span><br><span class="line">      +--------------+                `-&apos;      +----------------+                        |</span><br><span class="line">                                       |                                                 |</span><br><span class="line">                                       |                                         +-------+---------+</span><br><span class="line">                                       +-----------------------------------------+   globrunqget   |</span><br><span class="line">                                       |                                         +-----------------+</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                            +----------+--------+</span><br><span class="line">                            |   get netpoll g   |</span><br><span class="line">                            +----------+--------+</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                        +--------------+--------------+</span><br><span class="line">                        |              |              |</span><br><span class="line">                        |   netpoll    v              |</span><br><span class="line">                        |             +-+-+-+-+       |</span><br><span class="line">                        |             |G|G|G|G|       |</span><br><span class="line">                        |             +-+-+-+-+       |</span><br><span class="line">                        +-----------------------------+</span><br></pre></td></tr></table></figure>


<p>这张图展示了 g、p、m 三者之间的大致关系。m 是执行实体，对应的是操作系统线程。可以看到 m 会从绑定的 p 的本地队列、sched 中的全局队列、netpoll 中获取可运行的 g，实在找不着还会去其它的 p 那里去偷。</p>
<h2 id="p-如何初始化"><a href="#p-如何初始化" class="headerlink" title="p 如何初始化"></a>p 如何初始化</h2><p>程序启动时，会依次调用：</p>
<pre class="mermaid">graph TD
runtime.schedinit -->  runtime.procresize</pre>

<p>在 procresize 中会将全局 p 数组初始化，并将这些 p 串成链表放进 sched 全局调度器的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    p := allp[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置 p 的状态</span></span><br><span class="line">    p.status = _Pidle</span><br><span class="line">    <span class="comment">// 初始化时，所有 p 的 runq 都是空的，所以一定会走这个 if</span></span><br><span class="line">    <span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line">        <span class="comment">// 将 p 放到全局调度器的 pidle 队列中</span></span><br><span class="line">        pidleput(p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pidleput 也比较简单，没啥可说的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">        throw(<span class="string">"pidleput: P has non-empty run queue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简单的链表操作</span></span><br><span class="line">    _p_.link = sched.pidle</span><br><span class="line">    sched.pidle.set(_p_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pidle count + 1</span></span><br><span class="line">    atomic.Xadd(&amp;sched.npidle, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 p 在程序启动的时候就已经被初始化完毕了，除非手动调用 runtime.GOMAXPROCS。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    ret := <span class="keyword">int</span>(gomaxprocs)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> || n == ret &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopTheWorld(<span class="string">"GOMAXPROCS"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newprocs will be processed by startTheWorld</span></span><br><span class="line">    newprocs = <span class="keyword">int32</span>(n)</span><br><span class="line"></span><br><span class="line">    startTheWorld()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startTheWorld 中会调用 procresize。</p>
<h2 id="g-如何创建"><a href="#g-如何创建" class="headerlink" title="g 如何创建"></a>g 如何创建</h2><p>在用户代码里一般这么写:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// do the stuff</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>实际上会被翻译成 <code>runtime.newproc</code>，特权语法只是个语法糖。如果你要在其它语言里实现类似的东西，只要实现编译器翻译之后的内容就好了。具体流程:</p>
<pre class="mermaid">graph TD
runtime.newproc --> runtime.newproc1</pre>

<p>newproc 干的事情也比较简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// add 是一个指针运算，跳过函数指针</span></span><br><span class="line">    <span class="comment">// 把栈上的参数起始地址找到</span></span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, pc)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// funcval 是一个变长结构，第一个成员是函数指针</span></span><br><span class="line"><span class="comment">// 所以上面的 add 是跳过这个 fn</span></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">    fn <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 里比较常见的 getcallerpc 和 getcallersp，代码里的注释写的比较明白了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func f(arg1, arg2, arg3 int) &#123;</span></span><br><span class="line"><span class="comment">//    pc := getcallerpc()</span></span><br><span class="line"><span class="comment">//    sp := getcallersp(unsafe.Pointer(&amp;arg1))</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// These two lines find the PC and SP immediately following</span></span><br><span class="line"><span class="comment">// the call to f (where f will return).</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>getcallerpc 返回的是调用函数之后的那条程序指令的地址，即 callee 函数返回时要执行的下一条指令的地址。</p>
<p>systemstack 在 runtime 中用的也比较多，其功能为让 m 切换到 g0 上执行各种调度函数。至于啥是 g0，在讲 m 的时候再说。</p>
<p>newproc1 的工作流程也比较简单:</p>
<pre class="mermaid">graph TD
newproc1 --> newg
newg[gfget] --> nil{is nil?}
nil -->|yes|E[init stack]
nil -->|no|C[malg]
C --> D[set g status=> idle->dead]
D --> allgadd
E --> G[set g status=> dead-> runnable]
allgadd --> G
G --> runqput</pre>

<p>删掉了不关心的细节后的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        _g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">        throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">    siz := narg</span><br><span class="line">    siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    newg := gfget(_p_)</span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        newg = malg(_StackMin)</span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">    totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line">    spArg := sp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 g，g 的 gobuf 现场，g 的 m 的 curg</span></span><br><span class="line">    <span class="comment">// 以及各种寄存器</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    newg.sched.sp = sp</span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line">    <span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">        newg.labels = _g_.m.curg.labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">    newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">    _p_.goidcache++</span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">        _g_.stackguard0 = stackPreempt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>go func</code> 执行的结果是调用 runqput 将 g 放进了执行队列。但在放队列之前还做了点小动作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br></pre></td></tr></table></figure>

<h3 id="gostartcallfn"><a href="#gostartcallfn" class="headerlink" title="gostartcallfn"></a>gostartcallfn</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn = unsafe.Pointer(fv.fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">    &#125;</span><br><span class="line">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    sp := buf.sp</span><br><span class="line">    <span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">        sp -= sys.PtrSize</span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sp -= sys.PtrSize</span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc <span class="comment">// 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span></span><br><span class="line">    buf.sp = sp</span><br><span class="line">    buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">    buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>
<p>在之后的 m 的 schedule 讲解中会看到更详细的调度循环过程。</p>
<h3 id="runqput"><a href="#runqput" class="headerlink" title="runqput"></a>runqput</h3><p>因为是放 runq 而不是直接执行，因而什么时候开始执行并不是用户代码能决定得了的。再看看 runqput 这个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runqput 尝试把 g 放到本地执行队列中</span></span><br><span class="line"><span class="comment">// next 参数如果是 false 的话，runqput 会将 g 放到运行队列的尾部</span></span><br><span class="line"><span class="comment">// If next if false, runqput adds g to the tail of the runnable queue.</span></span><br><span class="line"><span class="comment">// If next is true, runqput puts g in the _p_.runnext slot.</span></span><br><span class="line"><span class="comment">// If the run queue is full, runnext puts g on the global queue.</span></span><br><span class="line"><span class="comment">// Executed only by the owner P.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(_p_ *p, gp *g, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> next &#123;</span><br><span class="line">    retryNext:</span><br><span class="line">        oldnext := _p_.runnext</span><br><span class="line">        <span class="keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> retryNext</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把之前的 runnext 踢到正常的 runq 中</span></span><br><span class="line">        gp = oldnext.ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">    t := _p_.runqtail</span><br><span class="line">    <span class="keyword">if</span> t-h &lt; <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">        _p_.runq[t%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span><br><span class="line">        atomic.Store(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列没有满的话，上面的 put 操作会成功</span></span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runqputslow"><a href="#runqputslow" class="headerlink" title="runqputslow"></a>runqputslow</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 slow，所以会一次性把本地队列里的多个 g (包含当前的这个) 放到全局队列</span></span><br><span class="line"><span class="comment">// 只会被 g 的 owner P 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(_p_ *p, gp *g, h, t <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch [<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从本地队列抓一批 g</span></span><br><span class="line">    n := t - h</span><br><span class="line">    n = n / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">        throw(<span class="string">"runqputslow: queue is not full"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i] = _p_.runq[(h+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;_p_.runqhead, h, h+n) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    batch[n] = gp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">1</span>); i &lt;= n; i++ &#123;</span><br><span class="line">            j := fastrandn(i + <span class="number">1</span>)</span><br><span class="line">            batch[i], batch[j] = batch[j], batch[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这些 goroutine 构造成链表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表放到全局队列中</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqputbatch(batch[<span class="number">0</span>], batch[n], <span class="keyword">int32</span>(n+<span class="number">1</span>))</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作全局 sched 时，需要获取全局 sched.lock 锁，全局锁争抢的开销较大，所以才称之为 slow。p 和 g 在 m 中交互时，因为现场永远是单线程，所以很多时候不用加锁。</p>
<h2 id="m-工作机制"><a href="#m-工作机制" class="headerlink" title="m 工作机制"></a>m 工作机制</h2><p>在 runtime 中有三种线程，一种是主线程，一种是用来跑 sysmon 的线程，一种是普通的用户线程。主线程在 runtime 由对应的全局变量: <code>runtime.m0</code> 来表示。用户线程就是普通的线程了，和 p 绑定，执行 g 中的任务。虽然说是有三种，实际上前两种线程整个 runtime 就只有一个实例。用户线程才会有很多实例。</p>
<h3 id="主线程-m0"><a href="#主线程-m0" class="headerlink" title="主线程 m0"></a>主线程 m0</h3><p>主线程中用来跑 <code>runtime.main</code>，流程线性执行，没有跳转:</p>
<pre class="mermaid">graph TD
runtime.main --> A[init max stack size]
A --> B[systemstack execute -> newm -> sysmon]
B --> runtime.lockOsThread
runtime.lockOsThread --> runtime.init
runtime.init --> runtime.gcenable
runtime.gcenable --> main.init
main.init --> main.main</pre>

<h3 id="sysmon-线程"><a href="#sysmon-线程" class="headerlink" title="sysmon 线程"></a>sysmon 线程</h3><p>sysmon 是在 <code>runtime.main</code> 中启动的，不过需要注意的是 sysmon 并不是在 m0 上执行的。因为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建了新的 m，但这个 m 又与普通的线程不一样，因为不需要绑定 p 就可以执行。是与整个调度系统脱离的。</p>
<p>sysmon 内部是个死循环，主要负责以下几件事情:</p>
<ol>
<li><p>checkdead，检查是否所有 goroutine 都已经锁死，如果是的话，直接调用 runtime.throw，强制退出。这个操作只在启动的时候做一次</p>
</li>
<li><p>将 netpoll 返回的结果注入到全局 sched 的任务队列</p>
</li>
<li><p>收回因为 syscall 而长时间阻塞的 p，同时抢占那些执行时间过长的 g</p>
</li>
<li><p>如果 span 内存闲置超过 5min，那么释放掉</p>
</li>
</ol>
<p>流程图:</p>
<pre class="mermaid">graph TD
sysmon --> usleep
usleep --> checkdead
checkdead --> |every 10ms|C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> injectglist
injectglist --> retake
C --> |no|retake
retake --> A[check forcegc needed]
A --> B[scavenge heap once in a while]
B --> usleep</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysmon 不需要绑定 P 就可以运行，所以不允许 write barriers</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.nmsys++</span><br><span class="line">    checkdead()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个 heap span 在一次GC 之后 5min 都没有被使用过</span></span><br><span class="line">    <span class="comment">// 那么把它交还给操作系统</span></span><br><span class="line">    scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Scavenge-a-lot for testing.</span></span><br><span class="line">        forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span><br><span class="line">        scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastscavenge := nanotime()</span><br><span class="line">    nscavenge := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">    idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">    delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// 初始化时 20us sleep</span></span><br><span class="line">            delay = <span class="number">20</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">            delay *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// 最多到 10ms</span></span><br><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(delay)</span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="comment">// Make wake-up period small enough</span></span><br><span class="line">                <span class="comment">// for the sampling to be correct.</span></span><br><span class="line">                maxsleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> scavengelimit &lt; forcegcperiod &#123;</span><br><span class="line">                    maxsleep = scavengelimit / <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                shouldRelax := <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> osRelaxMinNS &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    next := timeSleepUntil()</span><br><span class="line">                    now := nanotime()</span><br><span class="line">                    <span class="keyword">if</span> next-now &lt; osRelaxMinNS &#123;</span><br><span class="line">                        shouldRelax = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                    osRelax(<span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                notetsleep(&amp;sched.sysmonnote, maxsleep)</span><br><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                    osRelax(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                lock(&amp;sched.lock)</span><br><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">                noteclear(&amp;sched.sysmonnote)</span><br><span class="line">                idle = <span class="number">0</span></span><br><span class="line">                delay = <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 10ms 没有 poll 过 network，那么就 netpoll 一次</span></span><br><span class="line">        lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">            atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">            gp := netpoll(<span class="literal">false</span>) <span class="comment">// 非阻塞 -- 返回一个 goroutine 的列表</span></span><br><span class="line">            <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line">                <span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">                <span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">                <span class="comment">// injectglist grabs all P's but before it starts M's to run the P's,</span></span><br><span class="line">                <span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">                <span class="comment">// observes that there is no work to do and no other running M's</span></span><br><span class="line">                <span class="comment">// and reports deadlock.</span></span><br><span class="line">                incidlelocked(<span class="number">-1</span>)</span><br><span class="line">                injectglist(gp)</span><br><span class="line">                incidlelocked(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收在 syscall 状态阻塞的 P</span></span><br><span class="line">        <span class="comment">// 抢占长时间运行的 G</span></span><br><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">            idle = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            idle++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否需要 force GC(两分钟一次的)</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            forcegc.idle = <span class="number">0</span></span><br><span class="line">            forcegc.g.schedlink = <span class="number">0</span></span><br><span class="line">            injectglist(forcegc.g)</span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每过一段时间扫描一次堆</span></span><br><span class="line">        <span class="keyword">if</span> lastscavenge+scavengelimit/<span class="number">2</span> &lt; now &#123;</span><br><span class="line">            mheap_.scavenge(<span class="keyword">int32</span>(nscavenge), <span class="keyword">uint64</span>(now), <span class="keyword">uint64</span>(scavengelimit))</span><br><span class="line">            lastscavenge = now</span><br><span class="line">            nscavenge++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">            lasttrace = now</span><br><span class="line">            schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkdead"><a href="#checkdead" class="headerlink" title="checkdead"></a>checkdead</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查死锁的场景</span></span><br><span class="line"><span class="comment">// 该检查基于当前正在运行的 M 的数量，如果 0，那么就是 deadlock 了</span></span><br><span class="line"><span class="comment">// 检查的时候必须持有 sched.lock 锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对于 -buildmode=c-shared 或者 -buildmode=c-archive 来说</span></span><br><span class="line">    <span class="comment">// 没有 goroutine 正在运行也是 OK 的。因为调用这个库的程序应该是在运行的</span></span><br><span class="line">    <span class="keyword">if</span> islibrary || isarchive &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are dying because of a signal caught on an already idle thread,</span></span><br><span class="line">    <span class="comment">// freezetheworld will cause all running threads to block.</span></span><br><span class="line">    <span class="comment">// And runtime will essentially enter into deadlock state,</span></span><br><span class="line">    <span class="comment">// except that there is a thread that will call exit soon.</span></span><br><span class="line">    <span class="keyword">if</span> panicking &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</span><br><span class="line">    <span class="keyword">if</span> run &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> run &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: checkdead: nmidle="</span>, sched.nmidle, <span class="string">" nmidlelocked="</span>, sched.nmidlelocked, <span class="string">" mcount="</span>, mcount(), <span class="string">" nmsys="</span>, sched.nmsys, <span class="string">"\n"</span>)</span><br><span class="line">        throw(<span class="string">"checkdead: inconsistent counts"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grunning := <span class="number">0</span></span><br><span class="line">    lock(&amp;allglock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allgs); i++ &#123;</span><br><span class="line">        gp := allgs[i]</span><br><span class="line">        <span class="keyword">if</span> isSystemGoroutine(gp) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        s := readgstatus(gp)</span><br><span class="line">        <span class="keyword">switch</span> s &amp;^ _Gscan &#123;</span><br><span class="line">        <span class="keyword">case</span> _Gwaiting:</span><br><span class="line">            grunning++</span><br><span class="line">        <span class="keyword">case</span> _Grunnable,</span><br><span class="line">            _Grunning,</span><br><span class="line">            _Gsyscall:</span><br><span class="line">            unlock(&amp;allglock)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"runtime: checkdead: find g "</span>, gp.goid, <span class="string">" in status "</span>, s, <span class="string">"\n"</span>)</span><br><span class="line">            throw(<span class="string">"checkdead: runnable g"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allglock)</span><br><span class="line">    <span class="keyword">if</span> grunning == <span class="number">0</span> &#123; <span class="comment">// possible if main goroutine calls runtime·Goexit()</span></span><br><span class="line">        throw(<span class="string">"no goroutines (main called runtime.Goexit) - deadlock!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maybe jump time forward for playground.</span></span><br><span class="line">    gp := timejump()</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        globrunqput(gp)</span><br><span class="line">        _p_ := pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">"checkdead: no p for timer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mp := mget()</span><br><span class="line">        <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// There should always be a free M since</span></span><br><span class="line">            <span class="comment">// nothing is running.</span></span><br><span class="line">            throw(<span class="string">"checkdead: no m for timer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mp.nextp.set(_p_)</span><br><span class="line">        notewakeup(&amp;mp.park)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getg().m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">    throw(<span class="string">"all goroutines are asleep - deadlock!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="retake"><a href="#retake" class="headerlink" title="retake"></a>retake</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forcePreemptNS is the time slice given to a G before it is</span></span><br><span class="line"><span class="comment">// preempted.</span></span><br><span class="line"><span class="keyword">const</span> forcePreemptNS = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> <span class="comment">// 10ms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="comment">// Prevent allp slice changes. This lock will be completely</span></span><br><span class="line">    <span class="comment">// uncontended unless we're already stopping the world.</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// We can't use a range loop over allp because we may</span></span><br><span class="line">    <span class="comment">// temporarily drop the allpLock. Hence, we need to re-fetch</span></span><br><span class="line">    <span class="comment">// allp each time around the loop.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 在 procresize 修改了 allp 但还没有创建新的 p 的时候</span></span><br><span class="line">            <span class="comment">// 会有这种情况</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        s := _p_.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// 从 syscall 接管 P，如果它进行 syscall 已经经过了一个 sysmon 的 tick(至少 20us)</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.syscalltick)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                pd.syscalltick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一方面如果没有其它工作可做的话，我们不想接管 p</span></span><br><span class="line">            <span class="comment">// 但另一方面为了避免 sysmon 线程陷入沉睡，我们最终还是会接管这些 p</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解开 allplock 的锁，然后就可以持有 sched.lock 锁了</span></span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line">            <span class="comment">// (pretending that one more is running) before the CAS.</span></span><br><span class="line">            <span class="comment">// Otherwise the M from which we retake can exit the syscall,</span></span><br><span class="line">            <span class="comment">// increment nmidle and report deadlock.</span></span><br><span class="line">            incidlelocked(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoSysBlock(_p_)</span><br><span class="line">                    traceProcStop(_p_)</span><br><span class="line">                &#125;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123;</span><br><span class="line">            <span class="comment">// 如果 G 运行时间太长，那么抢占它</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            preemptone(_p_)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h3><p>普通线程就是我们 G/P/M 模型里的 M 了，M 对应的就是操作系统的线程。</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>上面在创建 sysmon 线程的时候也看到了，创建线程的函数是 newm。</p>
<pre class="mermaid">graph TD
newm --> newm1
newm1 --> newosproc
newosproc --> clone</pre>

<p>最终会走到 linux 创建线程的系统调用 <code>clone</code>，代码里大段和 cgo 相关的内容我们就不关心了，摘掉 cgo 相关的逻辑后的代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 m。该 m 会在启动时调用函数 fn，或者 schedule 函数</span></span><br><span class="line"><span class="comment">// fn 需要是 static 类型，且不能是在堆上分配的闭包。</span></span><br><span class="line"><span class="comment">// 运行 m 时，m.p 是有可能为 nil 的，所以不允许 write barriers</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">    mp := allocm(_p_, fn)</span><br><span class="line">    mp.nextp.set(_p_)</span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 p 会被赋值给 m 的 nextp 成员，在 m 执行 schedule 时，会将 nextp 拿出来，进行之后真正的绑定操作(其实就是把 nextp 赋值为 nil，并把这个 nextp 赋值给 m.p，把 m 赋值给 p.m)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">    newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m, stk unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Disable signals during clone, so that the new thread starts</span></span><br><span class="line">    <span class="comment">// with signals disabled. It will enable them in minit.</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: failed to create new OS thread (have "</span>, mcount(), <span class="string">" already; errno="</span>, -ret, <span class="string">")\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> ret == -_EAGAIN &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"runtime: may need to increase max user processes (ulimit -u)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">"newosproc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>首先空闲的 m 会被丢进全局调度器的 midle 队列中，在需要 m 的时候，会先从这里取:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">// 尝试从 midle 列表中获取一个 m</span></span><br><span class="line"><span class="comment">// 必须锁全局的 sched</span></span><br><span class="line"><span class="comment">// 可能在 STW 期间执行，所以不允许 write barriers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span> *<span class="title">m</span></span> &#123;</span><br><span class="line">    mp := sched.midle.ptr()</span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.midle = mp.schedlink</span><br><span class="line">        sched.nmidle--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取不到的话就会调用之前提到的 newm 来创建新线程，创建的线程是不会被销毁的，哪怕之后不需要这么多 m 了，也就只是会把 m 放在 midle 中。</p>
<p>什么时候会创建线程呢，可以追踪一下 newm 的调用方:</p>
<pre class="mermaid">graph TD
main --> |sysmon|newm
startTheWorld --> startTheWorldWithSema
gcMarkTermination --> startTheWorldWithSema
gcStart--> startTheWorldWithSema
startTheWorldWithSema --> |helpgc|newm
startTheWorldWithSema --> |run p|newm
startm --> mget
mget --> |if no free m|newm
startTemplateThread --> |templateThread|newm
LockOsThread --> startTemplateThread
main --> |iscgo|startTemplateThread
handoffp --> startm
wakep --> startm
injectglist --> startm</pre>

<p>基本上来讲，m 都是按需创建的。如果 sched.midle 中没有空闲的 m 了，现在又需要，那么就会去创建一个。</p>
<p>创建好的线程需要绑定到 p 之后才会开始执行，执行过程中也可能被剥夺掉 p。比如前面 retake 的流程，就会将 g 的 stackguard0 修改为 stackPreempt，待下一次进入 newstack 时，会判断是否有该抢占标记，有的话，就会放弃运行。这也就是所谓的<code>协作式抢占</code>。</p>
<p>工作线程执行的内容核心其实就只有俩: <code>schedule()</code> 和 <code>findrunnable()</code>。</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><pre class="mermaid">graph TD
schedule --> A[schedtick%61 == 0]
A --> |yes|globrunqget
A --> |no|runqget
globrunqget --> C[gp == nil]
C --> |no|execute
C --> |yes|runqget
runqget --> B[gp == nil]
B --> |no|execute
B --> |yes|findrunnable
findrunnable --> execute</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度器调度一轮要执行的函数: 寻找一个 runnable 状态的 goroutine，并 execute 它</span></span><br><span class="line"><span class="comment">// 调度函数是循环，永远都不会返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 cgo 调用的 g 不能被 schedule 走</span></span><br><span class="line">    <span class="comment">// 因为 cgo 调用使用 m 的 g0 栈</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">        gp = traceReader()</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 每调度几次就检查一下全局的 runq 来确保公平</span></span><br><span class="line">        <span class="comment">// 否则两个 goroutine 就可以通过互相调用</span></span><br><span class="line">        <span class="comment">// 完全占用本地的 runq 了</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// 在找到 goroutine 之前会一直阻塞下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程将要执行 goroutine，并且不会再进入 spinning 状态</span></span><br><span class="line">    <span class="comment">// 所以如果它被标记为 spinning，我们需要 reset 这个状态</span></span><br><span class="line">    <span class="comment">// 可能会重启一个新的 spinning 状态的 M</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">        <span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">        startlockedm(gp)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m 中所谓的调度循环实际上就是一直在执行下图中的 loop:</p>
<pre class="mermaid">graph TD
schedule --> execute
execute --> gogo
gogo --> goexit
goexit --> goexit1
goexit1 --> goexit0
goexit0 --> schedule</pre>


<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span><br><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span><br><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span><br><span class="line"><span class="comment">// acquiring a P in several places.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg() <span class="comment">// 这个可能是 m 的 g0</span></span><br><span class="line"></span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        _g_.m.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.curg = gp <span class="comment">// 把当前 g 的位置让给 m</span></span><br><span class="line">    gp.m = _g_.m <span class="comment">// 把 gp 指向 m，建立双向关系</span></span><br><span class="line"></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，绑定 g 和 m，然后 gogo 执行绑定的 g 中的函数。</p>
<h4 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h4><p>runtime.gogo 是汇编完成的，功能就是执行 <code>go func()</code> 的这个 <code>func()</code>，可以看到功能主要是把 g 对象的 gobuf 里的内容搬到寄存器里。然后从 <code>gobuf.pc</code> 寄存器存储的指令位置开始继续向后执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void gogo(Gobuf*)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), BX        <span class="comment">// gobuf</span></span><br><span class="line">    MOVQ    gobuf_g(BX), DX</span><br><span class="line">    MOVQ    <span class="number">0</span>(DX), CX        <span class="comment">// make sure g != nil</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    DX, g(CX)</span><br><span class="line">    MOVQ    gobuf_sp(BX), SP    <span class="comment">// restore SP</span></span><br><span class="line">    MOVQ    gobuf_ret(BX), AX</span><br><span class="line">    MOVQ    gobuf_ctxt(BX), DX</span><br><span class="line">    MOVQ    gobuf_bp(BX), BP</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_sp(BX)    <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ret(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ctxt(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_bp(BX)</span><br><span class="line">    MOVQ    gobuf_pc(BX), BX</span><br><span class="line">    JMP    BX</span><br></pre></td></tr></table></figure>

<p>当然，这里还是有一些和手写汇编不太一样的，看着比较奇怪的地方，<code>gobuf_sp(BX)</code> 这种写法按说标准 plan9 汇编中 <code>gobuf_sp</code> 只是个 <code>symbol</code>，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？</p>
<p>实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span></span><br></pre></td></tr></table></figure>

<p>这下知道怎么回事了吧，链接器会帮助我们把这个换成偏移量。。</p>
<h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><p>Goexit :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goexit terminates the goroutine that calls it. No other goroutine is affected.</span></span><br><span class="line"><span class="comment">// Goexit runs all deferred calls before terminating the goroutine. Because Goexit</span></span><br><span class="line"><span class="comment">// is not a panic, any recover calls in those deferred functions will return nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calling Goexit from the main goroutine terminates that goroutine</span></span><br><span class="line"><span class="comment">// without func main returning. Since func main has not returned,</span></span><br><span class="line"><span class="comment">// the program continues execution of other goroutines.</span></span><br><span class="line"><span class="comment">// If all other goroutines exit, the program crashes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Run all deferred functions for the current goroutine.</span></span><br><span class="line">    <span class="comment">// This code is similar to gopanic, see that implementation</span></span><br><span class="line">    <span class="comment">// for detailed comments.</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d := gp._defer</span><br><span class="line">        <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d.started &#123;</span><br><span class="line">            <span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">                d._panic.aborted = <span class="literal">true</span></span><br><span class="line">                d._panic = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            d.fn = <span class="literal">nil</span></span><br><span class="line">            gp._defer = d.link</span><br><span class="line">            freedefer(d)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        d.started = <span class="literal">true</span></span><br><span class="line">        reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">        <span class="keyword">if</span> gp._defer != d &#123;</span><br><span class="line">            throw(<span class="string">"bad defer entry in Goexit"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d._panic = <span class="literal">nil</span></span><br><span class="line">        d.fn = <span class="literal">nil</span></span><br><span class="line">        gp._defer = d.link</span><br><span class="line">        freedefer(d)</span><br><span class="line">        <span class="comment">// Note: we ignore recovers here because Goexit isn't a panic</span></span><br><span class="line">    &#125;</span><br><span class="line">    goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racegoend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoEnd()</span><br><span class="line">    &#125;</span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br><span class="line">    CALL    runtime·goexit1(SB)    <span class="comment">// does not return</span></span><br><span class="line">    <span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br></pre></td></tr></table></figure>

<p>mcall :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func mcall(fn func(*g))</span></span><br><span class="line"><span class="comment">// Switch to m-&gt;g0's stack, call fn(g).</span></span><br><span class="line"><span class="comment">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span></span><br><span class="line"><span class="comment">// to keep running g.</span></span><br><span class="line">TEXT runtime·mcall(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">    MOVQ    fn+<span class="number">0</span>(FP), DI</span><br><span class="line"></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), AX    <span class="comment">// save state in g-&gt;sched</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), BX    <span class="comment">// caller's PC</span></span><br><span class="line">    MOVQ    BX, (g_sched+gobuf_pc)(AX)</span><br><span class="line">    LEAQ    fn+<span class="number">0</span>(FP), BX    <span class="comment">// caller's SP</span></span><br><span class="line">    MOVQ    BX, (g_sched+gobuf_sp)(AX)</span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_g)(AX)</span><br><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(AX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch to m-&gt;g0 &amp; its stack, call fn</span></span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">    MOVQ    g_m(BX), BX</span><br><span class="line">    MOVQ    m_g0(BX), SI</span><br><span class="line">    CMPQ    SI, AX    <span class="comment">// if g == m-&gt;g0 call badmcall</span></span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    MOVQ    $runtime·badmcall(SB), AX</span><br><span class="line">    JMP    AX</span><br><span class="line">    MOVQ    SI, g(CX)    <span class="comment">// g = m-&gt;g0</span></span><br><span class="line">    MOVQ    (g_sched+gobuf_sp)(SI), SP    <span class="comment">// sp = m-&gt;g0-&gt;sched.sp</span></span><br><span class="line">    PUSHQ    AX</span><br><span class="line">    MOVQ    DI, DX</span><br><span class="line">    MOVQ    <span class="number">0</span>(DI), DI</span><br><span class="line">    CALL    DI</span><br><span class="line">    POPQ    AX</span><br><span class="line">    MOVQ    $runtime·badmcall2(SB), AX</span><br><span class="line">    JMP    AX</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<h4 id="wakep"><a href="#wakep" class="headerlink" title="wakep"></a>wakep</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tries to add one more P to execute G's.</span></span><br><span class="line"><span class="comment">// Called when a G is made runnable (newproc, ready).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// be conservative about spinning threads</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules some M to run the p (creates an M if necessary).</span></span><br><span class="line"><span class="comment">// If p==nil, tries to get an idle P, if no idle P's does nothing.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">// If spinning is set, the caller has incremented nmspinning and startm will</span></span><br><span class="line"><span class="comment">// either decrement nmspinning or set m.spinning in the newly started M.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">        _p_ = pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">             unlock(&amp;sched.lock)</span><br><span class="line">             <span class="keyword">if</span> spinning &#123;</span><br><span class="line">                 <span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span><br><span class="line">                 <span class="comment">// so it's okay to just undo the increment and give up.</span></span><br><span class="line">                 <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                     throw(<span class="string">"startm: negative nmspinning"</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mp := mget()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">            fn = mspinning</span><br><span class="line">        &#125;</span><br><span class="line">        newm(fn, _p_)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        throw(<span class="string">"startm: m is spinning"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"startm: m has p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">        throw(<span class="string">"startm: p has runnable gs"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">    mp.spinning = spinning</span><br><span class="line">    mp.nextp.set(_p_)</span><br><span class="line">    notewakeup(&amp;mp.park)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="goroutine-挂起"><a href="#goroutine-挂起" class="headerlink" title="goroutine 挂起"></a>goroutine 挂起</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf.</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">// unlockf must not access this G's stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">string</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    gp := mp.curg</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">        throw(<span class="string">"gopark: bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mp.waitlock = lock</span><br><span class="line">    mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&amp;unlockf))</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    mp.waittraceev = traceEv</span><br><span class="line">    mp.waittraceskip = traceskip</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// can't do anything that might move the G between Ms here.</span></span><br><span class="line">    mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark gp ready to run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, traceskip)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark runnable.</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g-&gt;status in ready"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    runqput(_g_.m.p.ptr(), gp, next)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in Case we've cleared it in newstack</span></span><br><span class="line">        _g_.stackguard0 = stackPreempt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">"notesleep not on g0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ns := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span><br><span class="line">        ns = <span class="number">10e6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> atomic.Load(key32(&amp;n.key)) == <span class="number">0</span> &#123;</span><br><span class="line">        gp.m.blocked = <span class="literal">true</span></span><br><span class="line">        futexsleep(key32(&amp;n.key), <span class="number">0</span>, ns)</span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp.m.blocked = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// One-time notifications.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noteclear</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    n.key = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    old := atomic.Xchg(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"notewakeup - double wakeup ("</span>, old, <span class="string">")\n"</span>)</span><br><span class="line">        throw(<span class="string">"notewakeup - double wakeup"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    futexwakeup(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h4><p>findrunnable 比较复杂，流程图先把 gc 相关的省略掉了:</p>
<pre class="mermaid">graph TD
runqget --> A[gp == nil]
A --> |no|return
A --> |yes|globrunqget
globrunqget --> B[gp == nil]
B --> |no| return
B --> |yes| C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> K[gp == nil]
K --> |no|return
K --> |yes|runqsteal
C --> |no|runqsteal
runqsteal --> D[gp == nil]
D --> |no|return
D --> |yes|E[globrunqget]
E --> F[gp == nil]
F --> |no| return
F --> |yes| G[check all p's runq]
G --> H[runq is empty]
H --> |no|runqget
H --> |yes|I[netpoll]
I --> J[gp == nil]
J --> |no| return
J --> |yes| stopm
stopm --> runqget</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到一个可执行的 goroutine 来 execute</span></span><br><span class="line"><span class="comment">// 会尝试从其它的 P 那里偷 g，从全局队列中拿，或者 network 中 poll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">    <span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">    <span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">        <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">        asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 runq</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局 runq</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll network.</span></span><br><span class="line">    <span class="comment">// netpoll 是我们执行 work-stealing 之前的一个优化</span></span><br><span class="line">    <span class="comment">// 如果没有任何的 netpoll 等待者，或者线程被阻塞在 netpoll 中，我们可以安全地跳过这段逻辑</span></span><br><span class="line">    <span class="comment">// 如果在阻塞的线程中存在任何逻辑上的竞争(e.g. 已经从 netpoll 中返回，但还没有设置 lastpoll)</span></span><br><span class="line">    <span class="comment">// 该线程还是会将下面的 netpoll 阻塞住</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> gp := netpoll(<span class="literal">false</span>); gp != <span class="literal">nil</span> &#123; <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="comment">// netpoll 返回 goroutine 链表，用 schedlink 连接</span></span><br><span class="line">            injectglist(gp.schedlink.ptr())</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从其它 p 那里偷 g</span></span><br><span class="line">    procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// GOMAXPROCS=1 或者除了我们其它的 p 都是 idle</span></span><br><span class="line">        <span class="comment">// 新的工作可能从 syscall/cgocall，网络或者定时器中来。</span></span><br><span class="line">        <span class="comment">// 上面这些任务都不会被放到本地的 runq，所有没有可以 stealing 的点</span></span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果正在自旋的 M 的数量 &gt;= 忙着的 P，那么阻塞</span></span><br><span class="line">    <span class="comment">// 这是为了</span></span><br><span class="line">    <span class="comment">// 当 GOMAXPROCS 远大于 1，但程序的并行度又很低的时候</span></span><br><span class="line">    <span class="comment">// 防止过量的 CPU 消耗</span></span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">            <span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有可以干的事情。如果我们正在 GC 的标记阶段，可以安全地扫描和加深对象的颜色，</span></span><br><span class="line">    <span class="comment">// 这样可以进行空闲时间的标记，而不是直接放弃 P</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">        gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line">    <span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line">    <span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line">    <span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line">    allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 P 并阻塞</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">        throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pidleput(_p_)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line">    <span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line">    <span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line">    <span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line">    <span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line">    <span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line">    <span class="comment">// to run the goroutine.</span></span><br><span class="line">    <span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line">    <span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line">    <span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line">    <span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line">    <span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line">    <span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line">    wasSpinning := _g_.m.spinning</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查一下所有的 runq</span></span><br><span class="line">    <span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                    _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                    atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查 gc 空闲 g</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        _p_ = pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">            pidleput(_p_)</span><br><span class="line">            _p_ = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">            acquirep(_p_)</span><br><span class="line">            <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go back to idle GC check.</span></span><br><span class="line">            <span class="keyword">goto</span> stop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poll network</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp := netpoll(<span class="literal">true</span>) <span class="comment">// 阻塞到返回为止</span></span><br><span class="line">        atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                injectglist(gp.schedlink.ptr())</span><br><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            injectglist(gp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="m-和-p-解绑定"><a href="#m-和-p-解绑定" class="headerlink" title="m 和 p 解绑定"></a>m 和 p 解绑定</h2><h3 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h3><pre class="mermaid">graph TD

mexit --> A[is m0?]
A --> |yes|B[handoffp]
A --> |no| C[iterate allm]
C --> |m found|handoffp
C --> |m not found| throw

forEachP --> |p status == syscall| handoffp

stoplockedm --> handoffp

entersyscallblock --> entersyscallblock_handoff
entersyscallblock_handoff --> handoffp

retake --> |p status == syscall| handoffp</pre>

<p>最终会把 p 放回全局的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hands off P from syscall or locked M.</span></span><br><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	<span class="comment">// handoffp must start an M in any situation where</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run on _p_.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// if it has local work, start it straight away</span></span><br><span class="line">	<span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if it has GC work, start it straight away</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no local work, check that there are no spinning/idle M's,</span></span><br><span class="line">	<span class="comment">// otherwise our help is not required</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">		startm(_p_, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		_p_.status = _Pgcstop</span><br><span class="line">		sched.stopwait--</span><br><span class="line">		<span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">			notewakeup(&amp;sched.stopnote)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		sched.safePointFn(_p_)</span><br><span class="line">		sched.safePointWait--</span><br><span class="line">		<span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">			notewakeup(&amp;sched.safePointNote)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If this is the last running P and nobody is polling network,</span></span><br><span class="line">	<span class="comment">// need to wakeup another M to poll network.</span></span><br><span class="line">	<span class="keyword">if</span> sched.npidle == <span class="keyword">uint32</span>(gomaxprocs<span class="number">-1</span>) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="g-的状态迁移"><a href="#g-的状态迁移" class="headerlink" title="g 的状态迁移"></a>g 的状态迁移</h2><pre class="mermaid">graph LR
start{newg} --> Gidle
Gidle --> |oneNewExtraM|Gdead
Gidle --> |newproc1|Gdead

Gdead --> |newproc1|Grunnable
Gdead --> |needm|Gsyscall

Gscanrunning --> |scang|Grunning

Grunnable --> |execute|Grunning

Gany --> |casgcopystack|Gcopystack

Gcopystack --> |todotodo|Grunning

Gsyscall --> |dropm|Gdead
Gsyscall --> |exitsyscall0|Grunnable
Gsyscall --> |exitsyscall|Grunning

Grunning --> |goschedImpl|Grunnable
Grunning --> |goexit0|Gdead
Grunning --> |newstack|Gcopystack
Grunning --> |reentersyscall|Gsyscall
Grunning --> |entersyscallblock|Gsyscall
Grunning --> |markroot|Gwaiting
Grunning --> |gcAssistAlloc1|Gwaiting
Grunning --> |park_m|Gwaiting
Grunning --> |gcMarkTermination|Gwaiting
Grunning --> |gcBgMarkWorker|Gwaiting
Grunning --> |newstack|Gwaiting

Gwaiting --> |gcMarkTermination|Grunning
Gwaiting --> |gcBgMarkWorker|Grunning
Gwaiting --> |markroot|Grunning
Gwaiting --> |gcAssistAlloc1|Grunning
Gwaiting --> |newstack|Grunning
Gwaiting --> |findRunnableGCWorker|Grunnable
Gwaiting --> |ready|Grunnable
Gwaiting --> |findrunnable|Grunnable
Gwaiting --> |injectglist|Grunnable
Gwaiting --> |schedule|Grunnable
Gwaiting --> |park_m|Grunnable
Gwaiting --> |procresize|Grunnable
Gwaiting --> |checkdead|Grunnable</pre>

<p>图上的 Gany 代表任意状态，GC 时的状态切换比较多，如果只关注正常情况下的状态转换，可以把 markroot、gcMark 之类的先忽略掉。</p>
<h2 id="p-的状态迁移"><a href="#p-的状态迁移" class="headerlink" title="p 的状态迁移"></a>p 的状态迁移</h2><pre class="mermaid">graph LR

Pidle --> |acquirep1|Prunning

Psyscall --> |retake|Pidle
Psyscall --> |entersyscall_gcwait|Pgcstop
Psyscall --> |exitsyscallfast|Prunning

Pany --> |gcstopm|Pgcstop
Pany --> |forEachP|Pidle
Pany --> |releasep|Pidle
Pany --> |handoffp|Pgcstop
Pany --> |procresize release current p use allp 0|Pidle
Pany --> |procresize when init|Pgcstop
Pany --> |procresize when free old p| Pdead
Pany --> |procresize after resize use current p|Prunning
Pany --> |reentersyscall|Psyscall
Pany --> |stopTheWorldWithSema|Pgcstop</pre>

<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>函数执行是在 goroutine 的栈上，这个栈在函数执行期间是有可能溢出的，我们前面也看到了，如果一个函数用到了栈，会将 stackguard0 和 sp 寄存器进行比较，如果 sp &lt; stackguard0，说明栈已经增长到溢出，因为栈是从内存高地址向低地址方向增长的。</p>
<p>那么这个比较过程是在哪里完成的呢？这一步是由编译器完成的，我们看看一个函数编译后的结果，这段代码来自 go-internals:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span> TEXT    <span class="string">""</span>.main(SB), $<span class="number">24</span><span class="number">-0</span></span><br><span class="line">  ;; stack-split prologue</span><br><span class="line">  <span class="number">0x0000</span> MOVQ    (TLS), CX</span><br><span class="line">  <span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line">  <span class="number">0x000d</span> JLS    <span class="number">58</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x000f</span> SUBQ    $<span class="number">24</span>, SP</span><br><span class="line">  <span class="number">0x0013</span> MOVQ    BP, <span class="number">16</span>(SP)</span><br><span class="line">  <span class="number">0x0018</span> LEAQ    <span class="number">16</span>(SP), BP</span><br><span class="line">  ;; ...omitted FUNCDATA stuff...</span><br><span class="line">  <span class="number">0x001d</span> MOVQ    $<span class="number">137438953482</span>, AX</span><br><span class="line">  <span class="number">0x0027</span> MOVQ    AX, (SP)</span><br><span class="line">  ;; ...omitted PCDATA stuff...</span><br><span class="line">  <span class="number">0x002b</span> CALL    <span class="string">""</span>.add(SB)</span><br><span class="line">  <span class="number">0x0030</span> MOVQ    <span class="number">16</span>(SP), BP</span><br><span class="line">  <span class="number">0x0035</span> ADDQ    $<span class="number">24</span>, SP</span><br><span class="line">  <span class="number">0x0039</span> RET</span><br><span class="line"></span><br><span class="line">  ;; stack-split epilogue</span><br><span class="line">  <span class="number">0x003a</span> NOP</span><br><span class="line">  ;; ...omitted PCDATA stuff...</span><br><span class="line">  <span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">  <span class="number">0x003f</span> JMP    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>函数开头被插的这段指令，即是将 g struct 中的 stackguard 与 SP 寄存器进行对比，JLS 表示 SP &lt; 16(CX) 的话即跳转。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; stack-split prologue</span><br><span class="line"><span class="number">0x0000</span> MOVQ    (TLS), CX</span><br><span class="line"><span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line"><span class="number">0x000d</span> JLS    <span class="number">58</span></span><br></pre></td></tr></table></figure>

<p>这里因为 CX 寄存器存储的是 g 的起始地址，而 16(CX) 指的是 g 结构体偏移 16 个字节的位置，可以回顾一下 g 结构体定义，16 个字节恰好是跳过了第一个成员 stack(16字节) 之后的 stackguard0 的位置。</p>
<p>58 转为 16 进制即是 0x3a。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;; stack-split epilogue</span><br><span class="line"><span class="number">0x003a</span> NOP</span><br><span class="line">;; ...omitted PCDATA stuff...</span><br><span class="line"><span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span><br><span class="line"><span class="number">0x003f</span> JMP    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>morestack_noctxt:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// morestack but not preserving ctxt.</span></span><br><span class="line">TEXT runtime·morestack_noctxt(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">    MOVL    $<span class="number">0</span>, DX</span><br><span class="line">    JMP    runtime·morestack(SB)</span><br></pre></td></tr></table></figure>

<p>morestack:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    <span class="comment">// Cannot grow scheduler stack (m-&gt;g0).</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">    MOVQ    g_m(BX), BX</span><br><span class="line">    MOVQ    m_g0(BX), SI</span><br><span class="line">    CMPQ    g(CX), SI</span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    CALL    runtime·badmorestackg0(SB)</span><br><span class="line">    INT    $<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot grow signal stack (m-&gt;gsignal).</span></span><br><span class="line">    MOVQ    m_gsignal(BX), SI</span><br><span class="line">    CMPQ    g(CX), SI</span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    CALL    runtime·badmorestackgsignal(SB)</span><br><span class="line">    INT    $<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called from f.</span></span><br><span class="line">    <span class="comment">// Set m-&gt;morebuf to f's caller.</span></span><br><span class="line">    MOVQ    <span class="number">8</span>(SP), AX    <span class="comment">// f's caller's PC</span></span><br><span class="line">    MOVQ    AX, (m_morebuf+gobuf_pc)(BX)</span><br><span class="line">    LEAQ    <span class="number">16</span>(SP), AX    <span class="comment">// f's caller's SP</span></span><br><span class="line">    MOVQ    AX, (m_morebuf+gobuf_sp)(BX)</span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), SI</span><br><span class="line">    MOVQ    SI, (m_morebuf+gobuf_g)(BX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set g-&gt;sched to context in f.</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), AX <span class="comment">// f's PC</span></span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_pc)(SI)</span><br><span class="line">    MOVQ    SI, (g_sched+gobuf_g)(SI)</span><br><span class="line">    LEAQ    <span class="number">8</span>(SP), AX <span class="comment">// f's SP</span></span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_sp)(SI)</span><br><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(SI)</span><br><span class="line">    MOVQ    DX, (g_sched+gobuf_ctxt)(SI)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call newstack on m-&gt;g0's stack.</span></span><br><span class="line">    MOVQ    m_g0(BX), BX</span><br><span class="line">    MOVQ    BX, g(CX)</span><br><span class="line">    MOVQ    (g_sched+gobuf_sp)(BX), SP</span><br><span class="line">    CALL    runtime·newstack(SB)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, <span class="number">0x1003</span>    <span class="comment">// crash if newstack returns</span></span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>newstack:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from runtime·morestack when more stack is needed.</span></span><br><span class="line"><span class="comment">// Allocate larger stack and relocate to new stack.</span></span><br><span class="line"><span class="comment">// Stack growth is multiplicative, for constant amortized cost.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.</span></span><br><span class="line"><span class="comment">// If the GC is trying to stop this g then it will set preemptscan to true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must be nowritebarrierrec because it can be called as part of</span></span><br><span class="line"><span class="comment">// stack growth from other nowritebarrierrec functions, but the</span></span><br><span class="line"><span class="comment">// compiler doesn't check this.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thisg := getg()</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> double check all gp. shouldn't be getg().</span></span><br><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr().stackguard0 == stackFork &#123;</span><br><span class="line">        throw(<span class="string">"stack growth after fork"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr() != thisg.m.curg &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack called from g="</span>, hex(thisg.m.morebuf.g), <span class="string">"\n"</span>+<span class="string">"\tm="</span>, thisg.m, <span class="string">" m-&gt;curg="</span>, thisg.m.curg, <span class="string">" m-&gt;g0="</span>, thisg.m.g0, <span class="string">" m-&gt;gsignal="</span>, thisg.m.gsignal, <span class="string">"\n"</span>)</span><br><span class="line">        morebuf := thisg.m.morebuf</span><br><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr())</span><br><span class="line">        throw(<span class="string">"runtime: wrong goroutine in newstack"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := thisg.m.curg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> thisg.m.curg.throwsplit &#123;</span><br><span class="line">        <span class="comment">// Update syscallsp, syscallpc in case traceback uses them.</span></span><br><span class="line">        morebuf := thisg.m.morebuf</span><br><span class="line">        gp.syscallsp = morebuf.sp</span><br><span class="line">        gp.syscallpc = morebuf.pc</span><br><span class="line">        pcname, pcoff := <span class="string">"(unknown)"</span>, <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        f := findfunc(gp.sched.pc)</span><br><span class="line">        <span class="keyword">if</span> f.valid() &#123;</span><br><span class="line">            pcname = funcname(f)</span><br><span class="line">            pcoff = gp.sched.pc - f.entry</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack at "</span>, pcname, <span class="string">"+"</span>, hex(pcoff),</span><br><span class="line">            <span class="string">" sp="</span>, hex(gp.sched.sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span><br><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span><br><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        thisg.m.traceback = <span class="number">2</span> <span class="comment">// Include runtime frames</span></span><br><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp)</span><br><span class="line">        throw(<span class="string">"runtime: stack split at bad time"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    morebuf := thisg.m.morebuf</span><br><span class="line">    thisg.m.morebuf.pc = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.lr = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.sp = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.g = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> stackguard0 may change underfoot, if another thread</span></span><br><span class="line">    <span class="comment">// is about to try to preempt gp. Read it just once and use that same</span></span><br><span class="line">    <span class="comment">// value now and below.</span></span><br><span class="line">    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Be conservative about where we preempt.</span></span><br><span class="line">    <span class="comment">// We are interested in preempting user Go code, not runtime code.</span></span><br><span class="line">    <span class="comment">// If we're holding locks, mallocing, or preemption is disabled, don't</span></span><br><span class="line">    <span class="comment">// preempt.</span></span><br><span class="line">    <span class="comment">// This check is very early in newstack so that even the status change</span></span><br><span class="line">    <span class="comment">// from Grunning to Gwaiting and back doesn't happen in this case.</span></span><br><span class="line">    <span class="comment">// That status change by itself can be viewed as a small preemption,</span></span><br><span class="line">    <span class="comment">// because the GC might change Gwaiting to Gscanwaiting, and then</span></span><br><span class="line">    <span class="comment">// this goroutine has to wait for the GC to finish before continuing.</span></span><br><span class="line">    <span class="comment">// If the GC is in some way dependent on this goroutine (for example,</span></span><br><span class="line">    <span class="comment">// it needs a lock held by the goroutine), that small preemption turns</span></span><br><span class="line">    <span class="comment">// into a real deadlock.</span></span><br><span class="line">    <span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">""</span> || thisg.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">            <span class="comment">// Let the goroutine keep running for now.</span></span><br><span class="line">            <span class="comment">// gp-&gt;preempt is set, so it will be preempted next time.</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"missing stack in newstack"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sp := gp.sched.sp</span><br><span class="line">    <span class="keyword">if</span> sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 &#123;</span><br><span class="line">        <span class="comment">// The call to morestack cost a word.</span></span><br><span class="line">        sp -= sys.PtrSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> || sp &lt; gp.stack.lo &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack sp="</span>, hex(sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span><br><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span><br><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sp &lt; gp.stack.lo &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: gp="</span>, gp, <span class="string">", gp-&gt;status="</span>, hex(readgstatus(gp)), <span class="string">"\n "</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: split stack overflow: "</span>, hex(sp), <span class="string">" &lt; "</span>, hex(gp.stack.lo), <span class="string">"\n"</span>)</span><br><span class="line">        throw(<span class="string">"runtime: split stack overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="keyword">if</span> gp == thisg.m.g0 &#123;</span><br><span class="line">            throw(<span class="string">"runtime: preempt g0"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> thisg.m.p == <span class="number">0</span> &amp;&amp; thisg.m.locks == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"runtime: g is running but p is not"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Synchronize with scang.</span></span><br><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">        <span class="keyword">if</span> gp.preemptscan &#123;</span><br><span class="line">            <span class="keyword">for</span> !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) &#123;</span><br><span class="line">                <span class="comment">// Likely to be racing with the GC as</span></span><br><span class="line">                <span class="comment">// it sees a _Gwaiting and does the</span></span><br><span class="line">                <span class="comment">// stack scan. If so, gcworkdone will</span></span><br><span class="line">                <span class="comment">// be set and gcphasework will simply</span></span><br><span class="line">                <span class="comment">// return.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">                <span class="comment">// gcw is safe because we're on the</span></span><br><span class="line">                <span class="comment">// system stack.</span></span><br><span class="line">                gcw := &amp;gp.m.p.ptr().gcw</span><br><span class="line">                scanstack(gp, gcw)</span><br><span class="line">                <span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">                    gcw.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">                gp.gcscandone = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            gp.preemptscan = <span class="literal">false</span></span><br><span class="line">            gp.preempt = <span class="literal">false</span></span><br><span class="line">            casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)</span><br><span class="line">            <span class="comment">// This clears gcscanvalid.</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act like goroutine called runtime.Gosched.</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a bigger segment and move the stack.</span></span><br><span class="line">    oldsize := gp.stack.hi - gp.stack.lo</span><br><span class="line">    newsize := oldsize * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> newsize &gt; maxstacksize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: goroutine stack exceeds "</span>, maxstacksize, <span class="string">"-byte limit\n"</span>)</span><br><span class="line">        throw(<span class="string">"stack overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The goroutine must be executing in order to call newstack,</span></span><br><span class="line">    <span class="comment">// so it must be Grunning (or Gscanrunning).</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gcopystack)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The concurrent GC will not scan the stack while we are doing the copy since</span></span><br><span class="line">    <span class="comment">// the gp is in a Gcopystack status.</span></span><br><span class="line">    copystack(gp, newsize, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"stack grow done\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Gcopystack, _Grunning)</span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下流程:</p>
<pre class="mermaid">graph TD
start[entering func] --> cmp[sp < stackguard0]
cmp --> |yes| morestack_noctxt
cmp --> |no|final[execute func]
morestack_noctxt --> morestack
morestack --> newstack
newstack --> preempt</pre>

<p>抢占都是在 newstack 中完成，但抢占标记是在 Go 源代码中的其它位置来进行标记的:</p>
<p>我们来看看 stackPreempt 是在哪些位置赋值给 stackguard0 的:</p>
<pre class="mermaid">graph LR

unlock --> |in case cleared in newstack|restorePreempt
ready --> |in case cleared in newstack|restorePreempt
startTheWorldWithSema --> |in case cleared in newstack|restorePreempt
allocm --> |in case cleared in newstack|restorePreempt
exitsyscall --> |in case cleared in newstack|restorePreempt
newproc1--> |in case cleared in newstack|restorePreempt
releasem -->  |in case cleared in newstack|restorePreempt

scang --> setPreempt
reentersyscall --> setPreempt
entersyscallblock --> setPreempt
preemptone--> setPreempt

enlistWorker --> preemptone
retake --> preemptone
preemptall --> preemptone
freezetheworld --> preemptall
stopTheWorldWithSema --> preemptall
forEachP --> preemptall
startpanic_m --> freezetheworld
gcMarkDone --> forEachP</pre>

<p>可见只有 gc 和 retake 才会去真正地抢占 g，并没有其它的入口，其它的地方就只是恢复一下可能在 newstack 中被清除掉的抢占标记。</p>
<p>当然，这里 entersyscall 和 entersyscallblock 比较特殊，虽然这俩函数的实现中有设置抢占标记，但实际上这两段逻辑是不会被走到的。因为 syscall 执行时是在 m 的 g0 栈上，如果在执行时被抢占，那么会直接 throw，而无法恢复。</p>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#调度"><span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本数据结构"><span class="toc-text">基本数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g-p-m-的关系"><span class="toc-text">g/p/m 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p-如何初始化"><span class="toc-text">p 如何初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g-如何创建"><span class="toc-text">g 如何创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gostartcallfn"><span class="toc-text">gostartcallfn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runqput"><span class="toc-text">runqput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runqputslow"><span class="toc-text">runqputslow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#m-工作机制"><span class="toc-text">m 工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主线程-m0"><span class="toc-text">主线程 m0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysmon-线程"><span class="toc-text">sysmon 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#checkdead"><span class="toc-text">checkdead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retake"><span class="toc-text">retake</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通线程"><span class="toc-text">普通线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程创建"><span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作流程"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#schedule"><span class="toc-text">schedule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute"><span class="toc-text">execute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gogo"><span class="toc-text">gogo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Goexit"><span class="toc-text">Goexit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wakep"><span class="toc-text">wakep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine-挂起"><span class="toc-text">goroutine 挂起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findrunnable"><span class="toc-text">findrunnable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#m-和-p-解绑定"><span class="toc-text">m 和 p 解绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handoffp"><span class="toc-text">handoffp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g-的状态迁移"><span class="toc-text">g 的状态迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p-的状态迁移"><span class="toc-text">p 的状态迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抢占流程"><span class="toc-text">抢占流程</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">请我喝咖啡</div>
  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;max-width:500px;">
      <div style="float:left;margin-left:50px;">
        <div style="margin: auto; text-align: center; font-size: 0.8em; color: red;">支付宝</div>
        <image src="/resources/myqr/alipay.jpg"/>
      </div>
      <div style="float:left; margin-left: 50px;">
        <div style="margin: auto; text-align: center; font-size: 0.8em; color: red;">微信</div>
        <image src="/resources/myqr/wechatpay.jpg"/>
      </div>
      <div style="clear:left;"></div>
  </div>
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/blog/2019/06/23/20190623003354.html" rel="next" title="追踪goroutine调度器[翻译自：Scheduler Tracing In Go]">
          追踪goroutine调度器[翻译自：Scheduler Tracing In Go]
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/blog/2019/06/24/20190624000000.html" rel="prev" title="goroutine总结">
            goroutine总结
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://geedchin.com">首页</a> |
        <a class="bottom-item" href="https://geedchin.com" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/geedchin" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
    
<!--

<script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
<script src='/resources/lib/js/mermaid@7.1.2.min.js'></script>

-->
    
	  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
      
	  <script>
	    if (window.mermaid) {
	      mermaid.initialize({theme: 'forest'});
	    }
	  </script>
	
</footer>
  
  <!-- scripts list from theme config.yml -->
  
    <script src="//cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
  
    <script src="/js/xoxo.js"></script>
  


<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  <script type="text/javascript" src="/js/jquery-2.0.0.min.js"></script>
  <script type="text/javascript" src="/js/click_show_text.js"></script>
  <!--动态线条背景-->
  <script type="text/javascript"
  color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="/js/canvas-nest.min.js">
  </script>
</body>
</html>
