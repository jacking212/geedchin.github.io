<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go协程1.14——抢占调度</title>
    <url>/blog/2020/05/12/20200512224315.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>go协程在1.14之前便有抢占调度，但是在1.14之前，抢占调度有一定的条件(非硬性抢占，sysmon标记抢占，在某些过程中判断到被抢占则主动让出资源)。如下代码，在1.14之前不会停止，但在1.14中运行，则会停止。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，将分析一下 1.14之前的版本的“抢占调度”与1.14真正的抢占调度是如何实现的（本文基于linux版本进行分析）</p>
</blockquote>
<h1 id="lt-1-14的“抢占调度”"><a href="#lt-1-14的“抢占调度”" class="headerlink" title="&lt;1.14的“抢占调度”"></a>&lt;1.14的“抢占调度”</h1><blockquote>
<p>以1.12.5版本的go为例。</p>
<p>在go程序启动过程中，会启动一个M来运行sysmon()任务，sysmon的一个重要功能就是让长时间运行的g主动让出资源给其他g运行。核心方法是retake(now).preemptone(p):</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	mp := _p_.m.ptr()</span><br><span class="line">	<span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.preempt = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// Every call in a go routine checks for stack overflow by</span></span><br><span class="line">	<span class="comment">// comparing the current stack pointer to gp-&gt;stackguard0.</span></span><br><span class="line">	<span class="comment">// Setting gp-&gt;stackguard0 to StackPreempt folds</span></span><br><span class="line">	<span class="comment">// preemption into the normal stack overflow check.</span></span><br><span class="line">	gp.stackguard0 = stackPreempt</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，将待被抢占g的preempt字段标记为true，并将g.stackguard0 值改为 stackPreempt(uintptrMask &amp; -1314)，g.stackguard0字段含义：go栈增长前用来比较的栈指针。这里将stackguard0值改的很小，它的值比 g.stack.lo还要小(go中栈的分配是从高地址到低地址)，这样在扩增栈的时候就能够知道是sysmon准备抢占当前g，就会主动让出资源给其他程序运行：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ... ... </span></span><br><span class="line">	<span class="comment">// 此处判断 gp.stackguard0 是否与 stackPreempt相等来判断是否要被抢占</span></span><br><span class="line">	preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line">	<span class="keyword">if</span> preempt &#123;</span><br><span class="line">		<span class="comment">// ... ...</span></span><br><span class="line">		<span class="comment">// 此处会发起调度，即让出资源给其他g运行。  gopreempt_m() -&gt; goschedImpl() -&gt; schedule()</span></span><br><span class="line">		gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，抢占的关键点是，触发栈申请。所以只要是没有触发栈申请的代码，都不会主动让出资源给其他g使用，那么就会导致问题：例如，无法gc，gc过程中要stw。</p>
<p>因此，网上所述g调度的时机点是基于此(触发栈空间的申请，涉及于此便会判断栈空间大小同时也会判断g.stackguard0是否&gt;g.stack.lo，由此得到是否让出资源重新调度)。</p>
</blockquote>
<h1 id="1-14中抢占调度"><a href="#1-14中抢占调度" class="headerlink" title="1.14中抢占调度"></a>1.14中抢占调度</h1><blockquote>
<p>在1.14版本中，保留了原有的抢占方式，在此基础上增加了基于信号的异步抢占，看下1.14版本中的preemptone方法</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	mp := _p_.m.ptr()</span><br><span class="line">	<span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.preempt = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// Every call in a go routine checks for stack overflow by</span></span><br><span class="line">	<span class="comment">// comparing the current stack pointer to gp-&gt;stackguard0.</span></span><br><span class="line">	<span class="comment">// Setting gp-&gt;stackguard0 to StackPreempt folds</span></span><br><span class="line">	<span class="comment">// preemption into the normal stack overflow check.</span></span><br><span class="line">	gp.stackguard0 = stackPreempt</span><br><span class="line">	<span class="comment">// Request an async preemption of this P.</span></span><br><span class="line">	<span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">		_p_.preempt = <span class="literal">true</span></span><br><span class="line">		preemptM(mp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相较于之前版本的代码，最后多出了一段判断是否支持 preemptM与异步抢占开关处于off状态的逻辑，在条件通过后执行<code>preemptM()</code>方法</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptM</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !pushCallSupported &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> GOOS == <span class="string">"darwin"</span> &amp;&amp; (GOARCH == <span class="string">"arm"</span> || GOARCH == <span class="string">"arm64"</span>) &amp;&amp; !iscgo &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Cas(&amp;mp.signalPending, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">		signalM(mp, sigPreempt)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经过一些判断后，最终满足条件的情况下，会执行到 <code>signalM(mp, sigPreempt)</code>，该方法会将sigPreempt信号发送给mp(需要被抢占的协程所对应的内核线程)。由定义知，sigPreempt=_SIGURG ，所以是向待被抢占的协程发送 _SIGURG 信号。</p>
<p>接下来，看下待被抢占的协程所在的内核线程是如何处理信号的：</p>
<p>程序创建新的内核线程时会执行以下函数(runtime/signal_unix.go/initsig())，下边看下此函数定义：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 创建新内核线程执行链：</span></span><br><span class="line"><span class="comment">newm()        ---------&gt; newm1()  ----&gt; 是cgo                     mstart()  -&gt; mstart1() -&gt; mstart0 -&gt; initsig()</span></span><br><span class="line"><span class="comment">templateThread()  -----↗               ↘非cgo    newosproc()  --↗ </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initsig</span><span class="params">(preinit <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !preinit &#123;</span><br><span class="line">		<span class="comment">// It's now OK for signal handlers to run.</span></span><br><span class="line">		signalsOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// For c-archive/c-shared this is called by libpreinit with</span></span><br><span class="line">	<span class="comment">// preinit == true.</span></span><br><span class="line">	<span class="keyword">if</span> (isarchive || islibrary) &amp;&amp; !preinit &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; _NSIG; i++ &#123;</span><br><span class="line">		t := &amp;sigtable[i]</span><br><span class="line">		<span class="keyword">if</span> t.flags == <span class="number">0</span> || t.flags&amp;_SigDefault != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We don't need to use atomic operations here because</span></span><br><span class="line">		<span class="comment">// there shouldn't be any other goroutines running yet.</span></span><br><span class="line">		fwdSig[i] = getsig(i)</span><br><span class="line">		<span class="keyword">if</span> !sigInstallGoHandler(i) &#123;</span><br><span class="line">			<span class="comment">// Even if we are not installing a signal handler,</span></span><br><span class="line">			<span class="comment">// set SA_ONSTACK if necessary.</span></span><br><span class="line">			<span class="keyword">if</span> fwdSig[i] != _SIG_DFL &amp;&amp; fwdSig[i] != _SIG_IGN &#123;</span><br><span class="line">				setsigstack(i)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> fwdSig[i] == _SIG_IGN &#123;</span><br><span class="line">				sigInitIgnored(i)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		handlingSig[i] = <span class="number">1</span></span><br><span class="line">		setsig(i, funcPC(sighandler))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，这段代码核心在 <code>setsig(i,funcPC(sighandler))</code>，i代表的是信号，主要作用是当系统收到信号i时，执行sighandler方法。其中，_SIGURG 信号是包含在里边的。然后看下 sighandler方法：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sighandler</span><span class="params">(sig <span class="keyword">uint32</span>, info *siginfo, ctxt unsafe.Pointer, gp *g)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line">	<span class="keyword">if</span> sig == sigPreempt &#123;</span><br><span class="line">		<span class="comment">// Might be a preemption signal.</span></span><br><span class="line">		doSigPreempt(gp, c)</span><br><span class="line">		<span class="comment">// Even if this was definitely a preemption signal, it</span></span><br><span class="line">		<span class="comment">// may have been coalesced with another signal, so we</span></span><br><span class="line">		<span class="comment">// still let it through to the application.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心逻辑在这一段，if sig == sigPreempt，执行 doSigPreempt，sigPreempt上边介绍过，它的值为 _SIGURG，因此这里便是处理抢占逻辑的核心方法，继续挖掘 doSigPreempt:</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doSigPreempt handles a preemption signal on gp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) &#123;</span><br><span class="line">		<span class="comment">// Inject a call to asyncPreempt.</span></span><br><span class="line">		ctxt.pushCall(funcPC(asyncPreempt))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Acknowledge the preemption.</span></span><br><span class="line">	atomic.Xadd(&amp;gp.m.preemptGen, <span class="number">1</span>)</span><br><span class="line">	atomic.Store(&amp;gp.m.signalPending, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asyncPreempt saves all user registers and calls asyncPreempt2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When stack scanning encounters an asyncPreempt frame, it scans that</span></span><br><span class="line"><span class="comment">// frame and its parent frame conservatively.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// asyncPreempt is implemented in assembly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncPreempt</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncPreempt2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	gp.asyncSafePoint = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">		mcall(preemptPark)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mcall(gopreempt_m)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.asyncSafePoint = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>doSigPreempt判断g是否希望异步抢占和是否在safePoint，满足条件则执行pushCall。通过将asyncPreempt函数指针传递过去，在一定时机执行asyncPreempt。通过上边该函数的介绍可以知道，该函数保存用户寄存器信息，并且调用 asyncPreempt2函数；在asyncPreempt2函数中，则会执行到 mcall函数，它将m执行的g切换到g0，然后执行 preemptPark或gopreempt_m函数，无论哪种情况，最终都会调用到schedule()，致使重新调度。此时便完成了通过signal对更多场景中g的抢占。</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>go内存管理浅析</title>
    <url>/blog/2020/05/11/20200511224315.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>Go的内存分配器基于TCMalloc(Thread Local Malloc)，并在TCMalloc基础上增加了自动回收机制(TCMalloc只是增加内存申请速度，用户需手动释放空间)。</p>
</blockquote>
<h2 id="内存管理中的重要组件"><a href="#内存管理中的重要组件" class="headerlink" title="内存管理中的重要组件"></a>内存管理中的重要组件</h2><blockquote>
<p>在开始介绍之前，主要介绍以下Go内存分配中几个重要的组件:</p>
<ol>
<li>mheap，管理整个Go程序使用的堆空间，当程序内存不够需要申请更多内存时就是由mheap向os申请资源。操作单位是页，页大小是8KB</li>
<li>mcentral，管理协程需要使用的内存，mcentral具有不同的规格属性，每个mcentral都管理着自身规格的内存。管理单元是mspan，mspan的规格(每个指定规格的mspan其上只能存放指定规格大小的数据)详情见源码(go/src/runtime/sizeclasses.go)。</li>
<li>mcache，协程模型中<code>P</code>上的缓存内存。主要供协程使用，由于<code>P</code>上每次最多只可能有一个<code>G</code>在running，因此对<code>P</code>上的缓存操作无需加锁，增加了内存申请与释放的速度。缓存单位是mspan。</li>
</ol>
<p>三者协作： mcache是P私有且无锁的内存，当协程需要内存数据时，直接从mcache上找到指定规格的mspan，并将数据存入mspan。当mspan为空(初始为空)或已满时，向mcentral申请该规格的mspan，mcentral根据自身情况，有空闲则返回，无空间则从mheap中申请，mheap则根据自身是否由空间来决定返回自身空闲空间或者向OS申请资源。</p>
</blockquote>
<h2 id="内存管理中的重要对象"><a href="#内存管理中的重要对象" class="headerlink" title="内存管理中的重要对象"></a>内存管理中的重要对象</h2><blockquote>
<ol>
<li>mheap_，mheap的实例对象。</li>
<li>mheap_.mcentral[i] ，是具体mcentral的一个实例，mheap_.mcentral长度为134（67种规格×2是否带指针）。mheap_.mcentral[i]里负责存放全局的i规格内存和管理他们的申请与释放。</li>
<li>p.mcache[i]，<code>P</code>上缓存内存示例，其也是一个数组，长度也为134。当p.mcache[i]为空或满时，需要申请内存就向mheap_.mcentral[i]申请。</li>
<li>mspan，mcache、mcentral管理的内存单元。每次申请或者清理都是以mspan大小的单位，mspan具有规格属性，不同规格的mspan其大小及存放该规格数据的数量也都不尽相同。</li>
<li>mheap_.arenas[i][j]， 数据类型为heapArena，该对象主要属性：bitmap[],spans[],pageInUse,pageMarks,zeroedBase，网上很多讲go内存管理都会提到，go内存分为3部分，spans,bitmap,arena其中，arena指的就是mheap_.arenas中描述的所有内存大小，bitmap指的便是这里的属性bitmap[]，spans指的便是这里的spans[]，bitmap[]是字节数组，每个字节有8bit，可以用来表示4字节的内存使用情况以及gc标志，spans[]是指针数组，每个指针大小为8byte,指向一个mspan。关于说堆最大512G的说法是错误的，在linux 的go1.14中，arenas[i][j].bitmap[]大小是2MB，2MB一共是2 * 1024 * 1024 * 8 bit可以表示 8 * 1024 * 1024个地址位信息即 8M * 8byte = 64MB信息，arena数组大小是 1 * 4M,所以理论上，arenas堆空间最大内存为64MB * 4M = 256TB，bitmap占空间大小为 2MB * 4M = 8TB；spans占内存大小为 8K(数组长度) * 8B(数组指针元素8B) = 64KB(spans可表示内存:8K * 8KB(页大小)=64MB,64MB * 4M(arenas数组大小)=256TB 这与通过bitmap计算出的结果是一致的)</li>
</ol>
</blockquote>
<h2 id="架构简图"><a href="#架构简图" class="headerlink" title="架构简图"></a>架构简图</h2><blockquote>
<p><img src="/resources/post_pic/2020/05/mem01.jpg" alt="go内存管理" title="go内存管理"></p>
</blockquote>
<h1 id="堆对象空间分配"><a href="#堆对象空间分配" class="headerlink" title="堆对象空间分配"></a>堆对象空间分配</h1><blockquote>
<p>堆对象分配的主要逻辑在 <code>runtime/malloc.go</code>中的 <code>mallocgc()</code> 函数</p>
</blockquote>
<h2 id="微小-tiny-对象分配-0-16byte"><a href="#微小-tiny-对象分配-0-16byte" class="headerlink" title="微小(tiny)对象分配 (0,16byte]"></a>微小(tiny)对象分配 (0,16byte]</h2><blockquote>
<p>按照代码中的逻辑，当待分配空间的对象大小&lt;=16byte且没有指针引用时，使用微小对象分配的方法，将其放到mcache.alloc[5]的mspan中，这个mspan的规格是16byte。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tiny allocator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tiny allocator combines several tiny allocation requests</span></span><br><span class="line"><span class="comment">// into a single memory block. The resulting memory block</span></span><br><span class="line"><span class="comment">// is freed when all subobjects are unreachable. The subobjects</span></span><br><span class="line"><span class="comment">// must be noscan (don't have pointers), this ensures that</span></span><br><span class="line"><span class="comment">// the amount of potentially wasted memory is bounded.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span></span><br><span class="line"><span class="comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span></span><br><span class="line"><span class="comment">// wastage (when all but one subobjects are unreachable).</span></span><br><span class="line"><span class="comment">// 8 bytes would result in no wastage at all, but provides less</span></span><br><span class="line"><span class="comment">// opportunities for combining.</span></span><br><span class="line"><span class="comment">// 32 bytes provides more opportunities for combining,</span></span><br><span class="line"><span class="comment">// but can lead to 4x worst case wastage.</span></span><br><span class="line"><span class="comment">// The best case winning is 8x regardless of block size.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Objects obtained from tiny allocator must not be freed explicitly.</span></span><br><span class="line"><span class="comment">// So when an object will be freed explicitly, we ensure that</span></span><br><span class="line"><span class="comment">// its size &gt;= maxTinySize.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SetFinalizer has a special case for objects potentially coming</span></span><br><span class="line"><span class="comment">// from tiny allocator, it such case it allows to set finalizers</span></span><br><span class="line"><span class="comment">// for an inner byte of a memory block.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The main targets of tiny allocator are small strings and</span></span><br><span class="line"><span class="comment">// standalone escaping variables. On a json benchmark</span></span><br><span class="line"><span class="comment">// the allocator reduces number of allocations by ~12% and</span></span><br><span class="line"><span class="comment">// reduces heap size by ~20%.</span></span><br><span class="line">off := c.tinyoffset</span><br><span class="line"><span class="comment">// 将微对象对齐</span></span><br><span class="line"><span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">	off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">	off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">	off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// 如果能被当前的内存块放下，则放到当前内存块</span></span><br><span class="line">	x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">	c.tinyoffset = off + size</span><br><span class="line">	c.local_tinyallocs++</span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则，取出微对象指定规格的mspan，从mspan中获取下个能够存放微对象的内存块</span></span><br><span class="line">span := c.alloc[tinySpanClass]</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="comment">// 如果没找到，那么执行nextFree，从下层(mcentral)申请一个mspan，c.nextFree -&gt; c.refill -&gt; mheap_.central[spc].mcentral.cacheSpan </span></span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">	v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">// 后续就是处理新申请的资源，同时修改当前mcache中关于其的元数据信息</span></span><br><span class="line"><span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line"><span class="comment">// based on amount of remaining free space.</span></span><br><span class="line"><span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">	c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">	c.tinyoffset = size</span><br><span class="line">&#125;</span><br><span class="line">size = maxTinySize</span><br></pre></td></tr></table></figure>

<h2 id="小对象分配-16byte-32kb"><a href="#小对象分配-16byte-32kb" class="headerlink" title="小对象分配 (16byte,32kb)"></a>小对象分配 (16byte,32kb)</h2><blockquote>
<p>小对象内存分配，比微对象少了从 mcache.tiny上快速分配空间的逻辑，同微对象后边的分配空间逻辑大致相同</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定sizeclass</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">	sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">span := c.alloc[spc]</span><br><span class="line"><span class="comment">// 从当前mspan找空闲内存块，找不到，则执行nextFree向底层申请</span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">	v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line"><span class="comment">// 根据需求，是否清理分配出来的内存为0</span></span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大对象分配-32kb-∞"><a href="#大对象分配-32kb-∞" class="headerlink" title="大对象分配 (32kb,∞)"></a>大对象分配 (32kb,∞)</h2><blockquote>
<p>大对象内存分配直接从heap申请资源</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s = largeAlloc(size, needzero, noscan)</span><br><span class="line">&#125;)</span><br><span class="line">s.freeindex = <span class="number">1</span></span><br><span class="line">s.allocCount = <span class="number">1</span></span><br><span class="line">x = unsafe.Pointer(s.base())</span><br><span class="line">size = s.elemsize</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go内存管理</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>go-defer</title>
    <url>/blog/2020/05/01/20200501210040.html</url>
    <content><![CDATA[<h1 id="defer的go生三大问"><a href="#defer的go生三大问" class="headerlink" title="defer的go生三大问"></a>defer的go生三大问</h1><h2 id="what"><a href="#what" class="headerlink" title="what?"></a>what?</h2><blockquote>
<p>defer 是go语言中的一种用于在函数中执行完成后执行指定逻辑的机制。</p>
</blockquote>
<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><blockquote>
<p>在很多场景中，使用defer既可以增加代码的可读性，又可以防止开发人员开发过程中漏掉一些需要代码执行逻辑执行完才需要执行的逻辑，比如：</p>
<ol>
<li>锁的 unlock</li>
<li>数据流的 close()</li>
<li>事务的 commit or rollback</li>
</ol>
</blockquote>
<h2 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h2><blockquote>
<p>举一个最简单的示例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">df</span><span class="params">()</span><span class="params">(x <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">b := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	b++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	x = b</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	b+=<span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(df())</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出结果为： 2</p>
<p>分析原因：<br>defer关键字相当于把待执行函数放入一个先进后出的栈中，当执行完整个函数，开始执行defer中的函数。b+=2  -&gt; x=b  -&gt; b++ ；因此，输出结果为2</p>
</blockquote>
<h1 id="defer的发展"><a href="#defer的发展" class="headerlink" title="defer的发展"></a>defer的发展</h1><blockquote>
<p>最近发布的1.14 defer性能提升很多，相比于1.12提升近十倍效率，以下是为本地测试代码及结果：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withDefer_2</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>&#123;i--&#125;</span><br><span class="line"><span class="keyword">defer</span> d()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withDefer2_2</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> d()</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>&#123;i--&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withoutDefer_2</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>&#123;i--&#125;</span><br><span class="line">d()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withIfDefer_2</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span>&#123;i--;<span class="keyword">defer</span> d()&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWithoutDefer_2</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">num:=<span class="number">10</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">	withoutDefer_2(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWithIfDefer_2</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">num:=<span class="number">10</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">	withIfDefer_2(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWithDefer_2</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">num:=<span class="number">10</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">	withDefer_2(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWithDefer2_2</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">num:=<span class="number">100</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">	withDefer2_2(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">测试结果：</span></span><br><span class="line"><span class="comment">go v1.14.2:</span></span><br><span class="line"><span class="comment">BenchmarkWithoutDefer_2</span></span><br><span class="line"><span class="comment">BenchmarkWithoutDefer_2-4   	1000000000	         0.247 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithIfDefer_2</span></span><br><span class="line"><span class="comment">BenchmarkWithIfDefer_2-4    	347914345	         3.43 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer_2</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer_2-4      	445812684	         2.69 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer2_2</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer2_2-4     	473210992	         2.47 ns/op</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">go v1.13.4</span></span><br><span class="line"><span class="comment">BenchmarkWithoutDefer_2-4   	1000000000	         0.241 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithIfDefer_2-4    	44776783	        28.1 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer_2-4      	44352997	        27.5 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer2_2-4     	40123170	        27.0 ns/op</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">go v1.12.5</span></span><br><span class="line"><span class="comment">BenchmarkWithoutDefer_2-4   	2000000000	         0.50 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithIfDefer_2-4    	30000000	        37.2 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer_2-4      	50000000	        36.7 ns/op</span></span><br><span class="line"><span class="comment">BenchmarkWithDefer2_2-4     	50000000	        37.1 ns/op</span></span><br><span class="line"><span class="comment">**/</span> </span><br></pre></td></tr></table></figure>
<p>在无defer的场景中，每次操作执行时间约0.5 ns，在有defer场景中，1.14版本执行时间在2.5-3.5之间，1.12版本执行时间在37左右，相差十倍。1.13版本速度比1.12大概提升30%</p>
</blockquote>
<h2 id="不同版本中defer的实现"><a href="#不同版本中defer的实现" class="headerlink" title="不同版本中defer的实现"></a>不同版本中defer的实现</h2><blockquote>
<ol>
<li>在1.12版本中，defer的实现主要是通过 runtime.deferproc 函数，创建defer并存入g的defer栈中，在执行完函数后，会循环调用 runtime.deferreturn函数来执行defer函数</li>
<li>在1.13版本中，defer的实现是通过执行 runtime.deferprocstack 函数，从栈上创建defer函数，相比于原来在堆上创建，速度提升了很多。</li>
<li>在1.14版本中，defer的实现主要是编译阶段生成的<code>jmp</code>指令，通过指令跳转，减少函数调用时间，大幅度提升了defer的执行效率。(当函数中defer数量超过8个时，效率会骤减，但效率仍比1.12中高30%左右，超过8个使用1.13中的方法执行defer)。为什么是8个：有一个8位的deferBits，每增加一个defer,deferBits的一个bit被设置为1，编译过程分析到deferBits不够用的时候，会切换defer实现方式，当使用for循环defer时，会采用1.12版本的方法将defer入栈，for外的使用1.13版本方法入栈。具体可以写示例代码，编译汇编代码查看</li>
<li>panic场景，编译器会在可能发生panic的地方加入汇编，判断panic条件</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>defer</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go-defer</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础组件之runc</title>
    <url>/blog/2020/04/21/20200421223550.html</url>
    <content><![CDATA[<h1 id="OCI-标准"><a href="#OCI-标准" class="headerlink" title="OCI 标准"></a>OCI 标准</h1><blockquote>
<p>OCI(open container initiative)定义了容器运行时标准和容器镜像标准。docker的runC组件便是符合容器运行时标准的一个运行时实现。由于runC不涉及到镜像的管理，此处不对镜像标准做讨论。</p>
</blockquote>
<h2 id="容器运行时标准"><a href="#容器运行时标准" class="headerlink" title="容器运行时标准"></a>容器运行时标准</h2><blockquote>
<p> 运行时标准定义：<code>github.com/opencontainers/runtime-spec</code>。<br>配置的根定义类型是<code>Spec</code>，主要定义了运行时的版本、运行时根目录、HostName、Process(容器启动命令、参数、环境变量等)、Mounts、Hooks、annotations以及不同平台的运行参数等信息。</p>
</blockquote>
<h1 id="runC操作示例"><a href="#runC操作示例" class="headerlink" title="runC操作示例"></a>runC操作示例</h1><blockquote>
<p>本地先创建一个实验目录，我的目录是：<code>/app/tmp/myc</code>。在该目录下创建目录<code>rootfs</code>作为容器运行时的根目录。此时rootfs目录是空的，为了正常运行，使用docker命令导出一个完整的容器目录。执行<code>runc spec</code>命令，生成OCI 标准容器运行时配置文件<code>config.json</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /app/tmp/myc/rootfs &amp;&amp; cd /app/tmp/myc</span><br><span class="line">docker export &#123;&#123;容器ID&#125;&#125; | tar xvf - -C rootfs</span><br><span class="line">runc spec</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以修改<code>process.args</code>参数来修改容器启动命令,<code>root</code>参数可以指定容器根目录(默认根目录为rootfs)。</p>
<p>此处需修改 config.json参数<code>process.terminal</code>为false，否则会报错，terminal为true时需启动时配置额外参数：<br><code>[0000] cannot allocate tty if runc will detach without setting console socket 
cannot allocate tty if runc will detach without setting console socket</code></p>
<p>此时便可以启动容器了。<code>runc create -b /app/tmp/myc testrunc</code>，<br>可以通过<code>runc list</code>查看容器状态为<code>created</code>，可以使用命令<code>runc start testrunc</code>来真正启动容器(注意，要保证配置文件中 process.args命令可执行，且后台运行，否则执行完就退出)。</p>
</blockquote>
<h1 id="容器运行时状态"><a href="#容器运行时状态" class="headerlink" title="容器运行时状态"></a>容器运行时状态</h1><blockquote>
<p>容器运行时状态转换图：</p>
<pre class="mermaid">graph TB;
    creating -->|success| created
    created -->|start failed| stopped
    created -->|start success| running
    running -->|err/exit/crash/kill|stopped
    running -->|pause|paused
    paused -->|resume|running</pre>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
        <category>docker基础组件</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker基础组件</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之网络——VLAN</title>
    <url>/blog/2020/03/22/20190621005014.html</url>
    <content><![CDATA[<h1 id="VLAN基础"><a href="#VLAN基础" class="headerlink" title="VLAN基础"></a>VLAN基础</h1><blockquote>
<p>VLAN(virtual LAN)，即虚拟局域网。LAN一般指所属同一广播域的数台机器组成的网络，VLAN则特指使用路由器分割成不同广播域的网络。</p>
</blockquote>
<h2 id="为什么要使用VLAN"><a href="#为什么要使用VLAN" class="headerlink" title="为什么要使用VLAN"></a>为什么要使用VLAN</h2><h3 id="为什么要使用VLAN-1"><a href="#为什么要使用VLAN-1" class="headerlink" title="为什么要使用VLAN"></a>为什么要使用VLAN</h3><blockquote>
<p>试想有一个具有大量终端的局域网内，当某台机器A希望访问机器B时，计算机A会先发ARP广播请求来尝试获取机器B的MAC地址，此时该局域网内所有机器都会收到该广播请求。可以想象，当ARP请求比较多时引起广播风暴，将会对服务器CPU造成压力。</p>
<p>常见的广播通信有：</p>
<ol>
<li>ARP请求</li>
<li>RIP </li>
<li>DHCP</li>
<li>NetBEUI</li>
<li>IPX</li>
<li>Apple Talk</li>
</ol>
</blockquote>
<h3 id="实现VLAN的机制"><a href="#实现VLAN的机制" class="headerlink" title="实现VLAN的机制"></a>实现VLAN的机制</h3><blockquote>
<p>在一台未设置任何VLAN的二层交换机上，任何广播数据帧都会被转发给除接收端的所有端口。<br><img src="/resources/post_pic/2020/03/vlan_01.jpg" alt="lan" title="lan"><br>如上图，当第一台机器请求访问第二台机器时，其他所有机器也都会收到ARP请求。此时，如果将交换机的端口划分为多个VLAN，即可避免广播域过大的问题。<br><img src="/resources/post_pic/2020/03/vlan_02.jpg" alt="vlan" title="vlan"><br>如图，将绿色端口划分到一个VLAN下，蓝色端口划分到一个VLAN下，当同一VLAN内的机器相互访问时，ARP广播请求不会发送到其他VLAN中。</p>
</blockquote>
<h3 id="如何跨VLAN访问："><a href="#如何跨VLAN访问：" class="headerlink" title="如何跨VLAN访问："></a>如何跨VLAN访问：</h3><blockquote>
<p>VLAN是广播域，通常两个广播域是由路由器连接。因此，VLAN间的通信也需要路由器提供中继服务，这被称作“VLAN间路由”。VLAN间路由可以使用普通的路由器，也可以使用三层交换机。不同VLAN间通信需要用到路由功能。</p>
</blockquote>
<h3 id="VLAN划分方式"><a href="#VLAN划分方式" class="headerlink" title="VLAN划分方式"></a>VLAN划分方式</h3><table>
<thead>
<tr>
<th>划分方式</th>
<th>如何划分</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>静态划分</td>
<td>静态VLAN也叫基于端口的VLAN，交换机给每个端口指定VLAN</td>
<td>缺点：端口需要一个个指定，且修改网络拓扑机构时维护比较麻烦</td>
</tr>
<tr>
<td>基于MAC的划分</td>
<td>通过查询并记录端口所连计算机上网卡的MAC地址来决定VLAN</td>
<td>不受网络拓扑结构影响，但是当更换机器时依赖于MAC地址给其划分VLAN，当划分方式不当时，很容易造成各VLAN大小不均匀，达不到目的</td>
</tr>
<tr>
<td>基于子网的划分</td>
<td>通过所连计算机的IP地址来决定VLAN</td>
<td>不受网络拓扑结构影响，即使更换服务器，只要IP设定为原IP即可加入原VLAN</td>
</tr>
<tr>
<td>基于用户的划分</td>
<td>根据交换机所连计算机用户决定属于哪个VLAN</td>
<td>一般指计算机中登录的用户名，放到办公网络区域可行。但是在服务器环境不可行，大部分公司内部机器用户名都是统一的规定的，可能就几个用户名</td>
</tr>
</tbody></table>
<h2 id="VLAN的汇聚链接"><a href="#VLAN的汇聚链接" class="headerlink" title="VLAN的汇聚链接"></a>VLAN的汇聚链接</h2><h3 id="设置跨越多台交换机的VLAN"><a href="#设置跨越多台交换机的VLAN" class="headerlink" title="设置跨越多台交换机的VLAN"></a>设置跨越多台交换机的VLAN</h3><blockquote>
<p>前文讲到的VLAN都是在一个交换机下划分的，如何将不同交换机的多个接口划分到同一VLAN下呢？</p>
<p>一种很容易想到的方法就是：每个VLAN使用一个专用网口，将多个交换机串到一起。这么做存在一个问题，有多少VLAN就需要多少额外的网口来作为跨交换机通信的接口。</p>
<p>为了避免这种低效的通信方式，人们想到一种让交换机互联的线集中到一根上，这时使用的就是汇聚链接(Trunk Link)。</p>
</blockquote>
<h3 id="何谓汇聚链接"><a href="#何谓汇聚链接" class="headerlink" title="何谓汇聚链接"></a>何谓汇聚链接</h3><blockquote>
<p>汇聚链接(Trunk Link)指的是能够转发不同VLAN的通信的端口。汇聚流通的数据帧上都附加了识别分属于哪个VLAN的标示信息。</p>
<p>用户只需将交换机互联的端口设定为汇聚链接就可以使用了，无需其他额外的特殊布线。接下来看下汇聚链接是如何实现跨交换机的VLAN的：</p>
<ol>
<li>A发送的数据帧从交换机1经过汇聚链接到达交换机2时，在数据帧上附加了表示属于红色VLAN的标记</li>
<li>交换机2收到数据帧后，经过检查VLAN标示发现这个数据帧是属于红色VLAN的</li>
<li>除去标记后，根据需要将复原的数据帧只转发给其他属于红色VLAN的端口<br><img src="/resources/post_pic/2020/03/vlan_03_trunk.jpg" alt="trunk link" title="trunk link"></li>
</ol>
</blockquote>
<h2 id="VLAN间路由"><a href="#VLAN间路由" class="headerlink" title="VLAN间路由"></a>VLAN间路由</h2><h3 id="不同VLAN间通信"><a href="#不同VLAN间通信" class="headerlink" title="不同VLAN间通信"></a>不同VLAN间通信</h3><blockquote>
<p>对交换机划分不同VLAN之后，处于同一交换机下不同VLAN的设备是无法通信的，即使它们连在同一个交换机上。</p>
<p>为什么会无法通信呢：在LAN内的终端间通信，必须在数据帧头中指定mac地址，而为了获取mac地址，TCP/IP协议下使用的是ARP协议，通过广播ARP请求得到目的终端的mac地址。对交换机划分VLAN后，不同VLAN的设备不在一个广播域，因此无法直接通信。</p>
<p>为了让设备通信，只能通过更高一层的信息进行路由。路由可以使用路由器，也可使用三层交换机实现。</p>
</blockquote>
<h3 id="使用路由器进行VLAN间路由"><a href="#使用路由器进行VLAN间路由" class="headerlink" title="使用路由器进行VLAN间路由"></a>使用路由器进行VLAN间路由</h3><blockquote>
<p>由于一个交换机上的VLAN有多个，因此要考虑路由器如何识别的问题。同设置跨多台交换机的VLAN方法类似，使用到汇聚链接。</p>
<p>具体实现方法：首先将用于连接路由器的交换机端口设为汇聚链接，而路由器上的端口也必须支持汇聚链路。双方用于汇聚链路的协议自然也必须相同。接着在路由器上定义对应各个VLAN的“子接口（Sub Interface）”。尽管实际与交换机连接的物理端口只有一个，但在理论上我们可以把它分割为多个虚拟端口。VLAN将交换机从逻辑上分割成了多台，因而用于VLAN间路由的路由器，也必须拥有分别对应各个VLAN的虚拟接口。采用这种方法的话，即使之后在交换机上新建VLAN，仍只需要一条网线连接交换机和路由器。用户只需要在路由器上新设一个对应新VLAN的子接口就可以了。</p>
</blockquote>
<h3 id="通信的数据流程"><a href="#通信的数据流程" class="headerlink" title="通信的数据流程"></a>通信的数据流程</h3><p><img src="/resources/post_pic/2020/03/vlan_04.jpg" alt="communication" title="communication"></p>
<blockquote>
<p>如上图所示，为各终端、路由器子接口设定IP地址。红色VLAN(VLAN ID=1)的网络地址为192.168.1.0/24，蓝色VLAN(VLAN ID=2)的网络地址为192.168.2.0/24。终端的mac地址简记为A、B、C、D。交换机通过对各端口所连接的终端MAC地址学习，生成如下地址表：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>MAC地址</th>
<th>VLAN</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>D</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>R</td>
<td>汇聚链接</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="同一VLAN下的终端数据通信"><a href="#同一VLAN下的终端数据通信" class="headerlink" title="同一VLAN下的终端数据通信"></a>同一VLAN下的终端数据通信</h4><blockquote>
<p>收发信双方同属于一个VLAN内的通信，一切处理均在交换机内完成。<br><img src="/resources/post_pic/2020/03/vlan_05.jpg" alt="communication" title="communication"></p>
<ol>
<li>终端A发出ARP请求信息后，请求解析B的mac地址</li>
<li>交换机收到数据帧，检索MAC地址中与收信端口属于同一VLAN的表项。</li>
<li>发现终端B连接在端口2上，于是将数据帧转发到端口2，最终终端B收到数据帧。</li>
</ol>
</blockquote>
<h4 id="不同VLAN下的终端数据通信"><a href="#不同VLAN下的终端数据通信" class="headerlink" title="不同VLAN下的终端数据通信"></a>不同VLAN下的终端数据通信</h4><p><img src="/resources/post_pic/2020/03/vlan_05.jpg" alt="communication" title="communication"></p>
<blockquote>
<ol>
<li>计算机A从通信目标的IP地址（192.168.2.1）得出C与本机不属于同一个网段。因此会向设定的默认网关（Default Gateway，GW）转发数据帧。在发送数据帧之前，需要先用ARP获取路由器的MAC地址。</li>
<li>得到路由器的MAC地址R后，接下来就是按图中所示的步骤发送往C去的数据帧。①的数据帧中，目标MAC地址是路由器的地址R、但内含的目标IP地址仍是最终要通信的对象C的地址。</li>
<li>交换机在端口1上收到①的数据帧后，检索MAC地址列表中与端口1同属一个VLAN的表项。由于汇聚链路会被看作属于所有的VLAN，因此这时交换机的端口6也属于被参照对象。这样交换机就知道往MAC地址R发送数据帧，需要经过端口6转发。从端口6发送数据帧时，由于它是汇聚链接，因此会被附加上VLAN识别信息。由于原先是来自红色VLAN的数据帧，因此如图中②所示，会被加上红色VLAN的识别信息后进入汇聚链路。</li>
<li>路由器收到②的数据帧后，确认其VLAN识别信息，由于它是属于红色VLAN的数据帧，因此交由负责红色VLAN的子接口接收。接着，根据路由器内部的路由表，判断该向哪里中继。由于目标网络192.168.2.0/24是蓝色VLAN，且该网络通过子接口与路由器直连，因此只要从负责蓝色VLAN的子接口转发就可以了。这时，数据帧的目标MAC地址被改写成计算机C的目标地址；并且由于需要经过汇聚链路转发，因此被附加了属于蓝色VLAN的识别信息。这就是图中③的数据帧。</li>
<li>交换机收到③的数据帧后，根据VLAN标识信息从MAC地址列表中检索属于蓝色VLAN的表项。由于通信目标——计算机C连接在端口3上、且端口3为普通的访问链接，因此交换机会将数据帧除去VLAN识别信息后（数据帧④）转发给端口3，最终计算机C才能成功地收到这个数据帧。</li>
</ol>
<p>进行VLAN间通信时，即使通信双方都连接在同一台交换机上，也必须经过：“发送方——交换机——路由器——交换机——接收方”这样一个流程。</p>
</blockquote>
<h3 id="通信实验"><a href="#通信实验" class="headerlink" title="通信实验"></a>通信实验</h3><h4 id="实操1，windows下使用工具模拟网络"><a href="#实操1，windows下使用工具模拟网络" class="headerlink" title="实操1，windows下使用工具模拟网络"></a>实操1，windows下使用工具模拟网络</h4><h5 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h5><p><img src="/resources/post_pic/2020/03/vlan_07_nettop.jpg" alt="网络拓扑结构" title="网络拓扑结构"></p>
<blockquote>
<p>如上图，2个交换机，左边交换机连接终端PC0，PC1，它们在同一VLAN下，右边交换机连接终端PC3，PC4，其中PC3在tag100的VLAN下，PC4在tag200的VLAN下。两个交换机通过一对trunk口连接。左侧交换机trunk口连接到路由器上，并在路由器分了子接口，每个子接口配置了IP，另外子接口还需配置数据通过子接口时增加VLANID的操作。</p>
</blockquote>
<h5 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h5><blockquote>
<p>实验使用cisco packet tracer7.2模拟各种设备。<br><img src="/resources/post_pic/2020/03/vlan_08_cpt.jpg" alt="cisco packet tracer图示" title="cisco packet tracer图示"><br>如图，router使用的型号是1841，switch使用的型号是2960。</p>
<p>配置方法：</p>
<ol>
<li>增加各种设备，并将设备连接起来，PC按照网络拓扑图配置IP地址。PC网关地址分别是(192.168.1.2, 192.168.2.2)</li>
<li>双击打开switch，给switch增加vlan，两switch都配置，如图配置：<br><img src="/resources/post_pic/2020/03/vlan_09_cfgswitch.jpg" alt="添加vlan" title="添加vlan"></li>
<li>配置端口类型，如下图，fastEthernet0/x 指一个端口，然后右侧可以配置access模式和trunk模式，acces模式要选择vlan的id，trunk口默认选择所有vlan。根据网络拓扑结构，左侧交换机2个tag100的acces口，分别连接PC0 PC1，2个trunk口，分别连接到另一个交换机和路由器；右侧交换机1个tag100的access口连接PC3，一个tag200的access口连接PC4，1个trunk口连接到左侧交换机。<br><img src="/resources/post_pic/2020/03/vlan_10_cfgporttype.jpg" alt="配置switch端口类型" title="配置switch端口类型"></li>
<li>配置路由器。我这边测试时，是将左侧交换机连接到路由器的FastEthernet0/0接口。点击路由器，进入到cli选项卡，即可在命令行下操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在路由器上配置trunk的封装协议的命令: encapsulation [isl/dot1q] vlan</span><br><span class="line">Router&gt; en</span><br><span class="line">Router# conf ter</span><br><span class="line">Router(config)# interface fa0/0.1</span><br><span class="line">Router(config-subif)# encapsulation dot1Q 100</span><br><span class="line">Router(config-subif)# ip address 192.168.1.2 255.255.255.0</span><br><span class="line">Router(config-subif)# interface fa0/0.2</span><br><span class="line">Router(config-subif)# encapsulation dot1Q 200</span><br><span class="line">Router(config-subif)# ip address 192.168.2.2 255.255.255.0</span><br><span class="line">Router(config-subif)# exit</span><br><span class="line">Router(config)# interface fa0/0</span><br><span class="line">Router(config-if)# shutdown</span><br><span class="line">Router(config-if)# no shutdown </span><br><span class="line">Router(config-if)# exit</span><br><span class="line">Router(config)# exit</span><br><span class="line">Router# show interface fa0/0.1</span><br><span class="line">FastEthernet0/0.1 is up, line protocol is up (connected)</span><br><span class="line"> Hardware is PQUICC_FEC, address is 000a.f32d.9601 (bia 000a.f32d.9601)</span><br><span class="line"> Internet address is 192.168.1.2/24</span><br><span class="line"> MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec, </span><br><span class="line">    reliability 255/255, txload 1/255, rxload 1/255</span><br><span class="line"> Encapsulation 802.1Q Virtual LAN, Vlan ID 100</span><br><span class="line"> ARP type: ARPA, ARP Timeout 04:00:00, </span><br><span class="line"> Last clearing of &quot;show interface&quot; counters never</span><br><span class="line">Router#show interface fa0/0.2</span><br><span class="line">FastEthernet0/0.2 is up, line protocol is up (connected)</span><br><span class="line"> Hardware is PQUICC_FEC, address is 000a.f32d.9601 (bia 000a.f32d.9601)</span><br><span class="line"> Internet address is 192.168.2.2/24</span><br><span class="line"> MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec, </span><br><span class="line">    reliability 255/255, txload 1/255, rxload 1/255</span><br><span class="line"> Encapsulation 802.1Q Virtual LAN, Vlan ID 200</span><br><span class="line"> ARP type: ARPA, ARP Timeout 04:00:00, </span><br><span class="line"> Last clearing of &quot;show interface&quot; counters never </span><br></pre></td></tr></table></figure></li>
<li>通信测试，PC0 、PC1、PC3、PC4都可通，在设备上ping内部IP都可通。</li>
</ol>
</blockquote>
<h4 id="实操2，linux下利用网络空间模拟"><a href="#实操2，linux下利用网络空间模拟" class="headerlink" title="实操2，linux下利用网络空间模拟"></a>实操2，linux下利用网络空间模拟</h4><h5 id="网络拓扑-1"><a href="#网络拓扑-1" class="headerlink" title="网络拓扑"></a>网络拓扑</h5><p><img src="/resources/post_pic/2020/03/vlan_11_nettop.jpg" alt="网络拓扑结构" title="网络拓扑结构"></p>
<blockquote>
<p>如上图，一共使用2个交换机，左边连接网络空间 ns0,ns1,ns2，右侧连接网络空间ns10,ns12，其中ns0 ns1 ns10在vid为100的vlan内，ns2 ns12在vid为200的vlan内。两个ovs通过trunk口连接，ovs-br0通过两个access口连接到主机(这么做主要是还没研究出怎么使用路由器子接口一样把ovs的一端加到宿主机上，就使用多个access口代替单个trunk口的作用)</p>
<p>实验脚本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#创建2个ovs</span></span><br><span class="line">ovs-vsctl add-br ovs-br0;ip l s ovs-br0 up</span><br><span class="line">ovs-vsctl add-br ovs-br1;ip l s ovs-br1 up</span><br><span class="line"><span class="comment"># 创建ns，并创建veth pair将一端加入到ns，同时添加默认路由规则</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 2`;<span class="keyword">do</span> \</span><br><span class="line">ip netns add ns<span class="variable">$i</span></span><br><span class="line">ip l a veth<span class="variable">$i</span> <span class="built_in">type</span> veth peer name nveth<span class="variable">$i</span>; \</span><br><span class="line">ip l s nveth<span class="variable">$i</span> name eth0 netns ns<span class="variable">$i</span>; \</span><br><span class="line">ip l s veth<span class="variable">$i</span> up; \</span><br><span class="line">ip netns <span class="built_in">exec</span> ns<span class="variable">$i</span> ip l s eth0 up; \</span><br><span class="line">ip netns <span class="built_in">exec</span> ns<span class="variable">$i</span> ip l s lo up; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 10 11`;<span class="keyword">do</span> \</span><br><span class="line">ip netns add ns<span class="variable">$i</span></span><br><span class="line">ip l a veth<span class="variable">$i</span> <span class="built_in">type</span> veth peer name nveth<span class="variable">$i</span>; \</span><br><span class="line">ip l s nveth<span class="variable">$i</span> name eth0 netns ns<span class="variable">$i</span>; \</span><br><span class="line">ip l s veth<span class="variable">$i</span> up; \</span><br><span class="line">ip netns <span class="built_in">exec</span> ns<span class="variable">$i</span> ip l s eth0 up; \</span><br><span class="line">ip netns <span class="built_in">exec</span> ns<span class="variable">$i</span> ip l s lo up; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 配置IP</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns0  ip a a 10.2.1.10/24 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1  ip a a 10.2.1.11/24 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2  ip a a 10.2.2.10/24 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns10 ip a a 10.2.1.12/24 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns11 ip a a 10.2.2.11/24 dev eth0</span><br><span class="line"><span class="comment"># 将5个ns分别连到两个交换机上的指定vlan口</span></span><br><span class="line"><span class="comment"># ovs-br0</span></span><br><span class="line">ovs-vsctl add-port ovs-br0 veth0 tag=100</span><br><span class="line">ovs-vsctl add-port ovs-br0 veth1 tag=100</span><br><span class="line">ovs-vsctl add-port ovs-br0 veth2 tag=200</span><br><span class="line"><span class="comment"># ovs-br1</span></span><br><span class="line">ovs-vsctl add-port ovs-br1 veth10 tag=100</span><br><span class="line">ovs-vsctl add-port ovs-br1 veth11 tag=200</span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## connect ovs-br0 and ovs-br1</span></span><br><span class="line">ip l a tveth0 <span class="built_in">type</span> veth peer name tveth1;</span><br><span class="line">ip l s tveth0 up;ip l s tveth1 up</span><br><span class="line">ovs-vsctl add-port ovs-br0 tveth0</span><br><span class="line">ovs-vsctl add-port ovs-br1 tveth1</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> port tveth0 vlan_mode=trunk</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> port tveth1 vlan_mode=trunk</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> port tveth0 trunks=100,200</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> port tveth1 trunks=100,200</span><br><span class="line"><span class="comment"># 创建两个veth pair将ovs的两个tag以access方式连接到宿主机</span></span><br><span class="line">ip l a rveth0 <span class="built_in">type</span> veth peer name rtveth0</span><br><span class="line">ip l a rveth1 <span class="built_in">type</span> veth peer name rtveth1</span><br><span class="line">ip l s rveth0 up;ip l s rtveth0 up</span><br><span class="line">ip l s rveth1 up;ip l s rtveth1 up</span><br><span class="line"><span class="comment"># 给两个网卡增加IP，作为VLAN的网关</span></span><br><span class="line">ip a a 10.2.1.2/24 dev rveth0</span><br><span class="line">ip a a 10.2.2.2/24 dev rveth1</span><br><span class="line">ovs-vsctl add-port ovs-br0 rtveth0 tag=100</span><br><span class="line">ovs-vsctl add-port ovs-br0 rtveth1 tag=200</span><br><span class="line"><span class="comment"># 给ns增加路由</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns0 route add default gw 10.2.1.2 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 route add default gw 10.2.1.2 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 route add default gw 10.2.2.2 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns10 route add default gw 10.2.1.2 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns11 route add default gw 10.2.2.2 dev eth0 </span><br></pre></td></tr></table></figure>

<p>做完实验清理脚本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ovs-vsctl del-br ovs-br0</span><br><span class="line">ovs-vsctl del-br ovs-br1</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 2`;<span class="keyword">do</span> \</span><br><span class="line">ip netns del ns<span class="variable">$i</span>; \</span><br><span class="line">ip l d veth<span class="variable">$i</span>; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 10 11`;<span class="keyword">do</span> \</span><br><span class="line">ip netns del ns<span class="variable">$i</span>; \</span><br><span class="line">ip l d veth<span class="variable">$i</span>; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">ip l d rveth0</span><br><span class="line">ip l d rveth1</span><br><span class="line">ip l d tveth0 </span><br></pre></td></tr></table></figure>
<p>经过测试，ns0,ns1,ns2,ns10,ns11之间全部互通。</p>
<p>在各个ns中，无法ping通外网，主要是两个VLAN是在挂在宿主机下的子网，如果想访问外网，要在宿主机上增加NAT规则。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.51cto.com/6930123/2115373" target="_blank" rel="noopener">VLAN基础部分参考</a></li>
<li><a href="https://blog.csdn.net/qq_41745698/article/details/83240348" target="_blank" rel="noopener">VLAN利用cisco packet tracer模拟网络操作参考</a></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker网络</tag>
        <tag>VLAN</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码阅读03——controller-manager 之 deploymentController</title>
    <url>/blog/2019/12/11/20191211215410.html</url>
    <content><![CDATA[<h1 id="控制器模型"><a href="#控制器模型" class="headerlink" title="控制器模型"></a>控制器模型</h1><p>在K8S中，控制器的代码都遵循了一个通用的编排模式：控制循环。例如，在一个待编排的对象R，它有一个对应的控制器，那么，可以用以下伪代码来描述这个控制循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">	实际状态 := 获取集群中对象R当前状态，从K8S中获取</span><br><span class="line">	期望状态 := 通过watcher监听到API对对象发起的修改(可能来源于用户也可能来源于组件内部) OR 当前其他对象控制循环将R放入该循环的队列</span><br><span class="line">	<span class="keyword">if</span> 实际状态 == 期望状态&#123;</span><br><span class="line">		contaniue</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		执行操作，调整对象R到期望状态</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，deployment控制replicaSet资源对象，然后replicaSet资源对象再来控制pod对象，从而实现了deployment对Pod对象的管理。在deploymentController的源码中也有对replicaSet和pod的控制循环，因为这个过程中涉及到对这两个对象的修改或者依赖于这两个对象修改时要某些处理。</p>
<p><img src="/resources/post_pic/2019/12/deployment-controller.png" alt="deployment控制器模型" title="deployment控制器模型"></p>
<p>如上图，deployment直接控制对象是replicaSet，replicaSet来控制Pod。另外，在deploymentController中，有deploymentInformor、replicaSetInformor、podInformor三个用于监听这三种对象的变化情况，然后再将变化事件推给deploymentController控制循环，从而完成整个控制逻辑。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>基于K8S 1.16.2源码</p>
<h2 id="控制启动入口"><a href="#控制启动入口" class="headerlink" title="控制启动入口"></a>控制启动入口</h2><p>Controller-manager整个监控逻辑启动入口是 kubernetes/cmd/kube-controller-manager/controller-manager.go中。<br>deploymentController控制循环启动：</p>
<ol>
<li>执行main函数，<code>cmd.Execute()</code>内部最终会调用到 <code>cmd.Run</code>方法(cmd/kube-controller-manager/app/controllermanager.go 108行)</li>
<li>该方法中，最后再执行<code>Run</code>方法，进入到 159行</li>
<li>该方法中246行执行<code>run</code>方法，<code>run</code>方法在上边定义</li>
<li>在<code>run</code>方法中，234行调用 <code>NewControllerInitializers()</code> 方法 373行</li>
<li>在 <code>NewControllerInitializers</code> 方法中，注册了一系列<code>controller</code>的入口函数，关注 385行，<code>controllers[&quot;deployment&quot;] = startDeploymentController</code></li>
<li>跳转到 <code>startDeploymentController</code> 定义(cmd/kube-controller-manager/app/apps.go 86行)，找到<code>NewDeploymentController</code>，通过此方法即可找到<code>deploymentController</code>的核心源码</li>
</ol>
<p>deploymentController中主要有3个Informor控制循环来共同协作来实现功能，接下来从上到下挨个分析这三个控制循环的源码</p>
<h2 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h2><h3 id="deployment如何到达控制循环中"><a href="#deployment如何到达控制循环中" class="headerlink" title="deployment如何到达控制循环中"></a>deployment如何到达控制循环中</h3><blockquote>
<p>在创建<code>deploymentController</code>变量的时候，函数里定义了deployment变化事件Handler，在handler中，最终都会把deployment对象放入 dc.queue队列中，然后在 dc.processNextWorkItem()方法中对其消费，在该函数中调用了dc.syncHandler方法，该方法是在创建 <code>deploymentController</code>对象的时候赋值的，执行体为 <code>dc.syncDeployment</code>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/deployment_controller.go 459行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> dc.processNextWorkItem() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := dc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	err := dc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line">	dc.handleErr(err, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即：只要将deployment对象放到dc.queue队列中，dc.processNextWorkItem方法便会从队列中取出数据，然后进入控制循环，接下来先讲一下，deployment对象入队的场景。</p>
</blockquote>
<h4 id="deploymentInformer"><a href="#deploymentInformer" class="headerlink" title="deploymentInformer"></a>deploymentInformer</h4><blockquote>
<p>deploymentInformer 里，监控到deployment发生变化，直接进入控制循环，这点没有什么问题，因为deploymentController本身就是要来管理deployment的。以下代码为deploymentInformer变化事件handler的初始化。其中<code>dc.addDeployment</code> 、<code>dc.updateDeployment</code>、<code>dc.deleteDeployment</code> 函数里的逻辑都比较简单，基本就是一些错误处理，最后把deployment 入队</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer appsinformers.DeploymentInformer, rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pkg/controller/deployment/deployment_controller.go 120行</span></span><br><span class="line">	dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    dc.addDeployment,</span><br><span class="line">		UpdateFunc: dc.updateDeployment,</span><br><span class="line">		<span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">		DeleteFunc: dc.deleteDeployment,</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pkg/controller/deployment/deployment_controller.go 135行</span></span><br><span class="line">	dc.syncHandler = dc.syncDeployment</span><br><span class="line">	dc.enqueueDeployment = dc.enqueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="replicasetInformer"><a href="#replicasetInformer" class="headerlink" title="replicasetInformer"></a>replicasetInformer</h4><blockquote>
<p>从上边控制器模型的图中可以看到，replicasetInformer有3种事件都反馈到deploymentController中，实际在replicasetInformer中，replicaSet的3种变化都会将其对应的deployment对象入队，使其进入控制循环。首先看下，informer中定义的事件handler：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer appsinformers.DeploymentInformer, rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ... /pkg/controller/deployment/deployment_controller.go 126行</span></span><br><span class="line">rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc:    dc.addReplicaSet,</span><br><span class="line">	UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">	DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>分别看下三种事件中的处理逻辑</p>
</blockquote>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addReplicaSet</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rs := obj.(*apps.ReplicaSet)</span><br><span class="line"><span class="comment">// ① 首先判断是否是已删除的rs，如果是，则调用 dc.deleteReplicaSet函数</span></span><br><span class="line"><span class="comment">//    dc.deleteReplicaSet：如果找不到对应的管理这个rs 的deployment对象，则直接返回，否则将deployment入队，让其进入控制循环</span></span><br><span class="line"><span class="keyword">if</span> rs.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// On a restart of the controller manager, it's possible for an object to</span></span><br><span class="line">	<span class="comment">// show up in a state that is already pending deletion.</span></span><br><span class="line">	dc.deleteReplicaSet(rs)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 如果rs有对应的deployment，则将其入队并退出，否则继续</span></span><br><span class="line"><span class="comment">// If it has a ControllerRef, that's all that matters.</span></span><br><span class="line"><span class="keyword">if</span> controllerRef := metav1.GetControllerOf(rs); controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">	d := dc.resolveControllerRef(rs.Namespace, controllerRef)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"ReplicaSet %s added."</span>, rs.Name)</span><br><span class="line">	dc.enqueueDeployment(d)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ③ 孤儿rs，根据rs的label找到与其相同的deployment，如果没有则直接退出，否则继续</span></span><br><span class="line"><span class="comment">// Otherwise, it's an orphan. Get a list of all matching Deployments and sync</span></span><br><span class="line"><span class="comment">// them to see if anyone wants to adopt it.</span></span><br><span class="line">ds := dc.getDeploymentsForReplicaSet(rs)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ds) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ④ 将上一步找到的所有deployment都入队，交由deployment控制循环处理</span></span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"Orphan ReplicaSet %s added."</span>, rs.Name)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> ds &#123;</span><br><span class="line">	dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">updateReplicaSet</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">curRS := cur.(*apps.ReplicaSet)</span><br><span class="line">oldRS := old.(*apps.ReplicaSet)</span><br><span class="line"><span class="keyword">if</span> curRS.ResourceVersion == oldRS.ResourceVersion &#123;</span><br><span class="line">	<span class="comment">// Periodic resync will send update events for all known replica sets.</span></span><br><span class="line">	<span class="comment">// Two different versions of the same replica set will always have different RVs.</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ① 更新前后，replicaset的控制者如果发生变化，而且更新前的控制在不为空，且找到旧的控制者，则将旧rs的控制者入队</span></span><br><span class="line"><span class="comment">//    这么做，是为了让旧rs的控制者知道rs脱离了控制，deployment会根据情况去判断是否再创建新的rs</span></span><br><span class="line">curControllerRef := metav1.GetControllerOf(curRS)</span><br><span class="line">oldControllerRef := metav1.GetControllerOf(oldRS)</span><br><span class="line">controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)</span><br><span class="line"><span class="keyword">if</span> controllerRefChanged &amp;&amp; oldControllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// The ControllerRef was changed. Sync the old controller, if any.</span></span><br><span class="line">	<span class="keyword">if</span> d := dc.resolveControllerRef(oldRS.Namespace, oldControllerRef); d != <span class="literal">nil</span> &#123;</span><br><span class="line">		dc.enqueueDeployment(d)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 如果新rs的控制者不为空，则去找其控制者，找不到，则直接退出，找到则将其控制者入队</span></span><br><span class="line"><span class="comment">// If it has a ControllerRef, that's all that matters.</span></span><br><span class="line"><span class="keyword">if</span> curControllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">	d := dc.resolveControllerRef(curRS.Namespace, curControllerRef)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"ReplicaSet %s updated."</span>, curRS.Name)</span><br><span class="line">	dc.enqueueDeployment(d)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ③ 否则，它是一个孤儿rs，同步能够与其匹配的deployment，看是否哪一个现在想管理它</span></span><br><span class="line"><span class="comment">// Otherwise, it's an orphan. If anything changed, sync matching controllers</span></span><br><span class="line"><span class="comment">// to see if anyone wants to adopt it now.</span></span><br><span class="line">labelChanged := !reflect.DeepEqual(curRS.Labels, oldRS.Labels)</span><br><span class="line"><span class="keyword">if</span> labelChanged || controllerRefChanged &#123;</span><br><span class="line">	ds := dc.getDeploymentsForReplicaSet(curRS)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ds) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Orphan ReplicaSet %s updated."</span>, curRS.Name)</span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> ds &#123;</span><br><span class="line">		dc.enqueueDeployment(d)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">deleteReplicaSet</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rs, ok := obj.(*apps.ReplicaSet)</span><br><span class="line"><span class="comment">// ① obj 对象可能是apps.ReplicaSet 或 cache.DeletedFinalStateUnknown,这里先进行不是apps.ReplicaSet时的处理。</span></span><br><span class="line"><span class="comment">//    如果不是，则从 cache.DeletedFinalStateUnknown中取出rs对象，失败则返回，并报错，成功则继续</span></span><br><span class="line"><span class="comment">// When a delete is dropped, the relist will notice a pod in the store not</span></span><br><span class="line"><span class="comment">// in the list, leading to the insertion of a tombstone object which contains</span></span><br><span class="line"><span class="comment">// the deleted key/value. Note that this value might be stale. If the ReplicaSet</span></span><br><span class="line"><span class="comment">// changed labels the new deployment will not be woken up till the periodic resync.</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get object from tombstone %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rs, ok = tombstone.Obj.(*apps.ReplicaSet)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Tombstone contained object that is not a ReplicaSet %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 获取rs的控制者，如果等于nil，则直接返回</span></span><br><span class="line"><span class="comment">//    可能原因：手动创建的rs，而不是通过deployment创建的rs</span></span><br><span class="line">controllerRef := metav1.GetControllerOf(rs)</span><br><span class="line"><span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// No controller should care about orphans being deleted.</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ③ 根据rsRef找到对应的控制者对象，如果为空，则直接退出，如果不为空，则将其入队</span></span><br><span class="line"><span class="comment">//     为空的原因：deployment删除时PropagationPolicy参数设置成background时，rs本身是记录了控制者信息，但是deployment被提前删除了。所以根据Ref信息获取不到存在的deployment</span></span><br><span class="line">d := dc.resolveControllerRef(rs.Namespace, controllerRef)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"ReplicaSet %s deleted."</span>, rs.Name)</span><br><span class="line">dc.enqueueDeployment(d)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="PodInformer"><a href="#PodInformer" class="headerlink" title="PodInformer"></a>PodInformer</h4><blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer appsinformers.DeploymentInformer, rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="comment">// pkg/controller/deployment/deployment_controller.go 131行</span></span><br><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	DeleteFunc: dc.deletePod,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>PodInformer中只有delete事件会通知到deployment，下边看下 dc.deletePod具体的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">deletePod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">pod, ok := obj.(*v1.Pod)</span><br><span class="line"><span class="comment">// ① 同rs删除事件函数中的开始处理，obj对象可能是v1.Pod或DeletedFinalStateUnknown，如果是后者，则取出v1.Pod并继续</span></span><br><span class="line"><span class="comment">// When a delete is dropped, the relist will notice a pod in the store not</span></span><br><span class="line"><span class="comment">// in the list, leading to the insertion of a tombstone object which contains</span></span><br><span class="line"><span class="comment">// the deleted key/value. Note that this value might be stale. If the Pod</span></span><br><span class="line"><span class="comment">// changed labels the new deployment will not be woken up till the periodic resync.</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get object from tombstone %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pod, ok = tombstone.Obj.(*v1.Pod)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Tombstone contained object that is not a pod %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"Pod %s deleted."</span>, pod.Name)</span><br><span class="line"><span class="comment">// ② 根据pod找到对应的deployment，如果找到，而且 deployment的更新策略为Recreate，则进入if处理逻辑，否则结束</span></span><br><span class="line"><span class="comment">//    此处判断deployment更新策略是因为，只有当更新测量是Recreate时，deployment才会受pod的删除影响。</span></span><br><span class="line"><span class="keyword">if</span> d := dc.getDeploymentForPod(pod); d != <span class="literal">nil</span> &amp;&amp; d.Spec.Strategy.Type == apps.RecreateDeploymentStrategyType &#123;</span><br><span class="line">	<span class="comment">// Sync if this Deployment now has no more Pods.</span></span><br><span class="line">	<span class="comment">// 根据 deployment获取其控制的rs，和每个rs对应的pod(podMap存储)</span></span><br><span class="line">	rsList, err := util.ListReplicaSets(d, util.RsListFromClient(dc.client.AppsV1()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	podMap, err := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	numPods := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 累加所有rs的pod数，如果等于0，则将deployment入队</span></span><br><span class="line">	<span class="comment">// Recreate更新策略：将所有pod都删除才创建新的Rs</span></span><br><span class="line">	<span class="keyword">for</span> _, podList := <span class="keyword">range</span> podMap &#123;</span><br><span class="line">		numPods += <span class="built_in">len</span>(podList)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> numPods == <span class="number">0</span> &#123;</span><br><span class="line">		dc.enqueueDeployment(d)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="控制循环-1"><a href="#控制循环-1" class="headerlink" title="控制循环"></a>控制循环</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/deployment_controller.go 562行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncDeployment</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	deployment, err := dc.dLister.Deployments(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deep-copy otherwise we are mutating our cache.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Deep-copy only when needed.</span></span><br><span class="line">	d := deployment.DeepCopy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ①</span></span><br><span class="line">	everything := metav1.LabelSelector&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(d.Spec.Selector, &amp;everything) &#123;</span><br><span class="line">		dc.eventRecorder.Eventf(d, v1.EventTypeWarning, <span class="string">"SelectingAll"</span>, <span class="string">"This deployment is selecting all pods. A non-empty selector is required."</span>)</span><br><span class="line">		<span class="keyword">if</span> d.Status.ObservedGeneration &lt; d.Generation &#123;</span><br><span class="line">			d.Status.ObservedGeneration = d.Generation</span><br><span class="line">			dc.client.AppsV1().Deployments(d.Namespace).UpdateStatus(d)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	rsList, err := dc.getReplicaSetsForDeployment(d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podMap, err := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ②</span></span><br><span class="line">	<span class="keyword">if</span> d.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.syncStatusOnly(d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③</span></span><br><span class="line">	<span class="keyword">if</span> err = dc.checkPausedConditions(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d.Spec.Paused &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ④</span></span><br><span class="line">	<span class="keyword">if</span> getRollbackTo(d) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.rollback(d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑤</span></span><br><span class="line">	scalingEvent, err := dc.isScalingEvent(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scalingEvent &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑥</span></span><br><span class="line">	<span class="keyword">switch</span> d.Spec.Strategy.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> apps.RecreateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRecreate(d, rsList, podMap)</span><br><span class="line">	<span class="keyword">case</span> apps.RollingUpdateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRolling(d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected deployment strategy type: %s"</span>, d.Spec.Strategy.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在源码中标记了 1-6个编号，重点关注这几处逻辑</p>
</blockquote>
<h4 id="①判断deployment选择器是否为空"><a href="#①判断deployment选择器是否为空" class="headerlink" title="①判断deployment选择器是否为空"></a>①判断<code>deployment</code>选择器是否为空</h4><blockquote>
<p><code>deployment</code>选择器如果为空，则其默认为选中所有，这在k8s中是不被允许的，所以做了短路处理，如果选择器为空，则直接return，不进行接下来的处理。</p>
</blockquote>
<h4 id="②判断删除标记"><a href="#②判断删除标记" class="headerlink" title="②判断删除标记"></a>②判断删除标记</h4><blockquote>
<p>判断删除时间戳是否为空，如果不为空，说明该deployment已被删除，则不做处理，只更新状态调用到<code>dc.syncStatusOnly</code>，重新计算deployment.status值，然后调用api执行更新操作。</p>
</blockquote>
<h4 id="③判断是否暂停"><a href="#③判断是否暂停" class="headerlink" title="③判断是否暂停"></a>③判断是否暂停</h4><blockquote>
<p>暂停操作相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂停</span></span><br><span class="line">kubectl rollout pause -n NAMESPACE deploy DEPLOYNAME</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复</span></span><br><span class="line">kubectl rollout resume -n NAMESPACE deploy DEPLOYNAME </span><br></pre></td></tr></table></figure>
<p>在暂停操作时，deploymentController是不对rs进行操作的，只有当恢复暂停时，才会进行操作。主要应用场景，多次修改deployment时，希望多次修改操作能够一次性提交更新，而不是每次保存配置时都更新。</p>
<p>回到源码，该部分逻辑很简单，如果判断结果是deployment处于暂停状态，那么调用到 <code>dc.sync</code>方法，该方法和<code>scale</code>时调用的方法是同一个，该方法里只会执行scale 和 更新deployment操作</p>
</blockquote>
<h4 id="④判断是否是rollback"><a href="#④判断是否是rollback" class="headerlink" title="④判断是否是rollback"></a>④判断是否是rollback</h4><blockquote>
<p>该方法即将被移除掉。。</p>
</blockquote>
<h4 id="⑤判断是否是扩缩容引起的deployment变化"><a href="#⑤判断是否是扩缩容引起的deployment变化" class="headerlink" title="⑤判断是否是扩缩容引起的deployment变化"></a>⑤判断是否是扩缩容引起的deployment变化</h4><blockquote>
<p>通过对比 <code>deployment.template</code> 和 <code>newRs.template</code> 相等而且副本数不同来做扩缩容，那么直接调用 <code>dc.sync</code>方法，处理扩缩容，否则，则继续</p>
</blockquote>
<h4 id="⑥根据deployment的更新策略调用不同的逻辑"><a href="#⑥根据deployment的更新策略调用不同的逻辑" class="headerlink" title="⑥根据deployment的更新策略调用不同的逻辑"></a>⑥根据deployment的更新策略调用不同的逻辑</h4><blockquote>
<p>这里主要看下 RollingUpdate的情况</p>
<p>此时，调用方法 <code>dc.rolloutRolling</code>，该方法源码如下，已加入详细注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pkg/controller/deployment/rolling.go 31行</span><br><span class="line">func (dc *DeploymentController) rolloutRolling(d *apps.Deployment, rsList []*apps.ReplicaSet) error &#123;</span><br><span class="line">// getAllReplicaSetsAndSyncRevision，该方法中，实现了很多deployment的管理rs逻辑</span><br><span class="line">// 1. 版本回滚，版本回滚的时候，deployment.template被修改为指定版本的值，newRs其实是对比历史版本rs后，取rs.template与deployment.template相等的rs(同时会将rs初始化掉部分字段置空或按规则生成新值、修改版本号等)</span><br><span class="line">// 2. 新建rs，调用方法第三个参数为，如果不存在newRs是否创建，此处传值为true，那么新建deployment的时候，里边的逻辑会去创建新rs</span><br><span class="line">newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, true)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line">allRSs := append(oldRSs, newRS)</span><br><span class="line">// 判断新Rs是否需要增加、减少副本数</span><br><span class="line">// deployment控制pod的副本数、滚动更新 就是通过此处修改 rs的副本数间接管理，然后由rs去控制pod数量</span><br><span class="line">scaledUp, err := dc.reconcileNewReplicaSet(allRSs, newRS, d)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line">if scaledUp &#123;</span><br><span class="line">	// Update DeploymentStatus</span><br><span class="line">	return dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">&#125;</span><br><span class="line">// 判断旧Rs是否需要增加、减少副本数</span><br><span class="line">// 滚动更新的时候有一定的策略，一边减少旧版本副本(下边代码)、一边增加新版本副本(上边)</span><br><span class="line">scaledDown, err := dc.reconcileOldReplicaSets(allRSs, controller.FilterActiveReplicaSets(oldRSs), newRS, d)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line">if scaledDown &#123;</span><br><span class="line">	// Update DeploymentStatus</span><br><span class="line">	return dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">&#125;</span><br><span class="line">// 判断deployment 是否达到稳定状态(1.deployment实际状态与期望状态完全一致并可用，2.所有旧Pod都处于非Running状态)</span><br><span class="line">// 如果稳定，那么执行clean逻辑，主要是清理历史replicaSet(如果配置了deployment.spec.RevisionHistoryLimit)</span><br><span class="line">if deploymentutil.DeploymentComplete(d, &amp;d.Status) &#123;</span><br><span class="line">	if err := dc.cleanupDeployment(oldRSs, d); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Sync deployment status</span><br><span class="line">return dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s源码阅读</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s源码阅读</tag>
        <tag>controller-manager</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/blog/2019/12/05/20191205000815.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>今天看到一个分享，有讲到使用http请求时踩到了一个坑：服务端 <code>TIME_WAIT</code> 过多导致服务变得不可用。<br>通过这个案例来复习一下tcp协议，并分析原因和解决问题。</p>
</blockquote>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>TCP协议面向应用层提供一种面向连接的、可靠的字节流服务，它处于7层网络协议的第4层。</p>
<ol>
<li>面向连接意味着两个应用在使用TCP协议交互时要首先建立连接(后续将讲到如何建立连接和关闭连接)</li>
<li>可靠的服务表明由TCP协议交付给应用的数据是可靠的。可靠性指的是数据能够被 <code>正确地</code> <code>有序地</code> 传输</li>
</ol>
</blockquote>
<h3 id="协议首部"><a href="#协议首部" class="headerlink" title="协议首部"></a>协议首部</h3><blockquote>
<!-- ![TCP协议头](/resources/post_pic/2019/12/tcp_header.jpg "TCP协议头") -->
<img src="/resources/post_pic/2019/12/tcp_header.jpg" width="80%" alt="TCP协议头" title="TCP协议头" align=center />

<p>协议头部第一行，分别表明了TCP双方的端口号，结合IP层的源、目的地址IP可唯一确定一个TCP连接双方的信息。<br>第二行表示当前数据包编号，为TCP传输过程中标记数据编号，它用于TCP提供可靠数据传输时保证数据有序的依据<br>第三行表示对对方数据包的确认号。值为收到的数据编号+1<br>第四行，前4位表示TCP协议头部长度(限制了头部最长2^4-1字长，1个字长为32bit)，6位保留位之后为6位标志位：</p>
<ol>
<li>URG 紧急指针有效</li>
<li>ACK 确认序号有效</li>
<li>PSH 接收方应尽快将报文段交给应用层</li>
<li>RST 重建连接</li>
<li>SYN 同步序号发起一个连接</li>
<li>FIN 发送端完成发送任务</li>
</ol>
<p>第四行后16位为窗口大小，用于TCP数据传输过程中拥塞控制<br>第五行为校验和与紧急指针。<br>选项中字段：TODO<br>数据包可能为空</p>
</blockquote>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><blockquote>
<p>TCP首部可包含选项部分。每个选项若干字节，00、01 为不带len字节的选项。带len字节的选项第一个字节表示类型，第二个字节表示该选项配置的长度len，后续跟len-2个字节的选项值</p>
<ol>
<li>00 选项表结束</li>
<li>01 无操作</li>
<li>02 xx 最大报文段长度，后续跟着的xx个字节数据表示长度具体值</li>
<li>08 0a 时间戳，后续4字节时间戳值，4字节时间戳回显应答</li>
</ol>
</blockquote>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="连接过程：三次握手"><a href="#连接过程：三次握手" class="headerlink" title="连接过程：三次握手"></a>连接过程：三次握手</h3><blockquote>
<p>为了建立TCP连接，客户端程序与服务端程序共进行过程：</p>
<p>这个过程共有3次交互，也被叫做3次握手。</p>
<!-- ![TCP三次握手过程](/resources/post_pic/2019/12/tcp_3_handshake.jpg "TCP三次握手过程") -->
<img src="/resources/post_pic/2019/12/tcp_3_handshake.jpg" width="80%" alt="TCP三次握手过程" title="TCP三次握手过程" align=center />

<p>如图，大写 <code>SYN</code> <code>ACK</code> 表示的TCP协议头中的标志位，小写 <code>req</code>,<code>ack</code>表示TCP协议头中的传输数据编号和确认编号(握手过程中<code>syn</code>标志位一直为1)。</p>
</blockquote>
<p>首先看连接过程：</p>
<blockquote>
<ol>
<li>客户端发起数据传输连接请求，<code>seq</code>值为 <code>x</code></li>
<li>服务端收到客户端连接请求，回复确认<code>ACK</code>标志位为1,序号<code>ack=x+1</code>，同时发起服务端到客户端的连接请求，<code>seq</code>值位 <code>y</code>（标志位<code>ACK</code> <code>SYN</code>为1，<code>seq</code>值为<code>y</code>,<code>ack</code>值为<code>x+1</code>）</li>
<li>客户端收到确认请求，建立起 客户端-》服务端连接。并回复服务端连接请求,<code>ACK</code>标志位为1，确认序号<code>ack=y+1</code>，当服务端收到确认序号时，建立起 服务端-》客户端 连接</li>
</ol>
</blockquote>
<p>连接过程中的状态变化：</p>
<blockquote>
<p>客户端：</p>
<ol>
<li>一开始处于<code>CLOSE</code>状态，当主动发起连接请求后，状态变为<code>SYN_SENT</code></li>
<li>当服务端收到请求并回复<code>ACK</code>，客户端收到返回包并回复服务端<code>ACK</code>后，状态由<code>SYN_SENT</code>变为<code>ESTABLISHED</code>，客户端-》服务端 连接建立</li>
</ol>
<p>服务端:</p>
<ol>
<li>一开始处于<code>CLOSE</code>状态，当被动接受连接请求后，状态变为 <code>SYN_RCVD</code></li>
<li>当客户端收到请求并回复<code>ACK</code>，服务端收到<code>ACK</code>后，状态由 <code>SYN_RCVD</code>变为<code>ESTABLISHED</code>，服务端-》客户端连接建立</li>
</ol>
<p>至此，全双工的TCP连接建立完成，可以进行数据传输</p>
</blockquote>
<h3 id="断开过程：四次挥手"><a href="#断开过程：四次挥手" class="headerlink" title="断开过程：四次挥手"></a>断开过程：四次挥手</h3><blockquote>
<p>断开一个连接需要经过四次交互，这是因为TCP连接是全双工工作，每个数据传输方向需要单独关闭。<br>当一方完成数据传输时就可以发送一个<code>FIN</code>来终止这个方向的连接,接收<code>FIN</code>的一端收到信号后不再读数据但是仍可以发送数据，可以等数据发送完毕再发<code>FIN</code>信号进行关闭该方向的连接。</p>
<!-- ![TCP四次挥手过程](/resources/post_pic/2019/12/tcp_4_bye.jpg "TCP四次挥手过程") -->
<img src="/resources/post_pic/2019/12/tcp_4_bye.jpg" width="80%" alt="TCP四次挥手过程" title="TCP四次挥手过程" align=center />

</blockquote>
<p>断开连接时交互过程：</p>
<blockquote>
<ol>
<li>客户端数据发送完成后，向服务端发送<code>FIN</code>信号表明结束 <code>C-&gt;S</code>方向的连接</li>
<li>服务端收到<code>FIN</code>信号，回复<code>ACK</code>，客户端收到<code>ACK</code>，<code>C-&gt;S</code>方向连接正式关闭</li>
<li>服务端数据发送完成向客户端发送 <code>FIN</code>信号关闭<code>S-&gt;C</code>方向连接</li>
<li>客户端收到<code>FIN</code>信号，回复<code>ACK</code>，服务端收到<code>ACK</code>，<code>S-&gt;C</code>方向连接正式关闭</li>
</ol>
</blockquote>
<p>断开连接过程中的状态变化：</p>
<blockquote>
<p>主动断开方(图中的客户端)：</p>
<ol>
<li>一开始处于<code>ESTABLISHED</code>状态，当主动发起关闭连接请求后状态变为<code>FIN_WAIT_1</code>(等待对端响应)</li>
<li>当收到确认响应后，状态由<code>FIN_WAIT_1</code>变为<code>FIN_WAIT_2</code>(等待对端关闭连接)</li>
<li>当收到对端的关闭请求后，状态由<code>FIN_WAIT_2</code>变为<code>TIME_WAIT</code>(等待2个MSL[最大报文寿命,报文在网络传输过程中最大生存时间]超时)</li>
<li>当经过2个MSL超时后，状态由<code>TIME_WAIT</code>变为<code>CLOSE</code></li>
</ol>
<p>被动断开方(图中的服务端)：</p>
<ol>
<li>一开始处于<code>ESTABLISHED</code>状态，当收到关闭连接请求后，状态变为<code>CLOSE_WAIT</code></li>
<li>当服务端数据传输完毕，向对端发起关闭请求连接后，状态变为<code>LAST_ACK</code></li>
<li>当收到对端<code>ACK</code>消息后，状态由<code>LAST_ACK</code>变为<code>CLOSE</code></li>
</ol>
<p>主动断开方<code>TIME_WAIT</code>存在的必要性：<br>如果没有2MSL的<code>TIME_WAIT</code>状态，当主动断开方发送的<code>ACK</code>失败时，另一端会重发<code>FIN</code>请求，而这时，如果原来的连接被复用就会出问题。有了<code>TIME_WAIT</code>状态后，主动断开方的<code>ACK</code>应答如果在网络中丢失，那么另一端会重发<code>FIN</code>请求，它只需再次应答即可。当2个MSL时间后仍未收到重发的请求，则认为应答数据包正确到达对端。</p>
</blockquote>
<!--### 总结-->


<h2 id="TCP可靠性传输"><a href="#TCP可靠性传输" class="headerlink" title="TCP可靠性传输"></a>TCP可靠性传输</h2><h3 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h3><blockquote>
<ol>
<li>应用数据被分割成TCP认为最合适发送的数据段(区别于UDP数据包长度不变)，由TCP传给IP的信息单位成为报文段或段，后续将讲到如何确定报文段的长度。</li>
<li>当TCP发送一个段后，它会启动一个定时器，等待目的端确认收到报文段。若不能及时收到确认将会重发报文段</li>
<li>TCP收到另一端的数据后，它将发送一个确认，这个确认不是立即发送的，通常推迟几分之一秒(捎带ACK，如果同时需要发送数据给对端，将ACK捎带过去)</li>
<li>TCP将保持它的首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到的段和检验和有差错，TCP将丢弃该段，等待发送端超时重传</li>
<li>IP层交付的数据可能是失序的，TCP层会根据收到的数据重新排序，将数据以正确的顺序交付给上层</li>
<li>IP层有可能收到重复数据，TCP会丢弃掉重复的数据</li>
<li>TCP提供流量控制。TCP的对端都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能容纳的数据，这防止较快主机发送到慢主机时导致缓冲区溢出</li>
</ol>
</blockquote>
<h3 id="最大报文段长度"><a href="#最大报文段长度" class="headerlink" title="最大报文段长度"></a>最大报文段长度</h3><blockquote>
<p>最大报文段长度(MSS)表示TCP往另一端传输数据的最大块数据的长度。当开始建立连接的时候，连接的双方都会告知各自的MSS。MSS的值在TCP协议头的<code>选项</code>部分。</p>
</blockquote>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><blockquote>
<p>内核参数<code>net.ipv4.tcp_timestamps</code>控制tcp数据包里是否带有timestamp，如果带有，则接收到消息的时候会做时间过滤，不符合的会被丢掉。</p>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><img src="/resources/post_pic/2020/03/tcp_01_cwnd.jpg" alt="TCP滑动窗口" title="TCP滑动窗口"></p>
<blockquote>
<p>报文在发送过程中可能的状态：</p>
<ol>
<li>已发送</li>
<li>可发送，但未发送</li>
<li>可发送，已发送，但未收到ack</li>
<li>不可发送<br>TCP发送数据的时候，会指定滑动窗口大小，如上图，滑动窗口大小为6,首先，看传输过程中，滑动窗口在3-8报文段时的情况。此时，1,2报文段处于状态①，9之后的报文段处于状态④；在窗口3-8内，都是可发送的报文，有处于状态1、2、3的，当客户端收到报文段5的ack时，3-5报文状态变为1，此时滑动窗口向右滑动3个位置，变成6-11。数据传输的过程中，发送窗口不断随着网络情况调整大小。</li>
</ol>
</blockquote>
<h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><blockquote>
<p>拥塞控制主要通过一定的算法，不断修改拥塞窗口大小(cwnd,congestion window)达到目的。主要用到以下几种算法：</p>
<ol>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传: 当发送数据端连续收到3次同一个数据包ack时，进入快速重传。此时 ssthresh值设为当前cwnd的一半，</li>
</ol>
</blockquote>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><blockquote>
<p>cwnd从初始值1开始，每收到1个报文段ACK，cwnd增加1.(数据并发发送，在一定时间内如果无丢包，cwnd几乎呈指数级增加。起始值为1，收到这个包的ACK后cwnd+1，下次发送2个数据包，当2个数据包收到ACK后cwnd+2，再下次发送4个数据包，以此类推)<br>当cwnd值增加到ssthresh大小时，进入拥塞避免。</p>
<p>进入慢启动过程有两种情况：</p>
<ol>
<li>刚刚建立连接，开始发送数据： 刚开始时，ssthresh值由连接双方协商，cwnd值为1。然后不断增加cwnd值，到达ssthresh值大小时进入拥塞避免</li>
<li>链路发生拥塞，超时未收到ack： 发生拥塞时，ssthresh值变为cwnd一半，cwnd值变为1。然后通过慢启动算法不断增加cwnd，到达ssthresh值大小时进入拥塞避免</li>
</ol>
</blockquote>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><blockquote>
<p>当cwnd的值到达慢启动ssthresh的值后，每个RTT(Round Trip Time，往返时延)cwnd+1。在拥塞避免阶段cwnd值线性增加</p>
<p>进入拥塞避免有两种情况：</p>
<ol>
<li>由慢启动过程的2中情况转入拥塞避免：在慢启动中已列出2种情况</li>
<li>由快速重传状态转入拥塞避免：发生快速重传时，ssthresh值大小变为cwnd的一半，cwnd值也变为原来的一半(此时ssthresh与cwnd一样大)。</li>
</ol>
<p>拥塞避免最后转换为2种状态：</p>
<ol>
<li>变为慢启动： 当发生超时时，状态转换为慢启动。</li>
<li>变为快速重传： 当发生连续收到3个相同ack时，状态转换为快速重传</li>
</ol>
</blockquote>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><blockquote>
<p>进入快速重传的情况：</p>
<ol>
<li>连续收到3次同一个数据包的ack：收到3次ack包很可能是由丢包引起的(在数据接收端，当数据包N丢失后，后续收到N+1,N+2的数据包时都会重复向数据发送端发送对N-1的ACK包。如果2次重复ACK，有可能是数据包乱序到达，3次重复ACK，很可能是丢包，4次，很大可能丢包。但是判断丢包用的重复ack次数值越大，对网络性能影响越大。折中取了3次)</li>
</ol>
</blockquote>
<h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><ol>
<li>状态转换<br><img src="/resources/post_pic/2020/03/tcp_02.jpg" alt="拥塞控制状态转换" title="拥塞控制状态转换"></li>
<li>状态转换实例图<br><img src="/resources/post_pic/2020/03/tcp_03.png" alt="拥塞控制状态转换实例" title="拥塞控制状态转换实例"></li>
</ol>
]]></content>
      <categories>
        <category>网络基础知识</category>
        <category>TCP协议</category>
      </categories>
      <tags>
        <tag>网络基础知识</tag>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s特性01 —— admission webhook</title>
    <url>/blog/2019/12/02/20191202233710.html</url>
    <content><![CDATA[<h1 id="admission-webhook-简介"><a href="#admission-webhook-简介" class="headerlink" title="admission webhook 简介"></a>admission webhook 简介</h1><blockquote>
<p>k8s准入控制通过http回调实现，在这个http服务里可以对请求的参数进行修改或者验证。在k8s里，可修改的wehook资源类型是 <code>mutatingWebhookConfiguration</code>,验证的wenhook资源类型是 <code>validatingWebhookConfiguration</code>。在调用链中，mutatingWebhook优先于validatingWebhook执行。</p>
</blockquote>
<h1 id="利用service实现"><a href="#利用service实现" class="headerlink" title="利用service实现"></a>利用service实现</h1><blockquote>
<p>demo地址：<a href="https://github.com/geedchin/k8s-webhook-demo" target="_blank" rel="noopener">k8s-webhook-demo</a></p>
</blockquote>
<h2 id="首先，通过k8s签发证书"><a href="#首先，通过k8s签发证书" class="headerlink" title="首先，通过k8s签发证书"></a>首先，通过k8s签发证书</h2><h3 id="创建k8s-csr-CertificateSigningRequest-资源"><a href="#创建k8s-csr-CertificateSigningRequest-资源" class="headerlink" title="创建k8s csr(CertificateSigningRequest)资源"></a>创建k8s csr(CertificateSigningRequest)资源</h3><blockquote>
<p>首先在空白目录下生成自己的csr文件及私钥，根据实际情况修改hosts和其他内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "hosts": [</span><br><span class="line">   "10.1.1.50"</span><br><span class="line"> ],</span><br><span class="line"> "CN": "kubernetes",</span><br><span class="line"> "key": &#123;</span><br><span class="line">   "algo": "ecdsa",</span><br><span class="line">   "size": 256</span><br><span class="line"> &#125;,</span><br><span class="line"> "names": [</span><br><span class="line">   &#123;</span><br><span class="line">     "C": "CN",</span><br><span class="line">     "ST": "SZ",</span><br><span class="line">     "L": "SZ",</span><br><span class="line">     "O": "k8s",</span><br><span class="line">     "OU": "System"</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>
<p>此时生成两个文件：server.csr, server-key.pem，server.csr用于向ca申请公钥，server-key.pem为服务的私钥。</p>
<p>使用以下命令生成k8s中的csr资源对象：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1beta1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: my-csr</span><br><span class="line">spec:</span><br><span class="line">  request: $(cat server.csr | base64 | tr -d '\n')</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  - server auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行以下命令通过申请： <code>kubectl certificate approve my-csr</code> <br><br>执行命令获取签发后的文件： <code>kubectl get csr my-csr -o jsonpath=&#39;{.status.certificate}&#39; | base64 --decode &gt; server.crt</code> <br><br>server.crt文件即为签发后的公钥</p>
</blockquote>
<h2 id="运行demo"><a href="#运行demo" class="headerlink" title="运行demo"></a>运行demo</h2><blockquote>
<p>将<code>server.crt</code> 及 <code>server-key.pem</code> 文件放至demo项目 <code>file/</code> 文件夹下。<br>直接运行项目即可。</p>
</blockquote>
<h2 id="创建-mutatingWebhookConfiguration-资源对象"><a href="#创建-mutatingWebhookConfiguration-资源对象" class="headerlink" title="创建 mutatingWebhookConfiguration 资源对象"></a>创建 mutatingWebhookConfiguration 资源对象</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-webhook</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook01.default.local</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://10.1.1.50:1443/mutatingwebhook</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my-webhook</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/mutatingwebhook</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span> </span><br><span class="line">    <span class="attr">caBundle:</span> <span class="string">//TODO</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CREATE</span></span><br><span class="line">    <span class="attr">apiGroups:</span> <span class="string">["*"]</span></span><br><span class="line">    <span class="attr">apiVersions:</span> <span class="string">["*"]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span> </span><br><span class="line">      <span class="attr">my-webhook:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">sideEffects:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">admissionReviewVersions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">v1beta1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>url根据实际情况填写<br>caBundle的值从集群config里取即可。路径：.clusters.cluster.certificate-authority-data<br>其他webhook的规则、namespaceSelector根据实际情况修改</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<ol>
<li>根据上一步中设置的namespaceSelector规则，给待测试的namespace打上标签，我这里用的是default测试，执行命令打上标签<code>kubectl label ns default my-webhook=true</code></li>
<li>在测试命名空间创建一个deployment，然后获取该deployment下的pod实例，即可查看到annotation里加上了webhook里打的patch内容</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s特性</category>
        <category>admission webhook</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s特性</tag>
        <tag>admission webhook</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码阅读02——apiserver</title>
    <url>/blog/2019/12/01/20191201215410.html</url>
    <content><![CDATA[<h1 id="整体："><a href="#整体：" class="headerlink" title="整体："></a>整体：</h1><p>TODO: webhook中使用service方式时，apiserver的pod使用hostNetwork，实际是无法解析service fqdn域名的，那么，在apiserver中是如何正确地请求到webhook的。</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s源码阅读</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s源码阅读</tag>
        <tag>apiserver</tag>
      </tags>
  </entry>
  <entry>
    <title>istio-crd</title>
    <url>/blog/2019/11/07/20191107171206.html</url>
    <content><![CDATA[<h1 id="pod容器间通信"><a href="#pod容器间通信" class="headerlink" title="pod容器间通信"></a>pod容器间通信</h1><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>istio</category>
        <category>crd</category>
      </categories>
      <tags>
        <tag>istio-crd</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码阅读01——K8S调度器（1）</title>
    <url>/blog/2019/08/03/20190803202810.html</url>
    <content><![CDATA[<h1 id="调度器概述"><a href="#调度器概述" class="headerlink" title="调度器概述"></a>调度器概述</h1><p>K8S调度器主要负责将Pod调度到某Node上运行。可以把调度器看做一个黑盒，输入为：pod,nodeList，输出为node，即给定pod和node列表，返回一个将pod调度到某node的结果。</p>
<p>整个调度流程大致如下：</p>
<pre class="mermaid">graph LR;
id1((Start))-->预选
预选-->优选
优选-->id2{是否调度到}
id2-->|是|id3
id2-->|否|抢占
抢占-->id3((结束))</pre>

<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>本文基于14.3源码</p>
<p>入口文件是在 <code>cmd/kube-scheduler/scheduler.go</code>，加载配置逻辑是 <code>cmd/kube-scheduler/app</code> 文件夹下。整个调度过程逻辑是在 <code>pkg/scheduler</code>下。</p>
<p>源码阅读主要从以下几方面：启动前初始化、启动过程、调度过程(预选、优选、抢占)</p>
<h2 id="启动前初始化过程"><a href="#启动前初始化过程" class="headerlink" title="启动前初始化过程"></a>启动前初始化过程</h2><p>启动前初始化函数不少，重点关注<code>pkg/scheduler/algorithmprovider/defaults</code>包下的3个文件里的init()。</p>
<ol>
<li><code>default.go/init()</code>方法主要注册了算法provider，目前有两个算法provider，分别是<code>DefaultProvider</code>和<code>ClusterAutoscalerProvider</code>。provider是一组算法的组合，包括预选、优选过程中的众多算法。此处注册过程只用到了算法的名字，到真正用到算法时会根据算法名取算法实现。</li>
<li><code>register_predicates.go/init()</code>方法主要注册多种预选算法，此处注册的方法通过名字与1中关联</li>
<li><code>register_priorities.go/init()</code>方法主要注册多种优选算法，此处注册的方法通过名字与1中关联</li>
</ol>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	command := app.NewSchedulerCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">	<span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从main函数(<code>cmd/kube-scheduler/scheduler.go</code>)看起：如上，可以看到main函数核心在 command.Execute，再找到command的类型是SchedulerCommand，然后追踪到该command的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">"kube-scheduler"</span>,</span><br><span class="line">		Long: <span class="string">`...`</span>,</span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := runCommand(cmd, args, opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注 <code>Run:func(cmd *cobra.Command,args []string)</code>，在这段代码里主要调用了 runCommand方法，再看这个方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCommand</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>, opts *options.Options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	verflag.PrintAndExitIfRequested()</span><br><span class="line">	utilflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">// 加载启动配置参数、选主（同一时间只有一个调度器真正在调度）</span></span><br><span class="line">	c, err := opts.Config()</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据配置的配置文件，complete配置</span></span><br><span class="line">	cc := c.Complete()</span><br><span class="line">	<span class="comment">// 根据featureGate决定使用的算法</span></span><br><span class="line">	algorithmprovider.ApplyFeatureGates()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configz registration.</span></span><br><span class="line">	<span class="keyword">if</span> cz, err := configz.New(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		cz.Set(cc.ComponentConfig)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Run(cc, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略部分不重要代码，留下了核心代码并加了注释，应该很好懂了。最后执行Run方法，接下来看Run方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(cc schedulerserverconfig.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建调度器，初始化调度器参数</span></span><br><span class="line">	sched, err := scheduler.New(cc.Client,</span><br><span class="line">		cc.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">		cc.PodInformer,</span><br><span class="line">		cc.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">		cc.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">		cc.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">		cc.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		cc.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">		cc.InformerFactory.Core().V1().Services(),</span><br><span class="line">		cc.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">		cc.InformerFactory.Storage().V1().StorageClasses(),</span><br><span class="line">		cc.Recorder,</span><br><span class="line">		cc.ComponentConfig.AlgorithmSource,</span><br><span class="line">		stopCh,</span><br><span class="line">		scheduler.WithName(cc.ComponentConfig.SchedulerName),</span><br><span class="line">		scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),</span><br><span class="line">		scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),</span><br><span class="line">		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">		scheduler.WithBindTimeoutSeconds(*cc.ComponentConfig.BindTimeoutSeconds))</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动所有 informers.</span></span><br><span class="line">	<span class="keyword">go</span> cc.PodInformer.Informer().Run(stopCh)</span><br><span class="line">	cc.InformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all caches to sync before scheduling.</span></span><br><span class="line">	cc.InformerFactory.WaitForCacheSync(stopCh)</span><br><span class="line">	controller.WaitForCacheSync(<span class="string">"scheduler"</span>, stopCh, cc.PodInformer.Informer().HasSynced)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare a reusable runCommand function.</span></span><br><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		sched.Run()</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.TODO()) <span class="comment">// TODO once Run() accepts a context, it should be used here</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Leader election is disabled, so runCommand inline until done.</span></span><br><span class="line">	run(ctx)</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"finished without leader elect"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，主要初始化了调度器的参数，定义了一个可stop的方法run，最后执行run(ctx)，查看run方法，里边的核心代码是 <code>sched.Run()</code>，此时代码进入到了 <code>pkg/scheduler</code>包里。继续追踪：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !sched.config.WaitForCacheSync() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.config.StopEverything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行的代码 go wait.Until…，实际上调用了<code>sched.scheduleOne</code>方法，并无限循环。</p>
<p>至此，启动过程结束，代码真正进到了调度处。</p>
<h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm&apos;s host fitting.</span><br><span class="line">func (sched *Scheduler) scheduleOne() &#123;</span><br><span class="line"></span><br><span class="line">	// 从待调度队列中取出一个待调度的pod，此处无数据时会阻塞</span><br><span class="line">	pod := sched.config.NextPod()</span><br><span class="line">	</span><br><span class="line">	// Synchronously attempt to find a fit for the pod.</span><br><span class="line">	start := time.Now()</span><br><span class="line">	// 执行调度方法，返回调度结果</span><br><span class="line">	scheduleResult, err := sched.schedule(pod)</span><br><span class="line">	// 如果调度出错，则可能进入抢占逻辑。</span><br><span class="line">	// 无论什么类型错误，进入if后都会return，结束本轮调度</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		// 如果错误类型是 FitError</span><br><span class="line">		if fitError, ok := err.(*core.FitError); ok &#123;</span><br><span class="line">			// 如果不允许抢占，则报错</span><br><span class="line">			if !util.PodPriorityEnabled() || sched.config.DisablePreemption &#123;</span><br><span class="line">				klog.V(3).Infof(&quot;Pod priority feature is not enabled or preemption is disabled by scheduler configuration.&quot; +</span><br><span class="line">					&quot; No preemption is performed.&quot;)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 否则，进入抢占</span><br><span class="line">				preemptionStartTime := time.Now()</span><br><span class="line">				sched.preempt(pod, fitError)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 否则，报错</span><br><span class="line">			klog.Errorf(&quot;error selecting node for pod: %v&quot;, err)</span><br><span class="line">			metrics.PodScheduleErrors.Inc()</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// ... 省略调度成功后绑定volume等操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sched *Scheduler) schedule(pod *v1.Pod) (core.ScheduleResult, error) &#123;</span><br><span class="line">	result, err := sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		pod = pod.DeepCopy()</span><br><span class="line">		sched.recordSchedulingFailure(pod, err, v1.PodReasonUnschedulable, err.Error())</span><br><span class="line">		return core.ScheduleResult&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	return result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主流程如上，先调度，再判断是否需要抢占，必要时进入抢占，调度成功则执行后续的收尾工作。再看一下调度方法(<code>sched.config.Algorithm.Schedule</code>)：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(result ScheduleResult, err error)</span></span> &#123;</span><br><span class="line">	trace := utiltrace.New(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</span><br><span class="line">	<span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodes, err := nodeLister.List()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, ErrNoNodesAvailable</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := g.snapshot(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace.Step(<span class="string">"Computing predicates"</span>)</span><br><span class="line">	startPredicateEvalTime := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 核心代码，预选过程，找到可运行pod的nodes</span></span><br><span class="line">	filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没找到，直接return</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, &amp;FitError&#123;</span><br><span class="line">			Pod:              pod,</span><br><span class="line">			NumAllNodes:      <span class="built_in">len</span>(nodes),</span><br><span class="line">			FailedPredicates: failedPredicateMap,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace.Step(<span class="string">"Prioritizing"</span>)</span><br><span class="line">	startPriorityEvalTime := time.Now()</span><br><span class="line">	<span class="comment">// When only one node after predicate, just use it.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">1</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">			SuggestedHost:  filteredNodes[<span class="number">0</span>].Name,</span><br><span class="line">			EvaluatedNodes: <span class="number">1</span> + <span class="built_in">len</span>(failedPredicateMap),</span><br><span class="line">			FeasibleNodes:  <span class="number">1</span>,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metaPrioritiesInterface := g.priorityMetaProducer(pod, g.nodeInfoSnapshot.NodeInfoMap)</span><br><span class="line">	<span class="comment">// 核心代码，优选过程，计算每个node的优先级得分</span></span><br><span class="line">	priorityList, err := PrioritizeNodes(pod, g.nodeInfoSnapshot.NodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	trace.Step(<span class="string">"Selecting host"</span>)</span><br><span class="line">	<span class="comment">// 找到优先级得分最大的node</span></span><br><span class="line">	host, err := g.selectHost(priorityList)</span><br><span class="line">	<span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">		SuggestedHost:  host,</span><br><span class="line">		EvaluatedNodes: <span class="built_in">len</span>(filteredNodes) + <span class="built_in">len</span>(failedPredicateMap),</span><br><span class="line">		FeasibleNodes:  <span class="built_in">len</span>(filteredNodes),</span><br><span class="line">	&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文仅讲解了调度器启动前的初始化过程以及调度整体流程，细节实现还需读者自行了解。</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s源码阅读</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s源码阅读</tag>
        <tag>k8s调度器</tag>
      </tags>
  </entry>
  <entry>
    <title>sync.Mutex源码</title>
    <url>/blog/2019/07/06/20190706025011.html</url>
    <content><![CDATA[<p>TOC</p>
<p>首先看下源码文件 sync/mutex.go里边开头的注释</p>
<blockquote>
<p>sync包提供基本同步原语，如互斥锁，除了Once和WaitGroup外，大多数类型都是供低层级库的协程使用，更高级别的同步最好通过通道和通信来完成，不应复制包含此包中定义的类型的值。</p>
</blockquote>
<p>由注释可以看出，官方建议使用channel来做同步，而且此包中的值不允许复制，主要原因是，复制后加锁和解锁操作就不作用在同一个对象上，这样就会出问题。如下例子运行时会报<code>unlock of unlocked mutex</code>错误：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	lock := sync.Mutex&#123;&#125;</span><br><span class="line">	Lock(lock)</span><br><span class="line">	lock.Unlock()<span class="comment">// 此行panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用此函数时会发生复制，这里加锁针对的是副本加锁</span></span><br><span class="line"><span class="comment">// 源lock未加锁，因此上边调用加锁会发生panic</span></span><br><span class="line"><span class="comment">// sync包下其他类型复制会发生同样问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lock</span><span class="params">(lock sync.Mutex)</span></span> &#123;</span><br><span class="line">	lock.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下定义常量下边的注释：</p>
<blockquote>
<p>锁公平：</p>
<p>互斥可以有两种操作模式：正常和饥饿。</p>
<ol>
<li><p>在正常模式下，等待加锁的G按FIFO顺序排队，但被唤醒的waiter并不持有锁，它们与新来的G争夺所有权，新来的G有一个优势，它们已经在CPU上运行，而且可能有很多，所以一个被唤醒的G很有可能抢不到锁，在这种情况下，它将在等待队列前面排队，如果有waiter超过1ms无法获取互斥量，则互斥量mutex进入饥饿模式；</p>
</li>
<li><p>在饥饿模式下，互斥体的所有权直接从解锁的G移交给队列前边的waiter，新来的G不会去争夺锁，即使它看起来是解锁的，也不会去spinning，它们会在队尾排队。如果waiter收到互斥的所有权，并看到①它是队列中最后一个waiter或②它等待不到1ms，它将从互斥模式切换回正常模式。</p>
</li>
</ol>
<p>正常模式有相当好的性能，因为Goroutine可以连续多次获取互斥，即使有阻塞的等待程序。饥饿模式对预防尾部潜伏期病变具有重要意义。</p>
</blockquote>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span></span><br><span class="line">	sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 Mutex.sema表示信号量，Mutex.status字段每一位含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state:   |32|31|...| |3|2|1|</span><br><span class="line">         \__________/ | | |</span><br><span class="line">              |       | | |</span><br><span class="line">              |       | | +--- mutex的占用状态（1被占用，0可用）</span><br><span class="line">              |       | |</span><br><span class="line">              |       | +---mutex的当前goroutine是否被唤醒</span><br><span class="line">              |       |</span><br><span class="line">              |       +---饥饿位，0正常，1饥饿</span><br><span class="line">              |</span><br><span class="line">              +---等待唤醒以尝试锁定的goroutine的计数，0表示没有等待者</span><br></pre></td></tr></table></figure>


<h1 id="加锁解锁方法源码"><a href="#加锁解锁方法源码" class="headerlink" title="加锁解锁方法源码"></a>加锁解锁方法源码</h1><p>Mutex一共有两个方法：<code>Lock()</code> 和 <code>Unlock()</code></p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a><code>Lock()</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁定Mutex.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don't spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">		<span class="comment">// so we won't be able to acquire the mutex anyway.</span></span><br><span class="line">		<span class="comment">// 如果原状态为非饥饿模式的锁定状态，且canSpin(函数实现在下边，当iter&lt;4、cpu数&gt;1、至少由1个运行中的p、当前p的运行g队列为空，则可spin)</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked  <span class="comment">// 确定是已锁定的非饥饿状态  mutexLocked|mutexStarving = 00...00101  当且仅当old==1时 old &amp; 101 == 1成立 </span></span><br><span class="line">		&amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">			<span class="comment">// 尝试设置mutexWoken标记来通知Unlock，不去唤醒其他阻塞的G</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp;</span><br><span class="line">				old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; <span class="comment">// 再次确认未被唤醒</span></span><br><span class="line">				old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp; <span class="comment">// 确认有G在排队</span></span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123; <span class="comment">// 将对象锁置为唤醒状态</span></span><br><span class="line"></span><br><span class="line">				awoke = <span class="literal">true</span> <span class="comment">// 标记当前G awoke</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin() <span class="comment">// 空转，根据iter，重试一定次数将不再空转</span></span><br><span class="line">			iter++<span class="comment">// 自旋次数</span></span><br><span class="line">			old = m.state <span class="comment">// 更新old</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">new</span> := old <span class="comment">// 不可空转、 或 ！非饥饿模式的锁定状态</span></span><br><span class="line">		<span class="comment">// 不要试图获取饥饿的mutex，新来的G必须排队.</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 若old是非饥饿模式，标记加锁</span></span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123; <span class="comment">// 如果old 已加锁/饥饿模式/加锁数!=0 则加锁数+1</span></span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.当前G切换到饥饿模式，但若mutex当前未加锁，则不切换</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don't do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">		<span class="comment">// be true in this case.  Unlock期望饥饿模式下有等待者，这种情况下不会为true</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123; <span class="comment">// 若处于饥饿模式，且(已加锁或有waiter)，则new饥饿位做标记</span></span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> awoke &#123; <span class="comment">// 如果唤醒</span></span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123; <span class="comment">// 如果new的mutexWoken位为0，则抛异常</span></span><br><span class="line">				throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">			&#125;<span class="comment">// 将唤醒位置0</span></span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">		&#125;<span class="comment">// 获锁成功</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123; <span class="comment">// 如果old值锁位与饥饿位标志都为0，则说明获锁成功直接break</span></span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span> <span class="comment">// 如果队列不为0，则入队</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/proc.go   linkname sync.runtime_canSpin()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// sync.Mutex is cooperative, so we are conservative with spinning.</span></span><br><span class="line">	<span class="comment">// Spin only few times and only if running on a multicore machine and</span></span><br><span class="line">	<span class="comment">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</span></span><br><span class="line">	<span class="comment">// As opposed to runtime mutex we don't do passive spinning here,</span></span><br><span class="line">	<span class="comment">// because there can be work on global runq or on other Ps.</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock()"></a><code>Unlock()</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 一个加锁状态的mutex不会与特定的G关联，允许在一个G加锁在另一个G解锁</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.  快速路径，删除锁标记</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 如果new的饥饿标记位为0</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line">			<span class="comment">// So get off the way.</span></span><br><span class="line">			<span class="comment">// 如果没有waiter或有G已经被唤醒或获得锁，不必再去唤醒</span></span><br><span class="line">			<span class="comment">// 在饥饿模式，解锁的G直接将锁所有权移交给下一个waiter</span></span><br><span class="line">			<span class="comment">// 我们不是</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || <span class="comment">// 没有waiter在排队</span></span><br><span class="line">				old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;<span class="comment">// 处于锁定、唤醒、饥饿状态</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">			<span class="comment">// 抓住唤醒一个waiter的机会</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter.</span></span><br><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line">		<span class="comment">// so new coming goroutines won't acquire it.</span></span><br><span class="line">		<span class="comment">// 饥饿模式：移交mutex所有权到下一个waiter</span></span><br><span class="line">		<span class="comment">// 注意：MutexLocked没有被设置，waiter将会在唤醒后设置它，但如果mutexStarving被设置的情况下</span></span><br><span class="line">		<span class="comment">// 需要考虑锁定mutex，因此新到达的G不会获得锁</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go-channel基础</title>
    <url>/blog/2019/07/01/20190701004200.html</url>
    <content><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><blockquote>
<p>首先看一下<code>channel</code>的结构定义</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// 队列长度，缓冲区中入队的数据长度</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列总长度，即缓冲区总长度</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// 队列中的数据</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span>			<span class="comment">//  chan中元素类型长度(unsafe.Sizeof(type))</span></span><br><span class="line">	closed   <span class="keyword">uint32</span>			<span class="comment">//  是否关闭，0，1</span></span><br><span class="line">	elemtype *_type <span class="comment">// chan中元素类型</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// 发送元素的索引 </span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// 接受元素的索引(配合sendx和buf，可以得到缓冲区真正的数据)</span></span><br><span class="line">	recvq    waitq  <span class="comment">// 等待接收数据的g队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// 等待发送数据的g队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex      <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有缓冲channel"><a href="#有缓冲channel" class="headerlink" title="有缓冲channel"></a>有缓冲channel</h1><p>对于一个有缓冲的通道，有如下规则：</p>
<ol>
<li>发送操作会使通道复制被发送的元素。若因通道缓冲区已满而无法复制，则会阻塞发送操作的goroutine。复制的目的地有两种：①当通道缓冲区无数据且有接收方在等待接收数据时，数据将会被直接复制到接收方持有的内存地址；②否则，复制到通道的buf中</li>
<li>接收操作会使通道给出一个已发送给它的元素值的副本，如果通道无数据，则会阻塞接收操作的goroutine</li>
<li>对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道接受它的操作完成之前完成</li>
</ol>
<p>注意：</p>
<ol>
<li>channel变量是引用类型，因此它的初始值为nil，向一个nil的channel发送或接收数据将会导致永久阻塞</li>
<li>发送方向通道发送的数据会被复制，至少1次，最多两次。①1次的情形：A 已有接收方阻塞且通道无缓冲数据;B 无缓冲的channel ②2次情形：无缓冲channel不会复制2次，有缓冲channel只要缓冲区有数据，则都会发生两次</li>
</ol>
<h1 id="happen-before"><a href="#happen-before" class="headerlink" title="happen before"></a>happen before</h1><h2 id="发送操作与接收操作的happen-before"><a href="#发送操作与接收操作的happen-before" class="headerlink" title="发送操作与接收操作的happen before"></a>发送操作与接收操作的happen before</h2><ol>
<li>无缓冲channel：接收操作完成都在发送操作完成后</li>
<li>有缓冲channel：缓冲长度为k，第c个数据接收完成发送在第k+c个数据发送之前</li>
</ol>
<h2 id="发送操作前后代码的happen-before"><a href="#发送操作前后代码的happen-before" class="headerlink" title="发送操作前后代码的happen before"></a>发送操作前后代码的happen before</h2><pre class="mermaid">graph TD;
subgraph 协程 g1
1-->idch1(channel操作)
idch1-->A
A-->X
end
subgraph 协程 g2
2-->idch2(channel操作)
idch2-->B
B-->Y
end</pre>
<p>解释：<br>如上图两个协程 g1 和 g2，channel操作指的是读或者写操作，这里两个协程一读一写。happen-before会使代码执行有以下顺序：</p>
<ol>
<li>1 -&gt; B -&gt; Y  </li>
<li>2 -&gt; A -&gt; X </li>
<li>1 -&gt; A -&gt; X</li>
<li>2 -&gt; B -&gt; Y<br>其他顺序无法保证，比如： A与B、Y，B与A、X，1与2，整体顺序如下图：<pre class="mermaid">graph TD;
subgraph 协程 g1
1-->idch1(channel操作)
idch1-->A
A-->X
end
subgraph 协程 g2
2-->idch2(channel操作)
idch2-->B
B-->Y
end
1-->idch2
idch2-->A
2-->idch1
idch1-->B</pre>

</li>
</ol>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="向通道写数据"><a href="#向通道写数据" class="headerlink" title="向通道写数据"></a>向通道写数据</h2><ol>
<li><p>先判断是否有读channel的G阻塞到这里，如果有，则直接将数据复制到等待读数据的G的elem域，并将其标记为<code>_Grunnable</code>，结束</p>
</li>
<li><p>否则，判断channel中已有数据是否小于缓冲大小，如果小于，则将数据复制到channel的循环队列中，结束</p>
</li>
<li><p>否则，判断如果是非阻塞，则直接返回false，表示写数据失败</p>
</li>
<li><p>否则，获取当前g，封装sudog，并把sudog放到channel的sendq域，然后将其标记为<code>_Gwating</code>，等有数据被读取，这里会被唤醒，并执行后续代码，最后返回true</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 1  </span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 4  // Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从通道读数据"><a href="#从通道读数据" class="headerlink" title="从通道读数据"></a>从通道读数据</h2></li>
<li><p>如果channel已关闭，且缓冲区无数据，则直接返回</p>
</li>
<li><p>否则，判断通道是否有写数据的G阻塞，如果有，则调用recv()函数并直接返回<br>2.1 recv()  如果缓冲区无数据，则直接将数据从sudog的G.elem中copy到ep<br>2.2 recv()  否则，将缓冲区第一个数据copy到ep中，并将阻塞的G.elem数据copy到缓冲区队列<br>2.3 recv()  将sudog.g的状态从<code>_Gwaiting</code>转为<code>_Grunnable</code></p>
</li>
<li><p>否则，若缓冲区队列已有数据，则直接从缓冲区复制，直接返回</p>
</li>
<li><p>否则，若非阻塞，直接返回失败</p>
</li>
<li><p>否则，获取当前g，初始化sudog，将sudog放至channel.recvq队列中，并将状态转至<code>_Gwaiting</code>，等待唤醒</p>
</li>
<li><p>唤醒之后，执行后续逻辑，返回接收数据成功</p>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5</span></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6</span></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/select.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A runtimeSelect is a single case passed to rselect.</span></span><br><span class="line"><span class="comment">// This must match ../reflect/value.go:/runtimeSelect</span></span><br><span class="line"><span class="keyword">type</span> runtimeSelect <span class="keyword">struct</span> &#123;</span><br><span class="line">	dir selectDir      <span class="comment">// selectSend、selectRecv、selectDefault 分别代表case里的事件 发送、接收、default</span></span><br><span class="line">	typ unsafe.Pointer <span class="comment">// channel type (not used here)</span></span><br><span class="line">	ch  *hchan         <span class="comment">// channel</span></span><br><span class="line">	val unsafe.Pointer <span class="comment">// ptr to data (SendDir) or ptr to receive buffer (RecvDir)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">		block()</span><br><span class="line">	&#125;</span><br><span class="line">	sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">	order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		rc := &amp;cases[i]</span><br><span class="line">		<span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line">		<span class="keyword">case</span> selectDefault:</span><br><span class="line">			sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line">		<span class="keyword">case</span> selectSend:</span><br><span class="line">			sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">		<span class="keyword">case</span> selectRecv:</span><br><span class="line">			sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> raceenabled || msanenabled &#123;</span><br><span class="line">			selectsetpc(&amp;sel[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select case descriptor.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's scasetype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	kind        <span class="keyword">uint16</span></span><br><span class="line">	pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，初始时，会遍历select里的所有case，并将这些case放入scase数组，scase数组描述每个case的事件，最后将其作为参数调用<code>selectgo</code>方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// selectgo 实现了select的功能.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span><br><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine's</span></span><br><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// selectgo 返回选中的nscase在数组cas0中的下标，它也是select调用语句中对应位置的序号</span></span><br><span class="line"><span class="comment">// 如果选中的scase事件是channel接收事件，第二个参数表示是否有值发送到接收方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"select: cas0="</span>, cas0, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases]</span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">			scases[i].releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"i="</span>, i, <span class="string">" x="</span>, lockorder[i], <span class="string">" y="</span>, lockorder[i+<span class="number">1</span>], <span class="string">"\n"</span>)</span><br><span class="line">				throw(<span class="string">"select: broken sort"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault:</span><br><span class="line">			dfli = casi</span><br><span class="line">			dfl = cas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">		selunlock(scases, lockorder)</span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="keyword">int</span>(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we'll see that it's now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won't block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"wait-return: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">" cas="</span>, cas, <span class="string">" kind="</span>, cas.kind, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			msanread(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125;</span><br><span class="line">		raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">		racerelease(chanbuf(c, c.recvx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">		racerelease(chanbuf(c, c.sendx))</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>channel</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine状态变换</title>
    <url>/blog/2019/06/27/20190627235500.html</url>
    <content><![CDATA[<h1 id="G状态变换"><a href="#G状态变换" class="headerlink" title="G状态变换"></a>G状态变换</h1><pre class="mermaid">graph TD;

id1((Start))-->|新建|Gidle
Gidle-->|初始化|Grunnable
Grunnable-->|开始运行|Grunning
Grunning-->|运行完成|Gdead

Gdead-->|结束|id100((End))

Grunning-->|等待事件|Gwaiting
Gwaiting-->|"事件到来，G去向「①p.runq ②sched.runq ③running」"|Grunnable

Grunning-->|"进入系统调用，此时如果可用M不够用会创建线程"|Gsyscall
Gsyscall-->|"退出系统调用，被放入调度器可运行队列"|id2{是否可直接运行}
id2-->|是|Grunning
id2-->|否|Grunnable
Grunning-->|需要扩展/收缩栈|Gcopystack
Gcopystack-->|扩展收缩栈完成|Grunning
Gdead-->|重新初始化|Grunnable</pre>
<h1 id="P状态变换"><a href="#P状态变换" class="headerlink" title="P状态变换"></a>P状态变换</h1><pre class="mermaid">graph TD;

id0((Start))-->|新建|Pgcstop
Pgcstop-->|完成初始化|Pidle
Pgcstop-->|启动调度|Pidle
Pidle-->|与某个M建立关联|Prunning
Prunning-->|与某个M断开关联|Pidle
Prunning-->|进入系统调用|Psyscall
Psyscall-->|退出系统调用|Prunning
Pdead-->|结束|id100((End))

Pidle-->|丢弃|Pdead
Prunning-->|丢弃|Pdead
Psyscall-->|丢弃|Pdead
Psyscall-->|停止调度|Pgcstop
Pidle-->|停止调度|Pgcstop
Prunning-->|停止调度|Pgcstop</pre>




]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>go程序启动过程分析</title>
    <url>/blog/2019/06/27/20190627220000.html</url>
    <content><![CDATA[<blockquote>
<p>os：osx 10.14.5</p>
<p>go version: 1.12.5 darwin/amd64</p>
<p>不加特说说明的文件都是在 runtime 包下</p>
</blockquote>
<h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><blockquote>
<p>整个程序入口是在 <code>rt0_darwin_amd64.s</code>的第8行。此处只有一行汇编<code>JMP _rt0_amd64(SB)</code>,跳转到<code>asm_amd64.s</code>中的第14行，配置好 <code>argc</code> <code>argv</code>后又跳转到 <code>rt0_go</code>(87行)。正式开始初始化go程序的运行时环境。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0</span><br><span class="line">	// 将参数向前复制到一个偶数栈上</span><br><span class="line">	MOVQ	DI, AX		// argc</span><br><span class="line">	MOVQ	SI, BX		// argv</span><br><span class="line">	SUBQ	$(4*8+7), SP		// 2args 2auto</span><br><span class="line">	ANDQ	$~15, SP</span><br><span class="line">	MOVQ	AX, 16(SP)</span><br><span class="line">	MOVQ	BX, 24(SP)</span><br><span class="line"></span><br><span class="line">	// 从给定（操作系统）栈中创建 istack。</span><br><span class="line">	// _cgo_init 可能更新 stackguard</span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(-64*1024+104)(SP), BX</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br><span class="line"></span><br><span class="line">	// 寻找正在运行的处理器信息</span><br><span class="line">	MOVL	$0, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, SI</span><br><span class="line">	</span><br><span class="line">	// CPU 相关的一些检测</span><br><span class="line">	(...)</span><br><span class="line"></span><br><span class="line">#ifdef GOOS_darwin</span><br><span class="line">	// 跳过 TLS 设置 on Darwin</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">	CALL	runtime·settls(SB)</span><br><span class="line"></span><br><span class="line">	// 使用它进行存储，确保能正常运行</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$0x123, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $0x123</span><br><span class="line">	JEQ 2(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line">	// 程序刚刚启动，此时位于主 OS 线程</span><br><span class="line">	// 设置 per-goroutine 和 per-mach 寄存器</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">	// 保存 m-&gt;g0 = g0</span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	// 保存 m0 to g0-&gt;m</span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				// 约定 D 总是被清除</span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">	MOVL	16(SP), AX		// 复制 argc</span><br><span class="line">	MOVL	AX, 0(SP)</span><br><span class="line">	MOVQ	24(SP), AX		// 复制 argv</span><br><span class="line">	MOVQ	AX, 8(SP)</span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	// 创建一个新的 goroutine 来启动程序</span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		// 入口</span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$0			// 参数大小</span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	// 启动这个 M</span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	CALL	runtime·abort(SB)	// mstart 应该永不返回</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	(...)</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>

<h1 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h1><blockquote>
<p>从上边汇编代码可以看出，整个过程按如下顺序执行：</p>
<ol>
<li>初始化系统运行时信息</li>
<li>初始化调度时全局变量 m0 g0及关联关系</li>
<li>runtime.check (实现在runtime1.go)对编译器工作进行校验，确保运行时类型正确</li>
<li>runtime.args (runtime1.go).处理程序参数</li>
<li>runtime.osinit (不同os在不同文件，os_darwin.go).获得CPU核心数</li>
<li>runtime.schedinit (proc.go). 初始化调度器</li>
<li>runtime.newproc (proc.go). 根据主goroutine入口地址创建G，并放至G队列中。</li>
<li>runtime.mstart (proc.go). 开始调度循环</li>
</ol>
</blockquote>
<h1 id="部分过程详细"><a href="#部分过程详细" class="headerlink" title="部分过程详细"></a>部分过程详细</h1><h2 id="runtime-schedinit-和-runtime-newproc"><a href="#runtime-schedinit-和-runtime-newproc" class="headerlink" title="runtime.schedinit 和 runtime.newproc"></a>runtime.schedinit 和 runtime.newproc</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	\_g_ := getg()</span><br><span class="line"></span><br><span class="line">	(...)</span><br><span class="line">	<span class="comment">// 最大系统线程数量（即 M），参考标准库 runtime/debug.SetMaxThreads</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	(...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模块数据验证</span></span><br><span class="line">	moduledataverify()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈、内存分配器、调度器相关初始化。</span></span><br><span class="line">	<span class="comment">// 栈初始化，复用管理链表</span></span><br><span class="line">	stackinit()</span><br><span class="line">	<span class="comment">// 内存分配器初始化</span></span><br><span class="line">	mallocinit()</span><br><span class="line">	<span class="comment">// 初始化当前 M</span></span><br><span class="line">	mcommoninit(_g_.m)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cpu 相关的初始化</span></span><br><span class="line">	cpuinit() <span class="comment">// 必须在 alginit 之前运行</span></span><br><span class="line">	alginit() <span class="comment">// maps 不能在此调用之前使用，从 CPU 指令集初始化哈希算法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模块加载相关的初始化</span></span><br><span class="line">	modulesinit()   <span class="comment">// 模块链接，提供 activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// 使用 maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// 初始化 interface table，使用 activeModules</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 信号屏蔽字初始化</span></span><br><span class="line">	msigsave(_g_.m)</span><br><span class="line">	initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理y命令行用户参数和环境变量</span></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理 GODEBUG、GOTRACEBACK 调试相关的环境变量设置</span></span><br><span class="line">	parsedebugvars()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 垃圾回收器初始化</span></span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 网络的上次轮询时间</span></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 CPU 核心数和 GOMAXPROCS 环境变量确定 P 的数量</span></span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整 P 的数量</span></span><br><span class="line">	<span class="comment">// 这时所有 P 均为新建的 P，因此不能返回有本地任务的 P</span></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不重要，调试相关</span></span><br><span class="line">	<span class="comment">// For cgocheck &gt; 1, we turn on the write barrier at all times</span></span><br><span class="line">	<span class="comment">// and check all pointer writes. We can't do this until after</span></span><br><span class="line">	<span class="comment">// procresize because the write barrier needs a P.</span></span><br><span class="line">	<span class="keyword">if</span> debug.cgocheck &gt; <span class="number">1</span> &#123;</span><br><span class="line">		writeBarrier.cgo = <span class="literal">true</span></span><br><span class="line">		writeBarrier.enabled = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			p.wbBuf.reset()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> buildVersion == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// 该条件永远不会被触发，此处只是为了防止 buildVersion 被编译器优化移除掉。</span></span><br><span class="line">		buildVersion = <span class="string">"unknown"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心组件初始化"><a href="#核心组件初始化" class="headerlink" title="核心组件初始化"></a>核心组件初始化</h3><h4 id="msigsave"><a href="#msigsave" class="headerlink" title="msigsave"></a>msigsave</h4><h4 id="stackinit"><a href="#stackinit" class="headerlink" title="stackinit"></a>stackinit</h4><p>goroutine栈结构</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// stack 描述了实际的栈内存：[stack.lo, stack.hi)</span></span><br><span class="line">	stack stack</span><br><span class="line">	<span class="comment">// stackguard0 是对比 Go 栈增长的 prologue 的栈指针</span></span><br><span class="line">	<span class="comment">// 如果 sp 寄存器比 stackguard0 小（由于栈往低地址方向增长），会触发栈拷贝和调度</span></span><br><span class="line">	<span class="comment">// 通常情况下：stackguard0 = stack.lo + StackGuard，但被抢占时会变为 StackPreempt</span></span><br><span class="line">	stackguard0 <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// stackguard1 是对比 C 栈增长的 prologue 的栈指针</span></span><br><span class="line">	<span class="comment">// 当位于 g0 和 gsignal 栈上时，值为 stack.lo + StackGuard</span></span><br><span class="line">	<span class="comment">// 在其他栈上值为 ~0 用于触发 morestackc (并 crash) 调用</span></span><br><span class="line">	stackguard1 <span class="keyword">uintptr</span></span><br><span class="line">	(...)</span><br><span class="line">	<span class="comment">// sched 描述了执行现场</span></span><br><span class="line">	sched       gobuf</span><br><span class="line">	(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>G的创建：(<code>proc.go</code>  <code>newproc()</code>)</p>
<blockquote>
<ol>
<li>首先检查go函数及其参数的合法性</li>
<li>尝试从本地P的自由G列表和调度器的自由G列表获取可用G(line3271:gfget(<code>_p_</code>))，如果未获取到，则新建G(line3273:malg(_StackMin))</li>
<li>初始化G，包括关联go函数及设置该G的状态和ID等</li>
<li>尝试将G放入本地P的runnext字段(line3348:runqput())：如果runnext为空，则直接放到runnext并返回；如果不为空，则替换，并将原runnext值放到本地P.runq末尾，如果满了将后一半的G移动至全局G队列</li>
</ol>
</blockquote>
<h4 id="mallocinit"><a href="#mallocinit" class="headerlink" title="mallocinit"></a>mallocinit</h4><p>内存分配器的初始化除去一些例行检查外，就是对堆的初始化了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 一些涉及内存分配器的常量的检查，包括</span></span><br><span class="line">	<span class="comment">// heapArenaBitmapBytes, physPageSize 等等</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化堆</span></span><br><span class="line">	mheap_.init()</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.mcache = allocmcache()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建初始的 arena 增长 hint</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; GOARCH != <span class="string">"wasm"</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">var</span> p <span class="keyword">uintptr</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">			(...)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">			hint.addr = p</span><br><span class="line">			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 32 位机器，不关心</span></span><br><span class="line">		(...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆的初始化：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化堆中各个组件的分配器</span></span><br><span class="line">	h.treapalloc.init(unsafe.Sizeof(treapNode&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">	h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">	h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不对 mspan 的分配清零，后台扫描可以通过分配它来并发的检查一个 span</span></span><br><span class="line">	<span class="comment">// 因此 span 的 sweepgen 在释放和重新分配时候能存活，从而可以防止后台扫描</span></span><br><span class="line">	<span class="comment">// 不正确的将其从 0 进行 CAS。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 因为 mspan 不包含堆指针，因此它是安全的</span></span><br><span class="line">	h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// h-&gt;mapcache 不需要初始化</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">		h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcommoninit"><a href="#mcommoninit" class="headerlink" title="mcommoninit"></a>mcommoninit</h4><p>M初始化</p>
<blockquote>
<p>M 创建时机：</p>
<ol>
<li>程序运行之初的 M0，无需创建已经存在的系统线程，只需对其进行初始化即可。<br>1.1 schedinit –&gt; mcommoninit –&gt; mpreinit –&gt; msigsave –&gt; initSigmask –&gt; mstart</li>
<li>需要时创建的 M，某些特殊情况下一定会创建一个新的 M并进行初始化，而后创建系统线程：<br>2.1 startm 时没有空闲 m<br>2.2 startTemplateThread 时<br>2.3 startTheWorldWithSema 时 p 如果没有 m<br>2.4 main 时创建系统监控<br>2.5 oneNewExtraM 时<br>2.6 初始化过程： newm –&gt; allocm –&gt; mcommoninit –&gt; mpreinit –&gt; newm1 –&gt; newosproc –&gt; mstart</li>
</ol>
</blockquote>
<p>P初始化</p>
<blockquote>
</blockquote>
<p>G初始化</p>
<blockquote>
<p>创建 G 的过程也是相对比较复杂的，我们来总结一下这个过程：<br>首先尝试从 P 本地 gfree 链表或全局 gfree 队列获取已经执行过的、已经执行过的 g 初始化过程中程序无论是本地队列还是全局队列都不可能获取到 g，因此创建一个新的 g，并为其分配运行线程（执行栈）。<br>这时 g 处于 _Gidle 状态创建完成后，g 被更改为 _Gdead 状态，并根据要执行函数的入口地址和参数，初始化执行栈的 SP 和参数的入栈位置，并将需要的参数拷贝一份存入执行栈中根据 SP、参数，在 g.sched 中保存 SP 和 PC 指针来初始化 g 的运行现场将调用方、要执行的函数的入口 PC 进行保存，并将 g 的状态更改为 _Grunnable给 goroutine 分配 id，并将其放入 P 本地队列的队头或全局队列（初始化阶段队列肯定不是满的，因此不可能放入全局队列）检查空闲的 P，将其唤醒，准备执行 G，但我们目前处于初始化阶段，主 goroutine 尚未开始执行，因此这里不会唤醒 P。</p>
</blockquote>
<h4 id="gcinit"><a href="#gcinit" class="headerlink" title="gcinit"></a>gcinit</h4><h4 id="procresize"><a href="#procresize" class="headerlink" title="procresize"></a>procresize</h4><blockquote>
<ol>
<li>调用时已经 STW；</li>
<li>记录调整 P 的时间；</li>
<li>按需调整 allp 的大小；</li>
<li>按需初始化 allp 中的 P；</li>
<li>从 allp 移除不需要的 P，将释放的 P 队列中的任务扔进全局队列；</li>
<li>如果当前的 P 还可以继续使用（没有被移除），则将 P 设置为 _Prunning；</li>
<li>否则将第一个 P 抢过来给当前 G 的 M 进行绑定</li>
<li>最后挨个检查 P，将没有任务的 P 放入 idle 队列</li>
<li>出去当前 P 之外，将有任务的 P 彼此串联成链表，将没有任务的 P 放回到 idle 链表中</li>
</ol>
</blockquote>
<h2 id="runtime-mstart"><a href="#runtime-mstart" class="headerlink" title="runtime.mstart"></a>runtime.mstart</h2>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine实例与分析</title>
    <url>/blog/2019/06/25/20190625000000.html</url>
    <content><![CDATA[<h2 id="实例1：多个goroutine在单个P上运行时调度队列分析"><a href="#实例1：多个goroutine在单个P上运行时调度队列分析" class="headerlink" title="实例1：多个goroutine在单个P上运行时调度队列分析"></a>实例1：多个goroutine在单个P上运行时调度队列分析</h2><p>示例代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(num)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处打印结果应该是不定的，大多数是 9012345678。</p>
<p>原因：在创建协程时，当前协程会先把它放到本地P的runnext中去，该字段用于存放新创建的G，以求更早地运行它，如果此时runnext字段已有一个G，那么这个已有的G就会被踢到P的可运行G队列末尾。此处协程里逻辑比较简单，运行速度很快，所以大多数情况都会按 9 0-8这样顺序调度，如果协程里逻辑比较复杂、CPU执行效率低下或调度器执行了调度了其他任务，结果就可能与这里有出入。</p>
<p>更改num的值，在num值改为小于等于257，都按上述流程工作，因为P本地G队列长度为256，再加上runnext，P本地就可以持有257个G，当大于257个G创建时，它们会被放到全局G队列中去（如果p.runq满，其中一半的G会被转移到调度器的可运行G队列中）</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine总结</title>
    <url>/blog/2019/06/24/20190624000000.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]go调度器源码分析</title>
    <url>/blog/2019/06/23/20190623220012.html</url>
    <content><![CDATA[<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>goroutine 在 runtime 中的数据结构:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]</span></span><br><span class="line"><span class="comment">// 如果从传统内存布局的角度来讲，Go 的栈实际上是分配在 C 语言中的堆区的</span></span><br><span class="line"><span class="comment">// 所以才能比 ulimit -s 的 stack size 还要大(1GB)</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="keyword">uintptr</span></span><br><span class="line">    hi <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 的运行现场</span></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="keyword">uintptr</span>    <span class="comment">// sp 寄存器</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span>    <span class="comment">// pc 寄存器</span></span><br><span class="line">    g    guintptr   <span class="comment">// g 指针</span></span><br><span class="line">    ctxt unsafe.Pointer <span class="comment">// 这个似乎是用来辅助 gc 的</span></span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    lr   <span class="keyword">uintptr</span>    <span class="comment">// 这是在 arm 上用的寄存器，不用关心</span></span><br><span class="line">    bp   <span class="keyword">uintptr</span>    <span class="comment">// 开启 GOEXPERIMENT=framepointer，才会有这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 简单数据结构，lo 和 hi 成员描述了栈的下界和上界内存地址</span></span><br><span class="line">    stack       stack</span><br><span class="line">    <span class="comment">// 在函数的栈增长 prologue 中用 sp 寄存器和 stackguard0 来做比较</span></span><br><span class="line">    <span class="comment">// 如果 sp 比 stackguard0 小(因为栈向低地址方向增长)，那么就触发栈拷贝和调度</span></span><br><span class="line">    <span class="comment">// 正常情况下 stackguard0 = stack.lo + StackGuard</span></span><br><span class="line">    <span class="comment">// 不过 stackguard0 在需要进行调度时，会被修改为 StackPreempt</span></span><br><span class="line">    <span class="comment">// 以触发抢占s</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// stackguard1 是在 C 栈增长 prologue 作对比的对象</span></span><br><span class="line">    <span class="comment">// 在 g0 和 gsignal 栈上，其值为 stack.lo+StackGuard</span></span><br><span class="line">    <span class="comment">// 在其它的栈上这个值是 ~0(按 0 取反)以触发 morestack 调用(并 crash)</span></span><br><span class="line">    stackguard1 <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    _panic         *_panic</span><br><span class="line">    _defer         *_defer</span><br><span class="line">    m              *m             <span class="comment">// 当前与 g 绑定的 m</span></span><br><span class="line">    sched          gobuf          <span class="comment">// goroutine 的现场</span></span><br><span class="line">    syscallsp      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp       <span class="keyword">uintptr</span>        <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    param          unsafe.Pointer <span class="comment">// wakeup 时的传入参数</span></span><br><span class="line">    atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">    stackLock      <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid           <span class="keyword">int64</span>  <span class="comment">// goroutine id</span></span><br><span class="line">    waitsince      <span class="keyword">int64</span>  <span class="comment">// g 被阻塞之后的近似时间</span></span><br><span class="line">    waitreason     <span class="keyword">string</span> <span class="comment">// if status==Gwaiting</span></span><br><span class="line">    schedlink      guintptr</span><br><span class="line">    preempt        <span class="keyword">bool</span>     <span class="comment">// 抢占标记，这个为 true 时，stackguard0 是等于 stackpreempt 的</span></span><br><span class="line">    throwsplit     <span class="keyword">bool</span>     <span class="comment">// must not split stack</span></span><br><span class="line">    raceignore     <span class="keyword">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">    sysblocktraced <span class="keyword">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">    sysexitticks   <span class="keyword">int64</span>    <span class="comment">// syscall 返回之后的 cputicks，用来做 tracing</span></span><br><span class="line">    traceseq       <span class="keyword">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">    tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">    lockedm        muintptr <span class="comment">// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上</span></span><br><span class="line">    sig            <span class="keyword">uint32</span></span><br><span class="line">    writebuf       []<span class="keyword">byte</span></span><br><span class="line">    sigcode0       <span class="keyword">uintptr</span></span><br><span class="line">    sigcode1       <span class="keyword">uintptr</span></span><br><span class="line">    sigpc          <span class="keyword">uintptr</span></span><br><span class="line">    gopc           <span class="keyword">uintptr</span> <span class="comment">// 创建该 goroutine 的语句的指令地址</span></span><br><span class="line">    startpc        <span class="keyword">uintptr</span> <span class="comment">// goroutine 函数的指令地址</span></span><br><span class="line">    racectx        <span class="keyword">uintptr</span></span><br><span class="line">    waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">    cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">    labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">    timer          *timer         <span class="comment">// time.Sleep 缓存的定时器</span></span><br><span class="line">    selectDone     <span class="keyword">uint32</span>         <span class="comment">// 该 g 是否正在参与 select，是否已经有人从 select 中胜出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 g 遇到阻塞，或需要等待的场景时，会被打包成 sudog 这样一个结构。一个 g 可能被打包为多个 sudog 分别挂在不同的等待队列上:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 代表在等待列表里的 g，比如向 channel 发送/接收内容时</span></span><br><span class="line"><span class="comment">// 之所以需要 sudog 是因为 g 和同步对象之间的关系是多对多的</span></span><br><span class="line"><span class="comment">// 一个 g 可能会在多个等待队列中，所以一个 g 可能被打包为多个 sudog</span></span><br><span class="line"><span class="comment">// 多个 g 也可以等待在同一个同步对象上</span></span><br><span class="line"><span class="comment">// 因此对于一个同步对象就会有很多 sudog 了</span></span><br><span class="line"><span class="comment">// sudog 是从一个特殊的池中进行分配的。用 acquireSudog 和 releaseSudog 来分配和释放 sudog</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的这些字段都是被该 g 所挂在的 channel 中的 hchan.lock 来保护的</span></span><br><span class="line">    <span class="comment">// shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isSelect 表示一个 g 是否正在参与 select 操作</span></span><br><span class="line">    <span class="comment">// 所以 g.selectDone 必须用 CAS 来操作，以胜出唤醒的竞争</span></span><br><span class="line">    isSelect <span class="keyword">bool</span></span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些字段则永远都不会被并发访问</span></span><br><span class="line">    <span class="comment">// 对于 channel 来说，waitlink 只会被 g 访问</span></span><br><span class="line">    <span class="comment">// 对于信号量来说，所有的字段，包括上面的那些字段都只在持有 semaRoot 锁时才可以访问</span></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span></span><br><span class="line">    parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在 runtime 中的结构，对应一个 pthread，pthread 也会对应唯一的内核线程(task_struct):</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// 用来执行调度指令的 goroutine</span></span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">    procid        <span class="keyword">uint64</span>       <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    gsignal       *g           <span class="comment">// signal-handling g</span></span><br><span class="line">    goSigStack    gsignalStack <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">    sigmask       sigset       <span class="comment">// storage for saved signal mask</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    curg          *g       <span class="comment">// 当前运行的用户 goroutine</span></span><br><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    id            <span class="keyword">int64</span></span><br><span class="line">    mallocing     <span class="keyword">int32</span></span><br><span class="line">    throwing      <span class="keyword">int32</span></span><br><span class="line">    preemptoff    <span class="keyword">string</span> <span class="comment">// 该字段不等于空字符串的话，要保持 curg 始终在这个 m 上运行</span></span><br><span class="line">    locks         <span class="keyword">int32</span></span><br><span class="line">    softfloat     <span class="keyword">int32</span></span><br><span class="line">    dying         <span class="keyword">int32</span></span><br><span class="line">    profilehz     <span class="keyword">int32</span></span><br><span class="line">    helpgc        <span class="keyword">int32</span></span><br><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// m 失业了，正在积极寻找工作~</span></span><br><span class="line">    blocked       <span class="keyword">bool</span> <span class="comment">// m 正阻塞在 note 上</span></span><br><span class="line">    inwb          <span class="keyword">bool</span> <span class="comment">// m 正在执行 write barrier</span></span><br><span class="line">    newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">    printlock     <span class="keyword">int8</span></span><br><span class="line">    incgo         <span class="keyword">bool</span>   <span class="comment">// m 正在执行 cgo call</span></span><br><span class="line">    freeWait      <span class="keyword">uint32</span> <span class="comment">// if == 0, safe to free g0 and delete m (atomic)</span></span><br><span class="line">    fastrand      [<span class="number">2</span>]<span class="keyword">uint32</span></span><br><span class="line">    needextram    <span class="keyword">bool</span></span><br><span class="line">    traceback     <span class="keyword">uint8</span></span><br><span class="line">    ncgocall      <span class="keyword">uint64</span>      <span class="comment">// cgo 调用总计数</span></span><br><span class="line">    ncgo          <span class="keyword">int32</span>       <span class="comment">// 当前正在执行的 cgo 订单计数</span></span><br><span class="line">    cgoCallersUse <span class="keyword">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">    cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line">    park          note</span><br><span class="line">    alllink       *m <span class="comment">// on allm</span></span><br><span class="line">    schedlink     muintptr</span><br><span class="line">    mcache        *mcache</span><br><span class="line">    lockedg       guintptr</span><br><span class="line">    createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span>    <span class="comment">// stack that created this thread.</span></span><br><span class="line">    freglo        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] lsb and f[i]</span></span><br><span class="line">    freghi        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] msb and f[i+16]</span></span><br><span class="line">    fflag         <span class="keyword">uint32</span>         <span class="comment">// floating point compare flags</span></span><br><span class="line">    lockedExt     <span class="keyword">uint32</span>         <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">    lockedInt     <span class="keyword">uint32</span>         <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">    nextwaitm     muintptr       <span class="comment">// 正在等待锁的下一个 m</span></span><br><span class="line">    waitunlockf   unsafe.Pointer <span class="comment">// todo go func(*g, unsafe.pointer) bool</span></span><br><span class="line">    waitlock      unsafe.Pointer</span><br><span class="line">    waittraceev   <span class="keyword">byte</span></span><br><span class="line">    waittraceskip <span class="keyword">int</span></span><br><span class="line">    startingtrace <span class="keyword">bool</span></span><br><span class="line">    syscalltick   <span class="keyword">uint32</span></span><br><span class="line">    thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line">    freelink      *m      <span class="comment">// on sched.freem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are here because they are too large to be on the stack</span></span><br><span class="line">    <span class="comment">// of low-level NOSPLIT functions.</span></span><br><span class="line">    libcall   libcall</span><br><span class="line">    libcallpc <span class="keyword">uintptr</span> <span class="comment">// for cpu profiler</span></span><br><span class="line">    libcallsp <span class="keyword">uintptr</span></span><br><span class="line">    libcallg  guintptr</span><br><span class="line">    syscall   libcall <span class="comment">// 存储 windows 平台的 syscall 参数</span></span><br><span class="line"></span><br><span class="line">    mOS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象数据结构，可以认为是 processor 的抽象，代表了任务执行时的上下文，m 必须获得 p 才能执行:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// 每次调用 schedule 时会加一</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// 每次系统调用时加一</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// 上次 sysmon 观察到的 tick 时间</span></span><br><span class="line">    m           muintptr   <span class="comment">// 和相关联的 m 的反向指针，如果 p 是 idle 的话，那这个指针是 nil</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">    racectx     <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runnable 状态的 goroutine。访问时是不加锁的</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// runnext 非空时，代表的是一个 runnable 状态的 G，</span></span><br><span class="line">    <span class="comment">// 这个 G 是被 当前 G 修改为 ready 状态的，</span></span><br><span class="line">    <span class="comment">// 并且相比在 runq 中的 G 有更高的优先级</span></span><br><span class="line">    <span class="comment">// 如果当前 G 的还有剩余的可用时间，那么就应该运行这个 G</span></span><br><span class="line">    <span class="comment">// 运行之后，该 G 会继承当前 G 的剩余时间</span></span><br><span class="line">    <span class="comment">// If a set of goroutines is locked in a</span></span><br><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    gfree    *g</span><br><span class="line">    gfreecnt <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">    <span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">    <span class="comment">// has actually been swept.</span></span><br><span class="line">    traceSweep <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">    <span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">    traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-P GC state</span></span><br><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker</span></span><br><span class="line">    gcBgMarkWorker       guintptr</span><br><span class="line">    gcMarkWorkerMode     gcMarkWorkerMode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前标记 worker 的开始时间，单位纳秒</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">    wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">    pad [sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局调度器，全局只有一个 schedt 类型的实例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 下面两个变量需以原子访问访问。保持在 struct 顶部，以使其在 32 位系统上可以对齐</span></span><br><span class="line">    goidgen  <span class="keyword">uint64</span></span><br><span class="line">    lastpoll <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当修改 nmidle，nmidlelocked，nmsys，nmfreed 这些数值时</span></span><br><span class="line">    <span class="comment">// 需要记得调用 checkdead</span></span><br><span class="line"></span><br><span class="line">    midle        muintptr <span class="comment">// idle m's waiting for work</span></span><br><span class="line">    nmidle       <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的空闲 m 计数</span></span><br><span class="line">    nmidlelocked <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的被 lock 的 m 计数</span></span><br><span class="line">    mnext        <span class="keyword">int64</span>    <span class="comment">// 当前预缴创建的 m 数，并且该值会作为下一个创建的 m 的 ID</span></span><br><span class="line">    maxmcount    <span class="keyword">int32</span>    <span class="comment">// 允许创建的最大的 m 数量</span></span><br><span class="line">    nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">    nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">    ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">    pidle      puintptr <span class="comment">// 空闲 p's</span></span><br><span class="line">    npidle     <span class="keyword">uint32</span></span><br><span class="line">    nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局的可运行 g 队列</span></span><br><span class="line">    runqhead guintptr</span><br><span class="line">    runqtail guintptr</span><br><span class="line">    runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dead G 的全局缓存</span></span><br><span class="line">    gflock       mutex</span><br><span class="line">    gfreeStack   *g</span><br><span class="line">    gfreeNoStack *g</span><br><span class="line">    ngfree       <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sudog 结构的集中缓存</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同大小的可用的 defer struct 的集中缓存池</span></span><br><span class="line">    deferlock mutex</span><br><span class="line">    deferpool [<span class="number">5</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被设置了 m.exited 标记之后的 m，这些 m 正在 freem 这个链表上等待被 free</span></span><br><span class="line">    <span class="comment">// 链表用 m.freelink 字段进行链接</span></span><br><span class="line">    freem *m</span><br><span class="line"></span><br><span class="line">    gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run</span></span><br><span class="line">    stopwait   <span class="keyword">int32</span></span><br><span class="line">    stopnote   note</span><br><span class="line">    sysmonwait <span class="keyword">uint32</span></span><br><span class="line">    sysmonnote note</span><br><span class="line"></span><br><span class="line">    <span class="comment">// safepointFn should be called on each P at the next GC</span></span><br><span class="line">    <span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line">    safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span><br><span class="line">    safePointWait <span class="keyword">int32</span></span><br><span class="line">    safePointNote note</span><br><span class="line"></span><br><span class="line">    profilehz <span class="keyword">int32</span> <span class="comment">// cpu profiling rate</span></span><br><span class="line"></span><br><span class="line">    procresizetime <span class="keyword">int64</span> <span class="comment">// 上次修改 gomaxprocs 的纳秒时间</span></span><br><span class="line">    totaltime      <span class="keyword">int64</span> <span class="comment">// ∫gomaxprocs dt up to procresizetime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="g-p-m-的关系"><a href="#g-p-m-的关系" class="headerlink" title="g/p/m 的关系"></a>g/p/m 的关系</h2><p>Go 实现了所谓的 M:N 模型，执行用户代码的 goroutine 可以认为都是对等的 goroutine。不考虑 g0 和 gsignal 的话，我们可以简单地认为调度就是将 m 绑定到 p，然后在 m 中不断循环执行调度函数(runtime.schedule)，寻找可用的 g 来执行，下图为 m 绑定到 p 时，可能得到的 g 的来源:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                  +---------+</span><br><span class="line">                                  | binded  +-------------+</span><br><span class="line">                                  +----+----+             |</span><br><span class="line">+------------------------------+       |                  v                 +-----------------------------+</span><br><span class="line">|                              |       |       +-------------------------+  |                             |</span><br><span class="line">|         +------------------+ |       |       |                         |  |        +------------------+ |</span><br><span class="line">|         | Local Run Queue  | |       |       |    +------------------+ |  |        | Global Run Queue | |</span><br><span class="line">| other P +-+-+-+-+-+-+-+-+--+ |       |       | P  | Local Run Queue  | |  | schedt +--+-+-+-+-+-+-+---+ |</span><br><span class="line">|           |G|G|G|G|G|G|G|    |       |       |    +-+-+-+-+-+-+-+-+--+ |  |           |G|G|G|G|G|G|     |</span><br><span class="line">|           +-+-+-+-+-+-+-+    |       |       |      |G|G|G|G|G|G|G|    |  |           +-+-+-+-+-+-+     |</span><br><span class="line">|            ^                 |       |       |      +-+-+-+-+-+-+-+    |  |            ^                |</span><br><span class="line">+------------+-----------------+       |       |       ^                 |  +------------+----------------+</span><br><span class="line">             |                         |       +-------+-----------------+               |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         |                              |                  |</span><br><span class="line">             |                         v                              |                  |</span><br><span class="line">      +------+-------+                .-.      +----------------+     |                  |</span><br><span class="line">      |    steal     +---------------( M )-----+    runqget     +-----+                  |</span><br><span class="line">      +--------------+                `-&apos;      +----------------+                        |</span><br><span class="line">                                       |                                                 |</span><br><span class="line">                                       |                                         +-------+---------+</span><br><span class="line">                                       +-----------------------------------------+   globrunqget   |</span><br><span class="line">                                       |                                         +-----------------+</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                            +----------+--------+</span><br><span class="line">                            |   get netpoll g   |</span><br><span class="line">                            +----------+--------+</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                                       |</span><br><span class="line">                        +--------------+--------------+</span><br><span class="line">                        |              |              |</span><br><span class="line">                        |   netpoll    v              |</span><br><span class="line">                        |             +-+-+-+-+       |</span><br><span class="line">                        |             |G|G|G|G|       |</span><br><span class="line">                        |             +-+-+-+-+       |</span><br><span class="line">                        +-----------------------------+</span><br></pre></td></tr></table></figure>


<p>这张图展示了 g、p、m 三者之间的大致关系。m 是执行实体，对应的是操作系统线程。可以看到 m 会从绑定的 p 的本地队列、sched 中的全局队列、netpoll 中获取可运行的 g，实在找不着还会去其它的 p 那里去偷。</p>
<h2 id="p-如何初始化"><a href="#p-如何初始化" class="headerlink" title="p 如何初始化"></a>p 如何初始化</h2><p>程序启动时，会依次调用：</p>
<pre class="mermaid">graph TD
runtime.schedinit -->  runtime.procresize</pre>

<p>在 procresize 中会将全局 p 数组初始化，并将这些 p 串成链表放进 sched 全局调度器的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    p := allp[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置 p 的状态</span></span><br><span class="line">    p.status = _Pidle</span><br><span class="line">    <span class="comment">// 初始化时，所有 p 的 runq 都是空的，所以一定会走这个 if</span></span><br><span class="line">    <span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line">        <span class="comment">// 将 p 放到全局调度器的 pidle 队列中</span></span><br><span class="line">        pidleput(p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pidleput 也比较简单，没啥可说的:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">        throw(<span class="string">"pidleput: P has non-empty run queue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简单的链表操作</span></span><br><span class="line">    _p_.link = sched.pidle</span><br><span class="line">    sched.pidle.set(_p_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pidle count + 1</span></span><br><span class="line">    atomic.Xadd(&amp;sched.npidle, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 p 在程序启动的时候就已经被初始化完毕了，除非手动调用 runtime.GOMAXPROCS。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    ret := <span class="keyword">int</span>(gomaxprocs)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> || n == ret &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopTheWorld(<span class="string">"GOMAXPROCS"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newprocs will be processed by startTheWorld</span></span><br><span class="line">    newprocs = <span class="keyword">int32</span>(n)</span><br><span class="line"></span><br><span class="line">    startTheWorld()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startTheWorld 中会调用 procresize。</p>
<h2 id="g-如何创建"><a href="#g-如何创建" class="headerlink" title="g 如何创建"></a>g 如何创建</h2><p>在用户代码里一般这么写:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// do the stuff</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>实际上会被翻译成 <code>runtime.newproc</code>，特权语法只是个语法糖。如果你要在其它语言里实现类似的东西，只要实现编译器翻译之后的内容就好了。具体流程:</p>
<pre class="mermaid">graph TD
runtime.newproc --> runtime.newproc1</pre>

<p>newproc 干的事情也比较简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// add 是一个指针运算，跳过函数指针</span></span><br><span class="line">    <span class="comment">// 把栈上的参数起始地址找到</span></span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, pc)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// funcval 是一个变长结构，第一个成员是函数指针</span></span><br><span class="line"><span class="comment">// 所以上面的 add 是跳过这个 fn</span></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">    fn <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 里比较常见的 getcallerpc 和 getcallersp，代码里的注释写的比较明白了:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func f(arg1, arg2, arg3 int) &#123;</span></span><br><span class="line"><span class="comment">//    pc := getcallerpc()</span></span><br><span class="line"><span class="comment">//    sp := getcallersp(unsafe.Pointer(&amp;arg1))</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// These two lines find the PC and SP immediately following</span></span><br><span class="line"><span class="comment">// the call to f (where f will return).</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>getcallerpc 返回的是调用函数之后的那条程序指令的地址，即 callee 函数返回时要执行的下一条指令的地址。</p>
<p>systemstack 在 runtime 中用的也比较多，其功能为让 m 切换到 g0 上执行各种调度函数。至于啥是 g0，在讲 m 的时候再说。</p>
<p>newproc1 的工作流程也比较简单:</p>
<pre class="mermaid">graph TD
newproc1 --> newg
newg[gfget] --> nil{is nil?}
nil -->|yes|E[init stack]
nil -->|no|C[malg]
C --> D[set g status=> idle->dead]
D --> allgadd
E --> G[set g status=> dead-> runnable]
allgadd --> G
G --> runqput</pre>

<p>删掉了不关心的细节后的代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        _g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">        throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">    siz := narg</span><br><span class="line">    siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    newg := gfget(_p_)</span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        newg = malg(_StackMin)</span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">    totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line">    spArg := sp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 g，g 的 gobuf 现场，g 的 m 的 curg</span></span><br><span class="line">    <span class="comment">// 以及各种寄存器</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    newg.sched.sp = sp</span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line">    <span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">        newg.labels = _g_.m.curg.labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">    newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">    _p_.goidcache++</span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">        _g_.stackguard0 = stackPreempt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>go func</code> 执行的结果是调用 runqput 将 g 放进了执行队列。但在放队列之前还做了点小动作:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br></pre></td></tr></table></figure>

<h3 id="gostartcallfn"><a href="#gostartcallfn" class="headerlink" title="gostartcallfn"></a>gostartcallfn</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn = unsafe.Pointer(fv.fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">    &#125;</span><br><span class="line">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    sp := buf.sp</span><br><span class="line">    <span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">        sp -= sys.PtrSize</span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sp -= sys.PtrSize</span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc <span class="comment">// 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span></span><br><span class="line">    buf.sp = sp</span><br><span class="line">    buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">    buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>
<p>在之后的 m 的 schedule 讲解中会看到更详细的调度循环过程。</p>
<h3 id="runqput"><a href="#runqput" class="headerlink" title="runqput"></a>runqput</h3><p>因为是放 runq 而不是直接执行，因而什么时候开始执行并不是用户代码能决定得了的。再看看 runqput 这个函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runqput 尝试把 g 放到本地执行队列中</span></span><br><span class="line"><span class="comment">// next 参数如果是 false 的话，runqput 会将 g 放到运行队列的尾部</span></span><br><span class="line"><span class="comment">// If next if false, runqput adds g to the tail of the runnable queue.</span></span><br><span class="line"><span class="comment">// If next is true, runqput puts g in the _p_.runnext slot.</span></span><br><span class="line"><span class="comment">// If the run queue is full, runnext puts g on the global queue.</span></span><br><span class="line"><span class="comment">// Executed only by the owner P.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(_p_ *p, gp *g, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> next &#123;</span><br><span class="line">    retryNext:</span><br><span class="line">        oldnext := _p_.runnext</span><br><span class="line">        <span class="keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> retryNext</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把之前的 runnext 踢到正常的 runq 中</span></span><br><span class="line">        gp = oldnext.ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">    t := _p_.runqtail</span><br><span class="line">    <span class="keyword">if</span> t-h &lt; <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">        _p_.runq[t%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span><br><span class="line">        atomic.Store(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列没有满的话，上面的 put 操作会成功</span></span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runqputslow"><a href="#runqputslow" class="headerlink" title="runqputslow"></a>runqputslow</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 slow，所以会一次性把本地队列里的多个 g (包含当前的这个) 放到全局队列</span></span><br><span class="line"><span class="comment">// 只会被 g 的 owner P 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(_p_ *p, gp *g, h, t <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch [<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从本地队列抓一批 g</span></span><br><span class="line">    n := t - h</span><br><span class="line">    n = n / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">        throw(<span class="string">"runqputslow: queue is not full"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i] = _p_.runq[(h+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;_p_.runqhead, h, h+n) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    batch[n] = gp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">1</span>); i &lt;= n; i++ &#123;</span><br><span class="line">            j := fastrandn(i + <span class="number">1</span>)</span><br><span class="line">            batch[i], batch[j] = batch[j], batch[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这些 goroutine 构造成链表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表放到全局队列中</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqputbatch(batch[<span class="number">0</span>], batch[n], <span class="keyword">int32</span>(n+<span class="number">1</span>))</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作全局 sched 时，需要获取全局 sched.lock 锁，全局锁争抢的开销较大，所以才称之为 slow。p 和 g 在 m 中交互时，因为现场永远是单线程，所以很多时候不用加锁。</p>
<h2 id="m-工作机制"><a href="#m-工作机制" class="headerlink" title="m 工作机制"></a>m 工作机制</h2><p>在 runtime 中有三种线程，一种是主线程，一种是用来跑 sysmon 的线程，一种是普通的用户线程。主线程在 runtime 由对应的全局变量: <code>runtime.m0</code> 来表示。用户线程就是普通的线程了，和 p 绑定，执行 g 中的任务。虽然说是有三种，实际上前两种线程整个 runtime 就只有一个实例。用户线程才会有很多实例。</p>
<h3 id="主线程-m0"><a href="#主线程-m0" class="headerlink" title="主线程 m0"></a>主线程 m0</h3><p>主线程中用来跑 <code>runtime.main</code>，流程线性执行，没有跳转:</p>
<pre class="mermaid">graph TD
runtime.main --> A[init max stack size]
A --> B[systemstack execute -> newm -> sysmon]
B --> runtime.lockOsThread
runtime.lockOsThread --> runtime.init
runtime.init --> runtime.gcenable
runtime.gcenable --> main.init
main.init --> main.main</pre>

<h3 id="sysmon-线程"><a href="#sysmon-线程" class="headerlink" title="sysmon 线程"></a>sysmon 线程</h3><p>sysmon 是在 <code>runtime.main</code> 中启动的，不过需要注意的是 sysmon 并不是在 m0 上执行的。因为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建了新的 m，但这个 m 又与普通的线程不一样，因为不需要绑定 p 就可以执行。是与整个调度系统脱离的。</p>
<p>sysmon 内部是个死循环，主要负责以下几件事情:</p>
<ol>
<li><p>checkdead，检查是否所有 goroutine 都已经锁死，如果是的话，直接调用 runtime.throw，强制退出。这个操作只在启动的时候做一次</p>
</li>
<li><p>将 netpoll 返回的结果注入到全局 sched 的任务队列</p>
</li>
<li><p>收回因为 syscall 而长时间阻塞的 p，同时抢占那些执行时间过长的 g</p>
</li>
<li><p>如果 span 内存闲置超过 5min，那么释放掉</p>
</li>
</ol>
<p>流程图:</p>
<pre class="mermaid">graph TD
sysmon --> usleep
usleep --> checkdead
checkdead --> |every 10ms|C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> injectglist
injectglist --> retake
C --> |no|retake
retake --> A[check forcegc needed]
A --> B[scavenge heap once in a while]
B --> usleep</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sysmon 不需要绑定 P 就可以运行，所以不允许 write barriers</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.nmsys++</span><br><span class="line">    checkdead()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个 heap span 在一次GC 之后 5min 都没有被使用过</span></span><br><span class="line">    <span class="comment">// 那么把它交还给操作系统</span></span><br><span class="line">    scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Scavenge-a-lot for testing.</span></span><br><span class="line">        forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span><br><span class="line">        scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastscavenge := nanotime()</span><br><span class="line">    nscavenge := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">    idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">    delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// 初始化时 20us sleep</span></span><br><span class="line">            delay = <span class="number">20</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">            delay *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// 最多到 10ms</span></span><br><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(delay)</span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="comment">// Make wake-up period small enough</span></span><br><span class="line">                <span class="comment">// for the sampling to be correct.</span></span><br><span class="line">                maxsleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> scavengelimit &lt; forcegcperiod &#123;</span><br><span class="line">                    maxsleep = scavengelimit / <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                shouldRelax := <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> osRelaxMinNS &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    next := timeSleepUntil()</span><br><span class="line">                    now := nanotime()</span><br><span class="line">                    <span class="keyword">if</span> next-now &lt; osRelaxMinNS &#123;</span><br><span class="line">                        shouldRelax = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                    osRelax(<span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                notetsleep(&amp;sched.sysmonnote, maxsleep)</span><br><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                    osRelax(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                lock(&amp;sched.lock)</span><br><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">                noteclear(&amp;sched.sysmonnote)</span><br><span class="line">                idle = <span class="number">0</span></span><br><span class="line">                delay = <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 10ms 没有 poll 过 network，那么就 netpoll 一次</span></span><br><span class="line">        lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">            atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">            gp := netpoll(<span class="literal">false</span>) <span class="comment">// 非阻塞 -- 返回一个 goroutine 的列表</span></span><br><span class="line">            <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line">                <span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">                <span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">                <span class="comment">// injectglist grabs all P's but before it starts M's to run the P's,</span></span><br><span class="line">                <span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">                <span class="comment">// observes that there is no work to do and no other running M's</span></span><br><span class="line">                <span class="comment">// and reports deadlock.</span></span><br><span class="line">                incidlelocked(<span class="number">-1</span>)</span><br><span class="line">                injectglist(gp)</span><br><span class="line">                incidlelocked(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收在 syscall 状态阻塞的 P</span></span><br><span class="line">        <span class="comment">// 抢占长时间运行的 G</span></span><br><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">            idle = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            idle++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否需要 force GC(两分钟一次的)</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            forcegc.idle = <span class="number">0</span></span><br><span class="line">            forcegc.g.schedlink = <span class="number">0</span></span><br><span class="line">            injectglist(forcegc.g)</span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每过一段时间扫描一次堆</span></span><br><span class="line">        <span class="keyword">if</span> lastscavenge+scavengelimit/<span class="number">2</span> &lt; now &#123;</span><br><span class="line">            mheap_.scavenge(<span class="keyword">int32</span>(nscavenge), <span class="keyword">uint64</span>(now), <span class="keyword">uint64</span>(scavengelimit))</span><br><span class="line">            lastscavenge = now</span><br><span class="line">            nscavenge++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">            lasttrace = now</span><br><span class="line">            schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkdead"><a href="#checkdead" class="headerlink" title="checkdead"></a>checkdead</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查死锁的场景</span></span><br><span class="line"><span class="comment">// 该检查基于当前正在运行的 M 的数量，如果 0，那么就是 deadlock 了</span></span><br><span class="line"><span class="comment">// 检查的时候必须持有 sched.lock 锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对于 -buildmode=c-shared 或者 -buildmode=c-archive 来说</span></span><br><span class="line">    <span class="comment">// 没有 goroutine 正在运行也是 OK 的。因为调用这个库的程序应该是在运行的</span></span><br><span class="line">    <span class="keyword">if</span> islibrary || isarchive &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are dying because of a signal caught on an already idle thread,</span></span><br><span class="line">    <span class="comment">// freezetheworld will cause all running threads to block.</span></span><br><span class="line">    <span class="comment">// And runtime will essentially enter into deadlock state,</span></span><br><span class="line">    <span class="comment">// except that there is a thread that will call exit soon.</span></span><br><span class="line">    <span class="keyword">if</span> panicking &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</span><br><span class="line">    <span class="keyword">if</span> run &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> run &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: checkdead: nmidle="</span>, sched.nmidle, <span class="string">" nmidlelocked="</span>, sched.nmidlelocked, <span class="string">" mcount="</span>, mcount(), <span class="string">" nmsys="</span>, sched.nmsys, <span class="string">"\n"</span>)</span><br><span class="line">        throw(<span class="string">"checkdead: inconsistent counts"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grunning := <span class="number">0</span></span><br><span class="line">    lock(&amp;allglock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allgs); i++ &#123;</span><br><span class="line">        gp := allgs[i]</span><br><span class="line">        <span class="keyword">if</span> isSystemGoroutine(gp) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        s := readgstatus(gp)</span><br><span class="line">        <span class="keyword">switch</span> s &amp;^ _Gscan &#123;</span><br><span class="line">        <span class="keyword">case</span> _Gwaiting:</span><br><span class="line">            grunning++</span><br><span class="line">        <span class="keyword">case</span> _Grunnable,</span><br><span class="line">            _Grunning,</span><br><span class="line">            _Gsyscall:</span><br><span class="line">            unlock(&amp;allglock)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"runtime: checkdead: find g "</span>, gp.goid, <span class="string">" in status "</span>, s, <span class="string">"\n"</span>)</span><br><span class="line">            throw(<span class="string">"checkdead: runnable g"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allglock)</span><br><span class="line">    <span class="keyword">if</span> grunning == <span class="number">0</span> &#123; <span class="comment">// possible if main goroutine calls runtime·Goexit()</span></span><br><span class="line">        throw(<span class="string">"no goroutines (main called runtime.Goexit) - deadlock!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maybe jump time forward for playground.</span></span><br><span class="line">    gp := timejump()</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        globrunqput(gp)</span><br><span class="line">        _p_ := pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">"checkdead: no p for timer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mp := mget()</span><br><span class="line">        <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// There should always be a free M since</span></span><br><span class="line">            <span class="comment">// nothing is running.</span></span><br><span class="line">            throw(<span class="string">"checkdead: no m for timer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mp.nextp.set(_p_)</span><br><span class="line">        notewakeup(&amp;mp.park)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getg().m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">    throw(<span class="string">"all goroutines are asleep - deadlock!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="retake"><a href="#retake" class="headerlink" title="retake"></a>retake</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forcePreemptNS is the time slice given to a G before it is</span></span><br><span class="line"><span class="comment">// preempted.</span></span><br><span class="line"><span class="keyword">const</span> forcePreemptNS = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> <span class="comment">// 10ms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="comment">// Prevent allp slice changes. This lock will be completely</span></span><br><span class="line">    <span class="comment">// uncontended unless we're already stopping the world.</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// We can't use a range loop over allp because we may</span></span><br><span class="line">    <span class="comment">// temporarily drop the allpLock. Hence, we need to re-fetch</span></span><br><span class="line">    <span class="comment">// allp each time around the loop.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 在 procresize 修改了 allp 但还没有创建新的 p 的时候</span></span><br><span class="line">            <span class="comment">// 会有这种情况</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        s := _p_.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// 从 syscall 接管 P，如果它进行 syscall 已经经过了一个 sysmon 的 tick(至少 20us)</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.syscalltick)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                pd.syscalltick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一方面如果没有其它工作可做的话，我们不想接管 p</span></span><br><span class="line">            <span class="comment">// 但另一方面为了避免 sysmon 线程陷入沉睡，我们最终还是会接管这些 p</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解开 allplock 的锁，然后就可以持有 sched.lock 锁了</span></span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line">            <span class="comment">// (pretending that one more is running) before the CAS.</span></span><br><span class="line">            <span class="comment">// Otherwise the M from which we retake can exit the syscall,</span></span><br><span class="line">            <span class="comment">// increment nmidle and report deadlock.</span></span><br><span class="line">            incidlelocked(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoSysBlock(_p_)</span><br><span class="line">                    traceProcStop(_p_)</span><br><span class="line">                &#125;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123;</span><br><span class="line">            <span class="comment">// 如果 G 运行时间太长，那么抢占它</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            preemptone(_p_)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h3><p>普通线程就是我们 G/P/M 模型里的 M 了，M 对应的就是操作系统的线程。</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>上面在创建 sysmon 线程的时候也看到了，创建线程的函数是 newm。</p>
<pre class="mermaid">graph TD
newm --> newm1
newm1 --> newosproc
newosproc --> clone</pre>

<p>最终会走到 linux 创建线程的系统调用 <code>clone</code>，代码里大段和 cgo 相关的内容我们就不关心了，摘掉 cgo 相关的逻辑后的代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 m。该 m 会在启动时调用函数 fn，或者 schedule 函数</span></span><br><span class="line"><span class="comment">// fn 需要是 static 类型，且不能是在堆上分配的闭包。</span></span><br><span class="line"><span class="comment">// 运行 m 时，m.p 是有可能为 nil 的，所以不允许 write barriers</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">    mp := allocm(_p_, fn)</span><br><span class="line">    mp.nextp.set(_p_)</span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 p 会被赋值给 m 的 nextp 成员，在 m 执行 schedule 时，会将 nextp 拿出来，进行之后真正的绑定操作(其实就是把 nextp 赋值为 nil，并把这个 nextp 赋值给 m.p，把 m 赋值给 p.m)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">    newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m, stk unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Disable signals during clone, so that the new thread starts</span></span><br><span class="line">    <span class="comment">// with signals disabled. It will enable them in minit.</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: failed to create new OS thread (have "</span>, mcount(), <span class="string">" already; errno="</span>, -ret, <span class="string">")\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> ret == -_EAGAIN &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"runtime: may need to increase max user processes (ulimit -u)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">"newosproc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>首先空闲的 m 会被丢进全局调度器的 midle 队列中，在需要 m 的时候，会先从这里取:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">// 尝试从 midle 列表中获取一个 m</span></span><br><span class="line"><span class="comment">// 必须锁全局的 sched</span></span><br><span class="line"><span class="comment">// 可能在 STW 期间执行，所以不允许 write barriers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span> *<span class="title">m</span></span> &#123;</span><br><span class="line">    mp := sched.midle.ptr()</span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.midle = mp.schedlink</span><br><span class="line">        sched.nmidle--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取不到的话就会调用之前提到的 newm 来创建新线程，创建的线程是不会被销毁的，哪怕之后不需要这么多 m 了，也就只是会把 m 放在 midle 中。</p>
<p>什么时候会创建线程呢，可以追踪一下 newm 的调用方:</p>
<pre class="mermaid">graph TD
main --> |sysmon|newm
startTheWorld --> startTheWorldWithSema
gcMarkTermination --> startTheWorldWithSema
gcStart--> startTheWorldWithSema
startTheWorldWithSema --> |helpgc|newm
startTheWorldWithSema --> |run p|newm
startm --> mget
mget --> |if no free m|newm
startTemplateThread --> |templateThread|newm
LockOsThread --> startTemplateThread
main --> |iscgo|startTemplateThread
handoffp --> startm
wakep --> startm
injectglist --> startm</pre>

<p>基本上来讲，m 都是按需创建的。如果 sched.midle 中没有空闲的 m 了，现在又需要，那么就会去创建一个。</p>
<p>创建好的线程需要绑定到 p 之后才会开始执行，执行过程中也可能被剥夺掉 p。比如前面 retake 的流程，就会将 g 的 stackguard0 修改为 stackPreempt，待下一次进入 newstack 时，会判断是否有该抢占标记，有的话，就会放弃运行。这也就是所谓的<code>协作式抢占</code>。</p>
<p>工作线程执行的内容核心其实就只有俩: <code>schedule()</code> 和 <code>findrunnable()</code>。</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><pre class="mermaid">graph TD
schedule --> A[schedtick%61 == 0]
A --> |yes|globrunqget
A --> |no|runqget
globrunqget --> C[gp == nil]
C --> |no|execute
C --> |yes|runqget
runqget --> B[gp == nil]
B --> |no|execute
B --> |yes|findrunnable
findrunnable --> execute</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调度器调度一轮要执行的函数: 寻找一个 runnable 状态的 goroutine，并 execute 它</span></span><br><span class="line"><span class="comment">// 调度函数是循环，永远都不会返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 cgo 调用的 g 不能被 schedule 走</span></span><br><span class="line">    <span class="comment">// 因为 cgo 调用使用 m 的 g0 栈</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">        gp = traceReader()</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 每调度几次就检查一下全局的 runq 来确保公平</span></span><br><span class="line">        <span class="comment">// 否则两个 goroutine 就可以通过互相调用</span></span><br><span class="line">        <span class="comment">// 完全占用本地的 runq 了</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// 在找到 goroutine 之前会一直阻塞下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程将要执行 goroutine，并且不会再进入 spinning 状态</span></span><br><span class="line">    <span class="comment">// 所以如果它被标记为 spinning，我们需要 reset 这个状态</span></span><br><span class="line">    <span class="comment">// 可能会重启一个新的 spinning 状态的 M</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">        <span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">        startlockedm(gp)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m 中所谓的调度循环实际上就是一直在执行下图中的 loop:</p>
<pre class="mermaid">graph TD
schedule --> execute
execute --> gogo
gogo --> goexit
goexit --> goexit1
goexit1 --> goexit0
goexit0 --> schedule</pre>


<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span><br><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span><br><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span><br><span class="line"><span class="comment">// acquiring a P in several places.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg() <span class="comment">// 这个可能是 m 的 g0</span></span><br><span class="line"></span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        _g_.m.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.curg = gp <span class="comment">// 把当前 g 的位置让给 m</span></span><br><span class="line">    gp.m = _g_.m <span class="comment">// 把 gp 指向 m，建立双向关系</span></span><br><span class="line"></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，绑定 g 和 m，然后 gogo 执行绑定的 g 中的函数。</p>
<h4 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h4><p>runtime.gogo 是汇编完成的，功能就是执行 <code>go func()</code> 的这个 <code>func()</code>，可以看到功能主要是把 g 对象的 gobuf 里的内容搬到寄存器里。然后从 <code>gobuf.pc</code> 寄存器存储的指令位置开始继续向后执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void gogo(Gobuf*)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), BX        <span class="comment">// gobuf</span></span><br><span class="line">    MOVQ    gobuf_g(BX), DX</span><br><span class="line">    MOVQ    <span class="number">0</span>(DX), CX        <span class="comment">// make sure g != nil</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    DX, g(CX)</span><br><span class="line">    MOVQ    gobuf_sp(BX), SP    <span class="comment">// restore SP</span></span><br><span class="line">    MOVQ    gobuf_ret(BX), AX</span><br><span class="line">    MOVQ    gobuf_ctxt(BX), DX</span><br><span class="line">    MOVQ    gobuf_bp(BX), BP</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_sp(BX)    <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ret(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ctxt(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_bp(BX)</span><br><span class="line">    MOVQ    gobuf_pc(BX), BX</span><br><span class="line">    JMP    BX</span><br></pre></td></tr></table></figure>

<p>当然，这里还是有一些和手写汇编不太一样的，看着比较奇怪的地方，<code>gobuf_sp(BX)</code> 这种写法按说标准 plan9 汇编中 <code>gobuf_sp</code> 只是个 <code>symbol</code>，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？</p>
<p>实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span></span><br></pre></td></tr></table></figure>

<p>这下知道怎么回事了吧，链接器会帮助我们把这个换成偏移量。。</p>
<h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><p>Goexit :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Goexit terminates the goroutine that calls it. No other goroutine is affected.</span></span><br><span class="line"><span class="comment">// Goexit runs all deferred calls before terminating the goroutine. Because Goexit</span></span><br><span class="line"><span class="comment">// is not a panic, any recover calls in those deferred functions will return nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calling Goexit from the main goroutine terminates that goroutine</span></span><br><span class="line"><span class="comment">// without func main returning. Since func main has not returned,</span></span><br><span class="line"><span class="comment">// the program continues execution of other goroutines.</span></span><br><span class="line"><span class="comment">// If all other goroutines exit, the program crashes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Run all deferred functions for the current goroutine.</span></span><br><span class="line">    <span class="comment">// This code is similar to gopanic, see that implementation</span></span><br><span class="line">    <span class="comment">// for detailed comments.</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d := gp._defer</span><br><span class="line">        <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d.started &#123;</span><br><span class="line">            <span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">                d._panic.aborted = <span class="literal">true</span></span><br><span class="line">                d._panic = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            d.fn = <span class="literal">nil</span></span><br><span class="line">            gp._defer = d.link</span><br><span class="line">            freedefer(d)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        d.started = <span class="literal">true</span></span><br><span class="line">        reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">        <span class="keyword">if</span> gp._defer != d &#123;</span><br><span class="line">            throw(<span class="string">"bad defer entry in Goexit"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d._panic = <span class="literal">nil</span></span><br><span class="line">        d.fn = <span class="literal">nil</span></span><br><span class="line">        gp._defer = d.link</span><br><span class="line">        freedefer(d)</span><br><span class="line">        <span class="comment">// Note: we ignore recovers here because Goexit isn't a panic</span></span><br><span class="line">    &#125;</span><br><span class="line">    goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racegoend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoEnd()</span><br><span class="line">    &#125;</span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br><span class="line">    CALL    runtime·goexit1(SB)    <span class="comment">// does not return</span></span><br><span class="line">    <span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br></pre></td></tr></table></figure>

<p>mcall :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func mcall(fn func(*g))</span></span><br><span class="line"><span class="comment">// Switch to m-&gt;g0's stack, call fn(g).</span></span><br><span class="line"><span class="comment">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span></span><br><span class="line"><span class="comment">// to keep running g.</span></span><br><span class="line">TEXT runtime·mcall(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">    MOVQ    fn+<span class="number">0</span>(FP), DI</span><br><span class="line"></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), AX    <span class="comment">// save state in g-&gt;sched</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), BX    <span class="comment">// caller's PC</span></span><br><span class="line">    MOVQ    BX, (g_sched+gobuf_pc)(AX)</span><br><span class="line">    LEAQ    fn+<span class="number">0</span>(FP), BX    <span class="comment">// caller's SP</span></span><br><span class="line">    MOVQ    BX, (g_sched+gobuf_sp)(AX)</span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_g)(AX)</span><br><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(AX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch to m-&gt;g0 &amp; its stack, call fn</span></span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">    MOVQ    g_m(BX), BX</span><br><span class="line">    MOVQ    m_g0(BX), SI</span><br><span class="line">    CMPQ    SI, AX    <span class="comment">// if g == m-&gt;g0 call badmcall</span></span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    MOVQ    $runtime·badmcall(SB), AX</span><br><span class="line">    JMP    AX</span><br><span class="line">    MOVQ    SI, g(CX)    <span class="comment">// g = m-&gt;g0</span></span><br><span class="line">    MOVQ    (g_sched+gobuf_sp)(SI), SP    <span class="comment">// sp = m-&gt;g0-&gt;sched.sp</span></span><br><span class="line">    PUSHQ    AX</span><br><span class="line">    MOVQ    DI, DX</span><br><span class="line">    MOVQ    <span class="number">0</span>(DI), DI</span><br><span class="line">    CALL    DI</span><br><span class="line">    POPQ    AX</span><br><span class="line">    MOVQ    $runtime·badmcall2(SB), AX</span><br><span class="line">    JMP    AX</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<h4 id="wakep"><a href="#wakep" class="headerlink" title="wakep"></a>wakep</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tries to add one more P to execute G's.</span></span><br><span class="line"><span class="comment">// Called when a G is made runnable (newproc, ready).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// be conservative about spinning threads</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules some M to run the p (creates an M if necessary).</span></span><br><span class="line"><span class="comment">// If p==nil, tries to get an idle P, if no idle P's does nothing.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">// If spinning is set, the caller has incremented nmspinning and startm will</span></span><br><span class="line"><span class="comment">// either decrement nmspinning or set m.spinning in the newly started M.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">        _p_ = pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">             unlock(&amp;sched.lock)</span><br><span class="line">             <span class="keyword">if</span> spinning &#123;</span><br><span class="line">                 <span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span><br><span class="line">                 <span class="comment">// so it's okay to just undo the increment and give up.</span></span><br><span class="line">                 <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                     throw(<span class="string">"startm: negative nmspinning"</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mp := mget()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">            fn = mspinning</span><br><span class="line">        &#125;</span><br><span class="line">        newm(fn, _p_)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        throw(<span class="string">"startm: m is spinning"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"startm: m has p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">        throw(<span class="string">"startm: p has runnable gs"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">    mp.spinning = spinning</span><br><span class="line">    mp.nextp.set(_p_)</span><br><span class="line">    notewakeup(&amp;mp.park)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="goroutine-挂起"><a href="#goroutine-挂起" class="headerlink" title="goroutine 挂起"></a>goroutine 挂起</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf.</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">// unlockf must not access this G's stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">string</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    gp := mp.curg</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">        throw(<span class="string">"gopark: bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mp.waitlock = lock</span><br><span class="line">    mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&amp;unlockf))</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    mp.waittraceev = traceEv</span><br><span class="line">    mp.waittraceskip = traceskip</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// can't do anything that might move the G between Ms here.</span></span><br><span class="line">    mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark gp ready to run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, traceskip)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark runnable.</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g-&gt;status in ready"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    runqput(_g_.m.p.ptr(), gp, next)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.locks--</span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in Case we've cleared it in newstack</span></span><br><span class="line">        _g_.stackguard0 = stackPreempt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">"notesleep not on g0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ns := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span><br><span class="line">        ns = <span class="number">10e6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> atomic.Load(key32(&amp;n.key)) == <span class="number">0</span> &#123;</span><br><span class="line">        gp.m.blocked = <span class="literal">true</span></span><br><span class="line">        futexsleep(key32(&amp;n.key), <span class="number">0</span>, ns)</span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp.m.blocked = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// One-time notifications.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noteclear</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    n.key = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">    old := atomic.Xchg(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"notewakeup - double wakeup ("</span>, old, <span class="string">")\n"</span>)</span><br><span class="line">        throw(<span class="string">"notewakeup - double wakeup"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    futexwakeup(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h4><p>findrunnable 比较复杂，流程图先把 gc 相关的省略掉了:</p>
<pre class="mermaid">graph TD
runqget --> A[gp == nil]
A --> |no|return
A --> |yes|globrunqget
globrunqget --> B[gp == nil]
B --> |no| return
B --> |yes| C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> K[gp == nil]
K --> |no|return
K --> |yes|runqsteal
C --> |no|runqsteal
runqsteal --> D[gp == nil]
D --> |no|return
D --> |yes|E[globrunqget]
E --> F[gp == nil]
F --> |no| return
F --> |yes| G[check all p's runq]
G --> H[runq is empty]
H --> |no|runqget
H --> |yes|I[netpoll]
I --> J[gp == nil]
J --> |no| return
J --> |yes| stopm
stopm --> runqget</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到一个可执行的 goroutine 来 execute</span></span><br><span class="line"><span class="comment">// 会尝试从其它的 P 那里偷 g，从全局队列中拿，或者 network 中 poll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">    <span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">    <span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">        <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">        asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 runq</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局 runq</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll network.</span></span><br><span class="line">    <span class="comment">// netpoll 是我们执行 work-stealing 之前的一个优化</span></span><br><span class="line">    <span class="comment">// 如果没有任何的 netpoll 等待者，或者线程被阻塞在 netpoll 中，我们可以安全地跳过这段逻辑</span></span><br><span class="line">    <span class="comment">// 如果在阻塞的线程中存在任何逻辑上的竞争(e.g. 已经从 netpoll 中返回，但还没有设置 lastpoll)</span></span><br><span class="line">    <span class="comment">// 该线程还是会将下面的 netpoll 阻塞住</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> gp := netpoll(<span class="literal">false</span>); gp != <span class="literal">nil</span> &#123; <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="comment">// netpoll 返回 goroutine 链表，用 schedlink 连接</span></span><br><span class="line">            injectglist(gp.schedlink.ptr())</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从其它 p 那里偷 g</span></span><br><span class="line">    procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// GOMAXPROCS=1 或者除了我们其它的 p 都是 idle</span></span><br><span class="line">        <span class="comment">// 新的工作可能从 syscall/cgocall，网络或者定时器中来。</span></span><br><span class="line">        <span class="comment">// 上面这些任务都不会被放到本地的 runq，所有没有可以 stealing 的点</span></span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果正在自旋的 M 的数量 &gt;= 忙着的 P，那么阻塞</span></span><br><span class="line">    <span class="comment">// 这是为了</span></span><br><span class="line">    <span class="comment">// 当 GOMAXPROCS 远大于 1，但程序的并行度又很低的时候</span></span><br><span class="line">    <span class="comment">// 防止过量的 CPU 消耗</span></span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">            <span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有可以干的事情。如果我们正在 GC 的标记阶段，可以安全地扫描和加深对象的颜色，</span></span><br><span class="line">    <span class="comment">// 这样可以进行空闲时间的标记，而不是直接放弃 P</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">        gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line">    <span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line">    <span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line">    <span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line">    allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 P 并阻塞</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">        throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pidleput(_p_)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line">    <span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line">    <span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line">    <span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line">    <span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line">    <span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line">    <span class="comment">// to run the goroutine.</span></span><br><span class="line">    <span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line">    <span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line">    <span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line">    <span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line">    <span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line">    <span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line">    wasSpinning := _g_.m.spinning</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查一下所有的 runq</span></span><br><span class="line">    <span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                    _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                    atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查 gc 空闲 g</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        _p_ = pidleget()</span><br><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">            pidleput(_p_)</span><br><span class="line">            _p_ = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">            acquirep(_p_)</span><br><span class="line">            <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go back to idle GC check.</span></span><br><span class="line">            <span class="keyword">goto</span> stop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poll network</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp := netpoll(<span class="literal">true</span>) <span class="comment">// 阻塞到返回为止</span></span><br><span class="line">        atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                injectglist(gp.schedlink.ptr())</span><br><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            injectglist(gp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="m-和-p-解绑定"><a href="#m-和-p-解绑定" class="headerlink" title="m 和 p 解绑定"></a>m 和 p 解绑定</h2><h3 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h3><pre class="mermaid">graph TD

mexit --> A[is m0?]
A --> |yes|B[handoffp]
A --> |no| C[iterate allm]
C --> |m found|handoffp
C --> |m not found| throw

forEachP --> |p status == syscall| handoffp

stoplockedm --> handoffp

entersyscallblock --> entersyscallblock_handoff
entersyscallblock_handoff --> handoffp

retake --> |p status == syscall| handoffp</pre>

<p>最终会把 p 放回全局的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hands off P from syscall or locked M.</span></span><br><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	<span class="comment">// handoffp must start an M in any situation where</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run on _p_.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// if it has local work, start it straight away</span></span><br><span class="line">	<span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if it has GC work, start it straight away</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no local work, check that there are no spinning/idle M's,</span></span><br><span class="line">	<span class="comment">// otherwise our help is not required</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">		startm(_p_, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		_p_.status = _Pgcstop</span><br><span class="line">		sched.stopwait--</span><br><span class="line">		<span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">			notewakeup(&amp;sched.stopnote)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		sched.safePointFn(_p_)</span><br><span class="line">		sched.safePointWait--</span><br><span class="line">		<span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">			notewakeup(&amp;sched.safePointNote)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If this is the last running P and nobody is polling network,</span></span><br><span class="line">	<span class="comment">// need to wakeup another M to poll network.</span></span><br><span class="line">	<span class="keyword">if</span> sched.npidle == <span class="keyword">uint32</span>(gomaxprocs<span class="number">-1</span>) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		startm(_p_, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="g-的状态迁移"><a href="#g-的状态迁移" class="headerlink" title="g 的状态迁移"></a>g 的状态迁移</h2><pre class="mermaid">graph LR
start{newg} --> Gidle
Gidle --> |oneNewExtraM|Gdead
Gidle --> |newproc1|Gdead

Gdead --> |newproc1|Grunnable
Gdead --> |needm|Gsyscall

Gscanrunning --> |scang|Grunning

Grunnable --> |execute|Grunning

Gany --> |casgcopystack|Gcopystack

Gcopystack --> |todotodo|Grunning

Gsyscall --> |dropm|Gdead
Gsyscall --> |exitsyscall0|Grunnable
Gsyscall --> |exitsyscall|Grunning

Grunning --> |goschedImpl|Grunnable
Grunning --> |goexit0|Gdead
Grunning --> |newstack|Gcopystack
Grunning --> |reentersyscall|Gsyscall
Grunning --> |entersyscallblock|Gsyscall
Grunning --> |markroot|Gwaiting
Grunning --> |gcAssistAlloc1|Gwaiting
Grunning --> |park_m|Gwaiting
Grunning --> |gcMarkTermination|Gwaiting
Grunning --> |gcBgMarkWorker|Gwaiting
Grunning --> |newstack|Gwaiting

Gwaiting --> |gcMarkTermination|Grunning
Gwaiting --> |gcBgMarkWorker|Grunning
Gwaiting --> |markroot|Grunning
Gwaiting --> |gcAssistAlloc1|Grunning
Gwaiting --> |newstack|Grunning
Gwaiting --> |findRunnableGCWorker|Grunnable
Gwaiting --> |ready|Grunnable
Gwaiting --> |findrunnable|Grunnable
Gwaiting --> |injectglist|Grunnable
Gwaiting --> |schedule|Grunnable
Gwaiting --> |park_m|Grunnable
Gwaiting --> |procresize|Grunnable
Gwaiting --> |checkdead|Grunnable</pre>

<p>图上的 Gany 代表任意状态，GC 时的状态切换比较多，如果只关注正常情况下的状态转换，可以把 markroot、gcMark 之类的先忽略掉。</p>
<h2 id="p-的状态迁移"><a href="#p-的状态迁移" class="headerlink" title="p 的状态迁移"></a>p 的状态迁移</h2><pre class="mermaid">graph LR

Pidle --> |acquirep1|Prunning

Psyscall --> |retake|Pidle
Psyscall --> |entersyscall_gcwait|Pgcstop
Psyscall --> |exitsyscallfast|Prunning

Pany --> |gcstopm|Pgcstop
Pany --> |forEachP|Pidle
Pany --> |releasep|Pidle
Pany --> |handoffp|Pgcstop
Pany --> |procresize release current p use allp 0|Pidle
Pany --> |procresize when init|Pgcstop
Pany --> |procresize when free old p| Pdead
Pany --> |procresize after resize use current p|Prunning
Pany --> |reentersyscall|Psyscall
Pany --> |stopTheWorldWithSema|Pgcstop</pre>

<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>函数执行是在 goroutine 的栈上，这个栈在函数执行期间是有可能溢出的，我们前面也看到了，如果一个函数用到了栈，会将 stackguard0 和 sp 寄存器进行比较，如果 sp &lt; stackguard0，说明栈已经增长到溢出，因为栈是从内存高地址向低地址方向增长的。</p>
<p>那么这个比较过程是在哪里完成的呢？这一步是由编译器完成的，我们看看一个函数编译后的结果，这段代码来自 go-internals:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000</span> TEXT    <span class="string">""</span>.main(SB), $<span class="number">24</span><span class="number">-0</span></span><br><span class="line">  ;; stack-split prologue</span><br><span class="line">  <span class="number">0x0000</span> MOVQ    (TLS), CX</span><br><span class="line">  <span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line">  <span class="number">0x000d</span> JLS    <span class="number">58</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x000f</span> SUBQ    $<span class="number">24</span>, SP</span><br><span class="line">  <span class="number">0x0013</span> MOVQ    BP, <span class="number">16</span>(SP)</span><br><span class="line">  <span class="number">0x0018</span> LEAQ    <span class="number">16</span>(SP), BP</span><br><span class="line">  ;; ...omitted FUNCDATA stuff...</span><br><span class="line">  <span class="number">0x001d</span> MOVQ    $<span class="number">137438953482</span>, AX</span><br><span class="line">  <span class="number">0x0027</span> MOVQ    AX, (SP)</span><br><span class="line">  ;; ...omitted PCDATA stuff...</span><br><span class="line">  <span class="number">0x002b</span> CALL    <span class="string">""</span>.add(SB)</span><br><span class="line">  <span class="number">0x0030</span> MOVQ    <span class="number">16</span>(SP), BP</span><br><span class="line">  <span class="number">0x0035</span> ADDQ    $<span class="number">24</span>, SP</span><br><span class="line">  <span class="number">0x0039</span> RET</span><br><span class="line"></span><br><span class="line">  ;; stack-split epilogue</span><br><span class="line">  <span class="number">0x003a</span> NOP</span><br><span class="line">  ;; ...omitted PCDATA stuff...</span><br><span class="line">  <span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">  <span class="number">0x003f</span> JMP    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>函数开头被插的这段指令，即是将 g struct 中的 stackguard 与 SP 寄存器进行对比，JLS 表示 SP &lt; 16(CX) 的话即跳转。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">;; stack-split prologue</span><br><span class="line"><span class="number">0x0000</span> MOVQ    (TLS), CX</span><br><span class="line"><span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line"><span class="number">0x000d</span> JLS    <span class="number">58</span></span><br></pre></td></tr></table></figure>

<p>这里因为 CX 寄存器存储的是 g 的起始地址，而 16(CX) 指的是 g 结构体偏移 16 个字节的位置，可以回顾一下 g 结构体定义，16 个字节恰好是跳过了第一个成员 stack(16字节) 之后的 stackguard0 的位置。</p>
<p>58 转为 16 进制即是 0x3a。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">;; stack-split epilogue</span><br><span class="line"><span class="number">0x003a</span> NOP</span><br><span class="line">;; ...omitted PCDATA stuff...</span><br><span class="line"><span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span><br><span class="line"><span class="number">0x003f</span> JMP    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>morestack_noctxt:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// morestack but not preserving ctxt.</span></span><br><span class="line">TEXT runtime·morestack_noctxt(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">    MOVL    $<span class="number">0</span>, DX</span><br><span class="line">    JMP    runtime·morestack(SB)</span><br></pre></td></tr></table></figure>

<p>morestack:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    <span class="comment">// Cannot grow scheduler stack (m-&gt;g0).</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">    MOVQ    g_m(BX), BX</span><br><span class="line">    MOVQ    m_g0(BX), SI</span><br><span class="line">    CMPQ    g(CX), SI</span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    CALL    runtime·badmorestackg0(SB)</span><br><span class="line">    INT    $<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot grow signal stack (m-&gt;gsignal).</span></span><br><span class="line">    MOVQ    m_gsignal(BX), SI</span><br><span class="line">    CMPQ    g(CX), SI</span><br><span class="line">    JNE    <span class="number">3</span>(PC)</span><br><span class="line">    CALL    runtime·badmorestackgsignal(SB)</span><br><span class="line">    INT    $<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called from f.</span></span><br><span class="line">    <span class="comment">// Set m-&gt;morebuf to f's caller.</span></span><br><span class="line">    MOVQ    <span class="number">8</span>(SP), AX    <span class="comment">// f's caller's PC</span></span><br><span class="line">    MOVQ    AX, (m_morebuf+gobuf_pc)(BX)</span><br><span class="line">    LEAQ    <span class="number">16</span>(SP), AX    <span class="comment">// f's caller's SP</span></span><br><span class="line">    MOVQ    AX, (m_morebuf+gobuf_sp)(BX)</span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVQ    g(CX), SI</span><br><span class="line">    MOVQ    SI, (m_morebuf+gobuf_g)(BX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set g-&gt;sched to context in f.</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), AX <span class="comment">// f's PC</span></span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_pc)(SI)</span><br><span class="line">    MOVQ    SI, (g_sched+gobuf_g)(SI)</span><br><span class="line">    LEAQ    <span class="number">8</span>(SP), AX <span class="comment">// f's SP</span></span><br><span class="line">    MOVQ    AX, (g_sched+gobuf_sp)(SI)</span><br><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(SI)</span><br><span class="line">    MOVQ    DX, (g_sched+gobuf_ctxt)(SI)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call newstack on m-&gt;g0's stack.</span></span><br><span class="line">    MOVQ    m_g0(BX), BX</span><br><span class="line">    MOVQ    BX, g(CX)</span><br><span class="line">    MOVQ    (g_sched+gobuf_sp)(BX), SP</span><br><span class="line">    CALL    runtime·newstack(SB)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, <span class="number">0x1003</span>    <span class="comment">// crash if newstack returns</span></span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>newstack:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from runtime·morestack when more stack is needed.</span></span><br><span class="line"><span class="comment">// Allocate larger stack and relocate to new stack.</span></span><br><span class="line"><span class="comment">// Stack growth is multiplicative, for constant amortized cost.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.</span></span><br><span class="line"><span class="comment">// If the GC is trying to stop this g then it will set preemptscan to true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must be nowritebarrierrec because it can be called as part of</span></span><br><span class="line"><span class="comment">// stack growth from other nowritebarrierrec functions, but the</span></span><br><span class="line"><span class="comment">// compiler doesn't check this.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thisg := getg()</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> double check all gp. shouldn't be getg().</span></span><br><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr().stackguard0 == stackFork &#123;</span><br><span class="line">        throw(<span class="string">"stack growth after fork"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr() != thisg.m.curg &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack called from g="</span>, hex(thisg.m.morebuf.g), <span class="string">"\n"</span>+<span class="string">"\tm="</span>, thisg.m, <span class="string">" m-&gt;curg="</span>, thisg.m.curg, <span class="string">" m-&gt;g0="</span>, thisg.m.g0, <span class="string">" m-&gt;gsignal="</span>, thisg.m.gsignal, <span class="string">"\n"</span>)</span><br><span class="line">        morebuf := thisg.m.morebuf</span><br><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr())</span><br><span class="line">        throw(<span class="string">"runtime: wrong goroutine in newstack"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := thisg.m.curg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> thisg.m.curg.throwsplit &#123;</span><br><span class="line">        <span class="comment">// Update syscallsp, syscallpc in case traceback uses them.</span></span><br><span class="line">        morebuf := thisg.m.morebuf</span><br><span class="line">        gp.syscallsp = morebuf.sp</span><br><span class="line">        gp.syscallpc = morebuf.pc</span><br><span class="line">        pcname, pcoff := <span class="string">"(unknown)"</span>, <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        f := findfunc(gp.sched.pc)</span><br><span class="line">        <span class="keyword">if</span> f.valid() &#123;</span><br><span class="line">            pcname = funcname(f)</span><br><span class="line">            pcoff = gp.sched.pc - f.entry</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack at "</span>, pcname, <span class="string">"+"</span>, hex(pcoff),</span><br><span class="line">            <span class="string">" sp="</span>, hex(gp.sched.sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span><br><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span><br><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        thisg.m.traceback = <span class="number">2</span> <span class="comment">// Include runtime frames</span></span><br><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp)</span><br><span class="line">        throw(<span class="string">"runtime: stack split at bad time"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    morebuf := thisg.m.morebuf</span><br><span class="line">    thisg.m.morebuf.pc = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.lr = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.sp = <span class="number">0</span></span><br><span class="line">    thisg.m.morebuf.g = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> stackguard0 may change underfoot, if another thread</span></span><br><span class="line">    <span class="comment">// is about to try to preempt gp. Read it just once and use that same</span></span><br><span class="line">    <span class="comment">// value now and below.</span></span><br><span class="line">    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Be conservative about where we preempt.</span></span><br><span class="line">    <span class="comment">// We are interested in preempting user Go code, not runtime code.</span></span><br><span class="line">    <span class="comment">// If we're holding locks, mallocing, or preemption is disabled, don't</span></span><br><span class="line">    <span class="comment">// preempt.</span></span><br><span class="line">    <span class="comment">// This check is very early in newstack so that even the status change</span></span><br><span class="line">    <span class="comment">// from Grunning to Gwaiting and back doesn't happen in this case.</span></span><br><span class="line">    <span class="comment">// That status change by itself can be viewed as a small preemption,</span></span><br><span class="line">    <span class="comment">// because the GC might change Gwaiting to Gscanwaiting, and then</span></span><br><span class="line">    <span class="comment">// this goroutine has to wait for the GC to finish before continuing.</span></span><br><span class="line">    <span class="comment">// If the GC is in some way dependent on this goroutine (for example,</span></span><br><span class="line">    <span class="comment">// it needs a lock held by the goroutine), that small preemption turns</span></span><br><span class="line">    <span class="comment">// into a real deadlock.</span></span><br><span class="line">    <span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">""</span> || thisg.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">            <span class="comment">// Let the goroutine keep running for now.</span></span><br><span class="line">            <span class="comment">// gp-&gt;preempt is set, so it will be preempted next time.</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"missing stack in newstack"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sp := gp.sched.sp</span><br><span class="line">    <span class="keyword">if</span> sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 &#123;</span><br><span class="line">        <span class="comment">// The call to morestack cost a word.</span></span><br><span class="line">        sp -= sys.PtrSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> || sp &lt; gp.stack.lo &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack sp="</span>, hex(sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span><br><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span><br><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sp &lt; gp.stack.lo &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: gp="</span>, gp, <span class="string">", gp-&gt;status="</span>, hex(readgstatus(gp)), <span class="string">"\n "</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: split stack overflow: "</span>, hex(sp), <span class="string">" &lt; "</span>, hex(gp.stack.lo), <span class="string">"\n"</span>)</span><br><span class="line">        throw(<span class="string">"runtime: split stack overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="keyword">if</span> gp == thisg.m.g0 &#123;</span><br><span class="line">            throw(<span class="string">"runtime: preempt g0"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> thisg.m.p == <span class="number">0</span> &amp;&amp; thisg.m.locks == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"runtime: g is running but p is not"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Synchronize with scang.</span></span><br><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">        <span class="keyword">if</span> gp.preemptscan &#123;</span><br><span class="line">            <span class="keyword">for</span> !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) &#123;</span><br><span class="line">                <span class="comment">// Likely to be racing with the GC as</span></span><br><span class="line">                <span class="comment">// it sees a _Gwaiting and does the</span></span><br><span class="line">                <span class="comment">// stack scan. If so, gcworkdone will</span></span><br><span class="line">                <span class="comment">// be set and gcphasework will simply</span></span><br><span class="line">                <span class="comment">// return.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">                <span class="comment">// gcw is safe because we're on the</span></span><br><span class="line">                <span class="comment">// system stack.</span></span><br><span class="line">                gcw := &amp;gp.m.p.ptr().gcw</span><br><span class="line">                scanstack(gp, gcw)</span><br><span class="line">                <span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">                    gcw.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">                gp.gcscandone = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            gp.preemptscan = <span class="literal">false</span></span><br><span class="line">            gp.preempt = <span class="literal">false</span></span><br><span class="line">            casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)</span><br><span class="line">            <span class="comment">// This clears gcscanvalid.</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act like goroutine called runtime.Gosched.</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a bigger segment and move the stack.</span></span><br><span class="line">    oldsize := gp.stack.hi - gp.stack.lo</span><br><span class="line">    newsize := oldsize * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> newsize &gt; maxstacksize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: goroutine stack exceeds "</span>, maxstacksize, <span class="string">"-byte limit\n"</span>)</span><br><span class="line">        throw(<span class="string">"stack overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The goroutine must be executing in order to call newstack,</span></span><br><span class="line">    <span class="comment">// so it must be Grunning (or Gscanrunning).</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gcopystack)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The concurrent GC will not scan the stack while we are doing the copy since</span></span><br><span class="line">    <span class="comment">// the gp is in a Gcopystack status.</span></span><br><span class="line">    copystack(gp, newsize, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"stack grow done\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Gcopystack, _Grunning)</span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下流程:</p>
<pre class="mermaid">graph TD
start[entering func] --> cmp[sp < stackguard0]
cmp --> |yes| morestack_noctxt
cmp --> |no|final[execute func]
morestack_noctxt --> morestack
morestack --> newstack
newstack --> preempt</pre>

<p>抢占都是在 newstack 中完成，但抢占标记是在 Go 源代码中的其它位置来进行标记的:</p>
<p>我们来看看 stackPreempt 是在哪些位置赋值给 stackguard0 的:</p>
<pre class="mermaid">graph LR

unlock --> |in case cleared in newstack|restorePreempt
ready --> |in case cleared in newstack|restorePreempt
startTheWorldWithSema --> |in case cleared in newstack|restorePreempt
allocm --> |in case cleared in newstack|restorePreempt
exitsyscall --> |in case cleared in newstack|restorePreempt
newproc1--> |in case cleared in newstack|restorePreempt
releasem -->  |in case cleared in newstack|restorePreempt

scang --> setPreempt
reentersyscall --> setPreempt
entersyscallblock --> setPreempt
preemptone--> setPreempt

enlistWorker --> preemptone
retake --> preemptone
preemptall --> preemptone
freezetheworld --> preemptall
stopTheWorldWithSema --> preemptall
forEachP --> preemptall
startpanic_m --> freezetheworld
gcMarkDone --> forEachP</pre>

<p>可见只有 gc 和 retake 才会去真正地抢占 g，并没有其它的入口，其它的地方就只是恢复一下可能在 newstack 中被清除掉的抢占标记。</p>
<p>当然，这里 entersyscall 和 entersyscallblock 比较特殊，虽然这俩函数的实现中有设置抢占标记，但实际上这两段逻辑是不会被走到的。因为 syscall 执行时是在 m 的 g0 栈上，如果在执行时被抢占，那么会直接 throw，而无法恢复。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪goroutine调度器[翻译自：Scheduler Tracing In Go]</title>
    <url>/blog/2019/06/23/20190623003354.html</url>
    <content><![CDATA[<blockquote>
<p>能够生成分析和调试信息是我喜欢Go语言的原因之一。通过配置<code>GODEBUG</code>环境变量可以在程序运行期间打印出调试信息，包括gc和scheduler的详细或摘要。最棒的是你不必在程序里设置任何开关它就能够正常工作。</p>
</blockquote>
<h1 id="开始前"><a href="#开始前" class="headerlink" title="开始前"></a>开始前</h1><blockquote>
<p>在这篇文章中，我将向您展示如何使用示例并发Go程序中解释调度程序跟踪信息。 如果您对调度程序有基本的了解，这将有所帮助。 我建议在继续之前阅读这两篇文章：</p>
<ol>
<li><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">Concurrency, Goroutines and GOMAXPROCS</a></li>
<li><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">Go Scheduler</a></li>
</ol>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><blockquote>
<p>以下是我们检查和解释<code>GODEBUG</code>结果的示例程序。</p>
</blockquote>
<p>List1</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workNum := <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(workNum)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> work(&amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// Wait to see the global run queue deplete.</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e10</span>; i++ &#123;</span><br><span class="line">		counter++</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>List1中的代码旨在针对我们希望运行时发出的调试信息进行预测。 在第12行，声明一个for循环创建十个goroutines。 然后主函数在第16行等待所有goroutines完成他们的工作。 第22行的工作函数休眠一秒钟，然后将局部变量增加100亿次。 递增完成后，该函数在等待组上调用Done并返回。</p>
<p>在设置<code>GODEBUG</code>来运行程序之前首先构建程序是一个不错的主意，该变量由运行时被设置，因此应用go命令也会产生跟踪输出。如果你使用<code>go run</code>来跟踪程序，那么在程序正式运行之前构建时的追踪信息也将被打印出来。</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>下边让我们来运行这个程序：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build example.go</span><br></pre></td></tr></table></figure>
<h2 id="追踪scheduler摘要信息"><a href="#追踪scheduler摘要信息" class="headerlink" title="追踪scheduler摘要信息"></a>追踪scheduler摘要信息</h2><blockquote>
<p>通过<code>schedtrace</code> 配置项可以让程序在运行时每隔 X 毫秒打印一行包括调度器状态和标准错误的摘要信息。让我们设置<code>GODEBUG</code>选项并运行这个程序吧：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS=1 GODEBUG=schedtrace=1000 ./example</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一旦程序开始运行，我们就可以看到追踪(tracing)信息开始打印了。程序本身不输出任何内容，因此控制台输出的内容均为追踪信息，让我们看看前两次tracing信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=1 idleprocs=0 threads=2 spinningthreads=0 idlethreads=0 runqueue=0 [1]</span><br><span class="line"></span><br><span class="line">SCHED 1009ms: gomaxprocs=1 idleprocs=0 threads=3 spinningthreads=0 idlethreads=1 runqueue=0 [9]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>让我们来分解一下每个字段的含义，并根据示例程序理解这些值的含义：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1009ms        : 从程序开始到打印该行信息经过的毫秒数.</span><br><span class="line">                此处是第1秒时打印的trace.</span><br><span class="line"></span><br><span class="line">gomaxprocs=1  : 配置的P数量(注：需了解 goroutine调度模型中 M P G 概念).</span><br><span class="line">                在此次试验中，仅设置为1.</span><br><span class="line"></span><br><span class="line">特别注意:</span><br><span class="line">考虑在这里的processor是一个逻辑processor，而不是物理processor。</span><br><span class="line">调度器在这些逻辑processors运行程序，而它们都是通过操作系统与内核线程(os thread)绑定的。</span><br><span class="line">操作系统会在可用的物理processor上再次调度这些内核线程。</span><br><span class="line"></span><br><span class="line">threads=3     : 运行时的线程数(注：我理解为goroutine调度模型中的M).</span><br><span class="line">                存在3个，一个用于processor，其他两个用于运行时</span><br><span class="line"></span><br><span class="line">idlethreads=1 : 空闲线程的数量.</span><br><span class="line">                1个线程空闲，2个在运行.</span><br><span class="line"></span><br><span class="line">idleprocs=0   : 空闲processor的数量.</span><br><span class="line">                0个空闲，1个运行.</span><br><span class="line"></span><br><span class="line">runqueue=0    : 全局运行队列(runq)中goroutine的数量.</span><br><span class="line">                所有可运行的goroutine被移动到 P 的local运行队列(注：p.runq).</span><br><span class="line"></span><br><span class="line">[9]           : P 的local 运行队列中的 goroutine 数量（注：由于运行时配置了processor数量为1这里只打印1个，配置多个时会打印多个，对应每一个 P）.</span><br><span class="line">                在P的local 运行队列中有 9个goroutine.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序在运行时给了我们很多非常棒的摘要信息。当我们在查看第一秒打印的追踪信息时，我们可以看到一个goroutine是如何运行而其他9个goroutine在 P的local 运行队列中等待。</p>
</blockquote>
<p>示例图1<br><img src="/resources/post_pic/2019/06/diagram1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="示例图1"></p>
<blockquote>
<p>在示例图1中，用字母 <code>P</code> 来表示processor，用字母 <code>M</code> 来表示线程，用字母 <code>G</code> 来表示goroutine。我们可以根据 <code>runqueue</code> 的值为0而推断出全局的运行队列(Global Run Queue)是空的。prcessor 的 <code>idleprocs</code> 值为0，而它正在运行着一个 goroutine ，我们后边新建的goroutine则在这个 processor的local 运行队列中（根据process 的<code>runqueue</code>值为9判断的）。</p>
<p>当我们把processor个数配置多个时会有怎样的追踪信息呢？让我们把<code>GOMAXPROCS</code>的值设置为2，再看一次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS=2 GODEBUG=schedtrace=1000 ./example</span><br><span class="line"></span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=1 threads=2 spinningthreads=0</span><br><span class="line">idlethreads=0 runqueue=0 [0 0]</span><br><span class="line"></span><br><span class="line">SCHED 1002ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1</span><br><span class="line">idlethreads=1 runqueue=0 [0 4]</span><br><span class="line"></span><br><span class="line">SCHED 2006ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=0 [4 4]</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">SCHED 6024ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=2 [3 3]</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">SCHED 10049ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=4 [2 2]</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">SCHED 13067ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=6 [1 1]</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">SCHED 17084ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=8 [0 0]</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">SCHED 21100ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=2 runqueue=0 [0 0]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行新程序后，让我们着重看一下第二秒之后的信息:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 2002ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0 idlethreads=1 runqueue=0 [4 4]</span><br><span class="line"></span><br><span class="line">2002ms        : 标志这是第二秒追踪的信息.</span><br><span class="line">gomaxprocs=2  : 程序最大processor数是2.</span><br><span class="line">threads=4     : 4个线程，2个用于运行processor，2个用于运行时.</span><br><span class="line">idlethreads=1 : 1个空闲线程(3 threads running).</span><br><span class="line">idleprocs=0   : 0个空闲processor (2 processors busy).</span><br><span class="line">runqueue=0    : 所有可运行的goroutine被移动到 P的local运行队列(所以全局runqueue为0).</span><br><span class="line">[4 4]         : 每个P的local 运行队列有4个 goroutine等待运行.</span><br></pre></td></tr></table></figure>

<p>示例图2<br><img src="/resources/post_pic/2019/06/diagram2.png" alt="示例图2"></p>
<blockquote>
<p>让我们再看一下示例图2.我们能够看到goroutine是如何在两个 processor上运行的，其中有8个goroutine在runqueue中等待运行，它们分别在两个processor 的local 运行队列中(各4个)。</p>
</blockquote>
<blockquote>
<p>第6秒的时候，发生了一些变化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 6024ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0 idlethreads=1 runqueue=2 [3 3]</span><br><span class="line"></span><br><span class="line">idleprocs=0 : 0 processors are idle (2 processors busy).</span><br><span class="line">runqueue=2  : 2 goroutines returned and are waiting to be terminated.</span><br><span class="line">[3 3]       : 3 goroutines are waiting inside each local run queue.</span><br></pre></td></tr></table></figure>

<p>示例图3<br><img src="/resources/post_pic/2019/06/diagram3.png" alt="示例图3"></p>
<blockquote>
<p>在此图中，我们创建的goroutine在完成工作之后被移动到 Golbal Run Queue 中。我们可以看到仍然有2个goroutine正在运行，每个processor各运行一个，每个processor的local 运行队列中有3个goroutine.</p>
</blockquote>
<p>特别注意：</p>
<blockquote>
<p>在许多情况下，goroutine在终止之前不会移回全局运行队列。 这个程序创建了一个特殊情况，因为for循环执行的逻辑运行时间超过10毫秒并且没有调用任何函数。 10ms是调度程序中的调度量。 执行10ms后，调度程序尝试抢占goroutines。 这些goroutine不能被抢占，因为它们不会调用任何函数。 在这种情况下，一旦goroutine到达wg.Done调用，goroutines立即被抢占并移动到全局运行队列以终止。</p>
</blockquote>
<blockquote>
<p>17秒的时候，我们可以看到在processor中正在运行着最后的两个goroutine。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 17084ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0 idlethreads=1 runqueue=8 [0 0]</span><br><span class="line"></span><br><span class="line">idleprocs=0 : 0 processors are idle (2 processors busy).</span><br><span class="line">runqueue=8  : 8 goroutines returned and are waiting to be terminated.</span><br><span class="line">[0 0]       : No goroutines are waiting inside any local run queue.</span><br></pre></td></tr></table></figure>

<p>示例图4<br><img src="/resources/post_pic/2019/06/diagram4.png" alt="示例图4"></p>
<blockquote>
<p>在图4中，我们看到8个goroutine在全局运行队列中，剩下的最后2个goroutine正在运行。 这时每个processor的local 运行队列都为空。</p>
</blockquote>
<blockquote>
<p>第21秒的摘要信息：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 21100ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line"></span><br><span class="line">idleprocs=2 : 2 processors are idle (0 processors busy).</span><br><span class="line">runqueue=0  : All the goroutines that were in the queue have been terminated.</span><br><span class="line">[0 0]       : No goroutines are waiting inside any local run queue.</span><br></pre></td></tr></table></figure>

<p>示例图5<br><img src="/resources/post_pic/2019/06/diagram5.png" alt="示例图5"></p>
<blockquote>
<p>此时，所有的goroutine都完成工作，并且被终结。</p>
</blockquote>
<h2 id="追踪详细信息"><a href="#追踪详细信息" class="headerlink" title="追踪详细信息"></a>追踪详细信息</h2><blockquote>
<p>scheduler的摘要追踪信息非常有用，但是有时你需要更详细的信息。在这种情况下，我们可以增加<code>shceddetail</code>配置，它能够提供 thread、processor、goroutine的详细信息，让我们重新运行程序：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS=2 GODEBUG=schedtrace=1000,scheddetail=1 ./example</span><br></pre></td></tr></table></figure>

<p>以下是第4秒的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 4028ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0</span><br><span class="line">idlethreads=1 runqueue=2 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0</span><br><span class="line">P0: status=1 schedtick=10 syscalltick=0 m=3 runqsize=3 gfreecnt=0</span><br><span class="line">P1: status=1 schedtick=10 syscalltick=1 m=2 runqsize=3 gfreecnt=0</span><br><span class="line">M3: p=0 curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1</span><br><span class="line">M2: p=1 curg=10 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1</span><br><span class="line">M1: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=1 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1</span><br><span class="line">M0: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1</span><br><span class="line">G1: status=4(semacquire) m=-1 lockedm=-1</span><br><span class="line">G2: status=4(force gc (idle)) m=-1 lockedm=-1</span><br><span class="line">G3: status=4(GC sweep wait) m=-1 lockedm=-1</span><br><span class="line">G4: status=2(sleep) m=3 lockedm=-1</span><br><span class="line">G5: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G6: status=1(stack growth) m=-1 lockedm=-1</span><br><span class="line">G7: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G8: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G9: status=1(stack growth) m=-1 lockedm=-1</span><br><span class="line">G10: status=2(sleep) m=2 lockedm=-1</span><br><span class="line">G11: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G12: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G13: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G17: status=4(timer goroutine (idle)) m=-1 lockedm=-1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>摘要的部分与前边的实验输出是相似的，但是我们现在有更详细的 thread、processor、goroutine信息。从 processor开始看吧：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P0: status=1 schedtick=10 syscalltick=0 m=3 runqsize=3 gfreecnt=0</span><br><span class="line"></span><br><span class="line">P1: status=1 schedtick=10 syscalltick=1 m=2 runqsize=3 gfreecnt=0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仍然用字母 P 表示 processor，由于<code>GOMAXPROCS</code>被设置为2，我们可以看到有两条关于P的信息。接下来我们看下线程：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M3: p=0 curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0</span><br><span class="line">spinning=0 blocked=0 lockedg=-1</span><br><span class="line"></span><br><span class="line">M2: p=1 curg=10 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0</span><br><span class="line">spinning=0 blocked=0 lockedg=-1</span><br><span class="line"></span><br><span class="line">M1: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=1 dying=0 helpgc=0</span><br><span class="line">spinning=0 blocked=0 lockedg=-1</span><br><span class="line"></span><br><span class="line">M0: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0</span><br><span class="line">spinning=0 blocked=0 lockedg=-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>M 表示线程。由于线程数被设置为4(注：并没看到那个地方配置了这个。。。)，我们可以看到4条关于M的详细信息。从这些详细信息中可以看出哪个P与哪个M关联。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在P的详情里P0的 m 值为3，表示P0与M3关联</span><br><span class="line">P0: status=1 schedtick=10 syscalltick=0 m=3 runqsize=3 gfreecnt=0</span><br><span class="line"># 反过来看M3，它的p值为0</span><br><span class="line">M3: p=0 curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0</span><br><span class="line">spinning=0 blocked=0 lockedg=-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里看到了M3和P0关联到一起，P 和 M都会记录这个信息。</p>
</blockquote>
<blockquote>
<p>G表示一个goroutine。在4秒标记处，我们看到目前存在14个goroutine，自程序启动以来已创建了17个goroutine。 我们知道由于跟踪中列出的最后一个G附加的数字而创建的goroutine总数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G17: status=4(timer goroutine (idle)) m=-1 lockedm=-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果这个程序继续创建goroutines，我们会看到这个数字线性增加。 例如，如果该程序正在处理Web请求，我们可以使用这个数值来大致了解已处理的请求数。 如果程序在处理请求期间没有创建任何其他goroutine，则此估计值更接近真实的请求数。</p>
</blockquote>
<blockquote>
<p>接下来再看一下 main函数运行的 goroutine：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G1: status=4(semacquire) m=-1 lockedm=-1</span><br><span class="line"></span><br><span class="line">30     wg.Done()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，main函数所在的 goroutine状态是 4,阻塞在 semacquire，这是因为我们在代码中调用了 group.Wait。</p>
<p>为了更好地理解此跟踪中的其余goroutine，了解状态数字代表什么是有很有用的。 以下是在运行时头文件中声明的状态代码列表：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status: http://golang.org/src/runtime/</span><br><span class="line">Gidle,            // 0</span><br><span class="line">Grunnable,        // 1 runnable and on a run queue</span><br><span class="line">Grunning,         // 2 running</span><br><span class="line">Gsyscall,         // 3 performing a syscall</span><br><span class="line">Gwaiting,         // 4 waiting for the runtime</span><br><span class="line">Gmoribund_unused, // 5 currently unused, but hardcoded in gdb scripts</span><br><span class="line">Gdead,            // 6 goroutine is dead</span><br><span class="line">Genqueue,         // 7 only the Gscanenqueue is used</span><br><span class="line">Gcopystack,       // 8 in this state when newstack is moving the stack</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们查看我们创建的10个goroutines时，我们现在可以查看它们的状态并更好地了解每个goroutine正在做什么：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Goroutines running in a processor. (idleprocs=0)</span><br><span class="line">G4: status=2(sleep) m=3 lockedm=-1   – Thread M3 / Processor P0</span><br><span class="line">G10: status=2(sleep) m=2 lockedm=-1  – Thread M2 / Processor P1</span><br><span class="line"></span><br><span class="line">// Goroutines waiting to be run on a particular processor. (runqsize=3)</span><br><span class="line">G5: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G7: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G8: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line"></span><br><span class="line">// Goroutines waiting to be run on a particular processor. (runqsize=3)</span><br><span class="line">G11: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G12: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line">G13: status=1(sleep) m=-1 lockedm=-1</span><br><span class="line"></span><br><span class="line">// Goroutines waiting on the global run queue. (runqueue=2)</span><br><span class="line">G6: status=1(stack growth) m=-1 lockedm=-1</span><br><span class="line">G9: status=1(stack growth) m=-1 lockedm=-1</span><br></pre></td></tr></table></figure>


<blockquote>
<p>通过对调度程序的基本了解以及了解程序的行为，我们可以详细了解事情的调度方式以及程序中每个处理器，线程和goroutine的状态。</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<p><code>GODEBUG</code>是在程序运行时窥视调度程序思维的好方法。 它可以告诉你很多关于程序的行为方式。 如果您想了解更多信息，请首先编写一些可用于预测来自调度程序的跟踪的简单程序。 在尝试查看更复杂程序的跟踪之前，了解期望的内容。</p>
</blockquote>
<p><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之网络</title>
    <url>/blog/2019/06/21/20190621005014.html</url>
    <content><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><blockquote>
<p>介绍部分docker的网络驱动</p>
</blockquote>
<h2 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h2><h3 id="docker0网桥"><a href="#docker0网桥" class="headerlink" title="docker0网桥"></a>docker0网桥</h3><blockquote>
<p>当在一台Linux系统的机器上装了Docker后，在宿主机上使用ifconfig命令可以看到多了一块名为docker0的网卡，我本地的docker0 IP是 172.17.0.0/16，宿主机上也多了一条路由：</p>
<p>#<code>route -n</code><br>…<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br>这条路由表示所有目的IP为 172.17.0.0/16的数据包都从docker0发出。使用docker创建一个容器，<code>docker run -d busybox</code>，进入到容器中查看网络设备信息<code>ip addr</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">77: eth0@if78: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该容器网卡eth0连接在 if78这个设备上（不同测试环境可能不一样），在宿主机上执行<code>ip addr</code>，查看网络设备：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">78: veth3eb50a6@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 86:5a:5e:ea:1c:60 brd ff:ff:ff:ff:ff:ff link-netnsid 3</span><br><span class="line">    inet6 fe80::845a:5eff:feea:1c60/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>78号设备的设备名称是 veth3eb50a6，然后再执行命令<code>brctl show</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">docker0         8000.0242f959ef4b       no              veth3eb50a6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以发现设备 veth3eb50a6 连在网桥docker0上。</p>
<p>网桥是一个二层设备，veth3eb50a6和容器中的eth0相当于一根网线的两个端口，整个过程可以看做是：用一根网线把容器和网桥docker0连了起来。当创建容器时如果不指定容器连接到的网络，容器都将连到docker0上，那么容器之间是二层互通的，可以之间相互访问。</p>
<p>至于上边主机上为什么添加路由信息：主机通过路由，使其能够访问容器IP，它工作在三层。</p>
</blockquote>
<h3 id="docker多网桥测试"><a href="#docker多网桥测试" class="headerlink" title="docker多网桥测试"></a>docker多网桥测试</h3><blockquote>
<p>本小节测试容器加入不同的网桥，以及它们之间的连通性。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先创建网络</span></span><br><span class="line">[root@node ~]# docker network create backend</span><br><span class="line">[root@node ~]# docker network create frontend</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器 c1,c2,c3，其中，c1,c2接入网桥backend，c2,c3接入网桥 frontend</span></span><br><span class="line">[root@node ~]# docker run -d --name c1 --net backend busybox</span><br><span class="line">[root@node ~]# docker run -d --name c2 --net backend busybox</span><br><span class="line">[root@node ~]# docker run -d --name c3 --net frontend busybox</span><br><span class="line">[root@node ~]# docker network connect frontend c2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从以上来看， c1,c2同时接入网桥backend两者二层连通，c2,c3同理接入网桥frontend。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> c2上插了两根网线，分别接入了backend和frontend。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分别进入 c1 c2 c3测试另外两个容器连通性，结果如下：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>-</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>c2</td>
<td>true</td>
<td>-</td>
<td>true</td>
</tr>
<tr>
<td>c3</td>
<td>false</td>
<td>true</td>
<td>-</td>
</tr>
</tbody></table>
<p>符合预期。</p>
<p>此时在宿主机上使用 <code>ip addr</code>命令可以看到新增的两个网桥和ip，使用<code>route</code>命令可以看到对应的r转发到这两个容器的路由信息。</p>
</blockquote>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><blockquote>
<p>如果需要docker容器访问外部网络，则需要对宿主机进行配置：</p>
<ol>
<li>允许Linux内核IP转发 <code>sysctl net.ipv4.conf.all.forwarding=1</code></li>
<li>将iptables FORWARD的策略从<code>DROP</code>改为<code>AACEPT</code></li>
</ol>
<p>当访问外部时，对其做SNAT（源地址转化），对外部来说，就是宿主机在访问，外部感知不到容器的存在。</p>
<p>如果外部访问容器，则需要做端口映射，在启动容器时指定参数 <code>-p 主机端口:容器端口</code>，在iptables的nat和filter 的DOCKER链中会增加一条规则，将访问宿主机指定端口的流量转发到容器中，所以外界访问Docker容器是通过DNAT（目的地址转换）实现的。可以通过在filter的DOCKER链上添加规则来限制源IP的数据包访问容器。</p>
</blockquote>
<h2 id="overlay网络"><a href="#overlay网络" class="headerlink" title="overlay网络"></a>overlay网络</h2><blockquote>
<p>docker中的overlay驱动使用IETF标准的VXLAN方式。</p>
<p>TODO</p>
</blockquote>
<h1 id="高级网络"><a href="#高级网络" class="headerlink" title="高级网络"></a>高级网络</h1><h2 id="Linux-NetworkNamespace"><a href="#Linux-NetworkNamespace" class="headerlink" title="Linux NetworkNamespace"></a>Linux NetworkNamespace</h2><blockquote>
<p>TODO</p>
</blockquote>
<h2 id="容器跨主机访问方案"><a href="#容器跨主机访问方案" class="headerlink" title="容器跨主机访问方案"></a>容器跨主机访问方案</h2><blockquote>
<p>TODO</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker网络</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s问题总结</title>
    <url>/blog/2019/06/20/20190620225015.html</url>
    <content><![CDATA[<blockquote>
<p>总结遇到的问题及解决方案</p>
</blockquote>
<h1 id="设计类问题"><a href="#设计类问题" class="headerlink" title="设计类问题"></a>设计类问题</h1><h2 id="集群Master高可用"><a href="#集群Master高可用" class="headerlink" title="集群Master高可用"></a>集群Master高可用</h2><blockquote>
<p>创建集群时，使用多个Master就不提了，这是基础。</p>
<ol>
<li>一般做法是使用Keepalived陪VIP，结合health_check来做高可用，但这种做法存在一个问题：所有的rest请求都落到一个Master上，当客户端请求量比较大的时候，会导致apiserver hang死。</li>
</ol>
<p>-<br>2. 使用DNS动态解析：平安证券分享的方案（公众号上看的，公布细节有限，原话是：<code>当Master挂掉，DNS解析可在十分钟内指向新的MasterIP</code>），猜测他们的做法使用脚本去发现apiserver的运行状况，发现挂掉，就切换解析，这种做法在Master挂掉时，会存在无法访问apiserver服务的空窗期（十分钟左右，DNS解析生效时间），无法提供服务，而且所有请求也都落到一个Master上；另一种利用DNS的做法是DNS批量解析到所有Master上，当脚本检测到Master挂掉，然后解除到该Master的解析，虽然比前者好用一些，但在DNS删除解析生效期间，也会有一部分请求落到挂掉的Master上。<br>-<br>3. 使用Nginx+Keepalived方案：首先所有Master上都使用docker启动一个NGINX，并配置自动重启和检查apiserver健康的策略，然后安装好keepalived并配置VIP和设置NGINX的监控检查规则。客户端向集群发送rest请求时使用的是VIP+NGINX端口，所有请求都落到VIP Master的NGINX上，然后由NGINX转发到所有Master的apiserver上。- NGINX配置apiserver健康检查，可以保证其转发的请求都能转发到正常运行的apiserver上，keepalived配置NGINX的健康检查可以保证，每次客户端请求时都能请求到NGINX，通过这么设置，实现了NGINX的高可用和apiserver的高可用，且所有到apiserver的请求不仅仅落到某一台机器上。</p>
</blockquote>
<h2 id="不同集群Pod间网络互通"><a href="#不同集群Pod间网络互通" class="headerlink" title="不同集群Pod间网络互通"></a>不同集群Pod间网络互通</h2><blockquote>
<p>正常情况下，不同集群的Pod之间是无法相互访问的</p>
<p>想要不同集群Pod之间网络互通，必要条件是，两者的网段不能够冲突，如果冲突，无法确定Pod要访问的地址到底是另一个集群的还是当前集群的。</p>
<ol>
<li>使用网络插件。通过对Pod请求出来的数据进行重新封包（目标PodIP所在集群作为新包的目的IP），把数据包发送到目标Pod所在集群，然后网络插件再解包，把解包后的原始数据包发送到指定Pod，实现Pod网络互通的目地。</li>
<li>使用网关+路由的方式。在集群中弄几台机器用作网关，所有到该集群Pod的请求路由到这些机器，这些机器再利用kube-proxy将请求转到Pod内部，实现网络互通，但这种实现方式中，一个Pod请求到外部和外部请求进来的路径不一致。外部请求进来：proxyNode-&gt;Pod；请求到外部：Pod-&gt;Pod所在Node-&gt;外部。这种方式存在问题：对于Pod来说，每次请求的来源IP都是ProxyNode，当应用根据来源IP来做一些策略时可能存在问题。</li>
</ol>
</blockquote>
<h1 id="踩坑系列"><a href="#踩坑系列" class="headerlink" title="踩坑系列"></a>踩坑系列</h1><h2 id="apiserver请求过多，直接hang死"><a href="#apiserver请求过多，直接hang死" class="headerlink" title="apiserver请求过多，直接hang死"></a>apiserver请求过多，直接hang死</h2><blockquote>
<p>使用<code>集群Master高可用方案</code>里的第3点（参照<code>设计类问题</code>中的<code>集群Master高可用部分</code>）。</p>
</blockquote>
<h2 id="k8s-1-12以下版本kubelet使用configmap后无法删除pod"><a href="#k8s-1-12以下版本kubelet使用configmap后无法删除pod" class="headerlink" title="k8s 1.12以下版本kubelet使用configmap后无法删除pod"></a>k8s 1.12以下版本kubelet使用configmap后无法删除pod</h2><blockquote>
<p>原因：kubelet目录使用了软连接，umount时报错。解决：1.升级1.12后修复bug 2. /etc/systemd/system/kubelet.service.d/10-kubeadm.conf中启动命令加上参数 –root-dir=/app/…kubelet 直接将kubelet目录改成实际目录</p>
</blockquote>
<h2 id="k8s-postStart执行程序导致容器无法ready"><a href="#k8s-postStart执行程序导致容器无法ready" class="headerlink" title="k8s postStart执行程序导致容器无法ready"></a>k8s postStart执行程序导致容器无法ready</h2><blockquote>
<p>使用postStart执行程序时如果执行的是一个常驻程序，会导致容器一直处于 containerCreating状态</p>
</blockquote>
<h2 id="k8s-apiserver-调不通-service类型的webhook-TODO"><a href="#k8s-apiserver-调不通-service类型的webhook-TODO" class="headerlink" title="k8s apiserver 调不通 service类型的webhook  // TODO"></a>k8s apiserver 调不通 service类型的webhook  // TODO</h2><h2 id="k8s-coredns主机多个servername时，随机解析-主机上配了容灾dns服务器"><a href="#k8s-coredns主机多个servername时，随机解析-主机上配了容灾dns服务器" class="headerlink" title="k8s coredns主机多个servername时，随机解析(主机上配了容灾dns服务器)"></a>k8s coredns主机多个servername时，随机解析(主机上配了容灾dns服务器)</h2><blockquote>
<p>coredns configmap配置串行解析</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forward . /etc/resolv.conf  &#123; </span><br><span class="line"> policy  sequential</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="k8s集群内数据包无法通过weave发送到指定pod-内核3-10-weave-2-4-0"><a href="#k8s集群内数据包无法通过weave发送到指定pod-内核3-10-weave-2-4-0" class="headerlink" title="k8s集群内数据包无法通过weave发送到指定pod(内核3.10,weave 2.4.0)"></a>k8s集群内数据包无法通过weave发送到指定pod(内核3.10,weave 2.4.0)</h2><blockquote>
<p>原因(同时存在)：</p>
<ol>
<li>在低于3.14版本的内核中，bridge设备的mac地址发生变化的时候，local fdb未更新。<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a4b816d8ba1c1917842dc3de97cbf8ef116e043e" target="_blank" rel="noopener">内核修复记录</a></li>
<li>weave 2.4.0中，网桥执行initPrep时给网桥设置了mac地址，后边其他地方又修改了。<a href="https://github.com/weaveworks/weave/pull/3442" target="_blank" rel="noopener">weave修复记录</a></li>
</ol>
<p>解决办法(解决1个即可)：</p>
<ol>
<li>升级内核大于3.14(解决内核bug) </li>
<li>升级weave版本到2.5.0以后(去掉了initPrep中给网桥初始化mac地址的代码)</li>
</ol>
</blockquote>
<h2 id="内核参数-tcp-timestamps-开启导致的问题"><a href="#内核参数-tcp-timestamps-开启导致的问题" class="headerlink" title="内核参数 tcp_timestamps 开启导致的问题"></a>内核参数 tcp_timestamps 开启导致的问题</h2><blockquote>
<p>高版本内核中移除了同一dst的timestamp缓存tcp timestamp的offsets随机生成，集群内部访问到外部时，经过主机会做NAT，端口复用的时候就会出现timestamp 比对端期望的小，导致对端把数据包丢弃，从而无法建立连接。</p>
<p>cp: remove per-destination timestamp cache<br>Commit 8a5bd45f6616 (tcp: randomize tcp timestamp offsets for each connection)<br>randomizes TCP timestamps per connection.</p>
<p>解决办法：</p>
<ol>
<li>关闭内核中 net.ipv4.tcp_timestamps</li>
<li>关闭服务端内核配置： net.ipv4.tcp_tw_recycle (tcp_tw_resue?)</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之资源隔离</title>
    <url>/blog/2019/06/20/20190620225014.html</url>
    <content><![CDATA[<h1 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Linux Namespace是Linux内核提供的一个功能，它可以隔离一系列的系统资源，比如：PID,UserID,NetWork等。</p>
</blockquote>
<p>当前Linux内核一共实现了6种不同类型的Namespace:</p>
<table>
<thead>
<tr>
<th>Namespace类型</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<blockquote>
<p>Namespace 的API主要使用如下三个系统调用：</p>
<ol>
<li>clone() 创建新进程。根据系统调用参数来判断哪些Namespace被创建，而且它们的紫禁城也会被包含到这些Namespace中</li>
<li>unshare() 将进程移除某个Namespace</li>
<li>setns（） 将进程加入到Namespace中</li>
</ol>
</blockquote>
<h2 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h2><blockquote>
<p>UTS Namespace主要用来隔离 nodename和domainname两个系统标识，在UTS Namespace中，每个Namespace允许有自己的hostname。</p>
</blockquote>
<p>golang测试代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file : uts.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在代码目录下执行命令：<code>go run uts.go</code>，然后进入shell交互页面。</p>
<p>然后执行命令<code>echo $$</code>，打印出当前shell的进程id，然后再执行命令 <code>readlink /proc/$pid/ns/uts</code>，打印出的结果与直接在terminal中执行该命令结果是不一样的，说明已实现了uts隔离。</p>
<p>在该shell中修改hostname：<code>hostname -b test</code>，然后同时在该shell中和直接在terminal中打印<code>hostname</code>，发现两者不一致，说明在uts隔离的shell中对uts修改不会影响宿主机。</p>
</blockquote>
<h2 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h2><blockquote>
<p>IPC Namespace 用来隔离 信号量、消息队列和共享内存，每一个IPC Namespace的这些资源都是隔离的。<br>在上一版本的代码中略作修改：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: ipc.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC, <span class="comment">// 增加一个flag</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPC隔离测试：</p>
<p>首先在宿主机上打开一个shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看现有 ipc message queues</span></span><br><span class="line">root@master:~# ipcs -q</span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个message queue</span></span><br><span class="line">root@master:~# ipcmk -Q</span><br><span class="line">消息队列 id：0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后在查看一下</span></span><br><span class="line">root@master:~# ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line">0xfee7b418 0          root       644        0            0 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时能看到一个queue了，再使用另一个shell去运行程序： go run ipc.go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ipcs -q</span></span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由以上实验可以发现，在新建的Namespace里，看不到宿主机上创建的queue，说明IPC Namespace创建成功，IPC已经被隔离。</p>
</blockquote>
<h2 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h2><blockquote>
<p>PID Namespace是用来隔离进程ID的，同一个进程在不同的PID Namespace里可以有不同的PID，在docker容器里面，使用 <code>ps -ef</code>就会发现，容器内，前台运行的进程PID是1，但在容器外使用<code>ps -ef</code>却发现同一进程有不同的PID，这就是PID Namespace的功劳。</p>
</blockquote>
<p>测试代码，在上一节代码中增加一个CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: pid.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID,  <span class="comment">// add</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时打开两个shell，其中一个运行： <code>go run pid.go</code></p>
<p>在宿主机shell中执行命令： <code>ps -ef|grep pid.go</code>可以查到另一个shell中运行的go程序的pid，然后在另一个运行go程序的shell中执行命令: <code>echo $$</code>可以得到当前sh的pid，可以发现，在运行go程序的shell中其PID为1，而在宿主机看到该程序的PID不为1。说明PID已隔离。</p>
</blockquote>
<h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><blockquote>
<p>Mount Namespace 用来隔离各个进程看到的挂载点视图，在不同的Namespace中，看到的文件层次是不一样的，在Mount Namespace中调用mount() umount()仅影响当前Namespace的文件系统（注：Mount有传播模式，如果是share模式还是会影响到的，测试时设置private模式可避免影响）</p>
</blockquote>
<p>测试代码，在上一节基础上再增加一个CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: ns.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序： <code>go run ns.go</code></p>
<p>在程序shell中执行命令<code>mount --make-private /proc</code>，先修改挂载模式为private</p>
<p>修改 mount 之前，查看 /proc (<code>ls /proc</code>)目录发现里边文件有很多，然后执行命令：<code>mount -t proc proc /proc</code>，在查看 /proc目录，发现里边文件少了很多。此时使用 <code>ps -ef</code>查看系统进程，可以看到只有 <code>sh</code>进程和 <code>ps -ef</code>进程。说明Mount隔离成功。(注：/proc目录下有很多数字的目录，这些每个目录都代表一个进程，数字为进程的PID，里边存储着跟进程相关数据，Mount隔离和PID隔离配合，使得<code>ps -ef</code>命令查看到当前Namespace下的进程，且PID是从1开始编号的)</p>
<h2 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h2><blockquote>
<p>User Namespace主要是隔离用户的用户组ID，可以在宿主机上以一个非root用户运行创建一个User Namespace，并且在这个Namespace下创建root用户，且在namespace下有root权限。</p>
</blockquote>
<p>测试代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: user.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |</span><br><span class="line">			syscall.CLONE_NEWUSER,</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      syscall.Getuid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      syscall.Getgid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以普通用户执行：<code>go run user.go</code>，在shell中输入命令<code>id</code>，打印出：<code>uid=0(root) gid=0(root) 组=0(root),65534(nogroup)</code>，但当尝试列出 <code>/root</code>目录时，会提示权限不够。</p>
</blockquote>
<h2 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h2><blockquote>
<p>Network Namespace是用来隔离网络设备，IP地址端口等网络栈的Namespace。</p>
</blockquote>
<p>测试代码：在上一节代码基础上增加CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: network.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"mydocker/tools/logging"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line"></span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |</span><br><span class="line">			syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      syscall.Getuid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      syscall.Getgid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在宿主机上查看网络设备，<code>ifconfig</code>，可以看到很多个网络设备。</p>
<p>执行命令：<code>go run network.go</code>后，在查看网络设备，发现只有 lo 一个网络设备了，说明Network Namespace隔离成功。</p>
</blockquote>
<h1 id="Linux-Cgroup"><a href="#Linux-Cgroup" class="headerlink" title="Linux Cgroup"></a>Linux Cgroup</h1><blockquote>
<p>Linux Cgroup提供了对一组进程及将来子进程的资源限制、控制和统计的能力。</p>
</blockquote>
<h2 id="Cgroup的三个组件："><a href="#Cgroup的三个组件：" class="headerlink" title="Cgroup的三个组件："></a>Cgroup的三个组件：</h2><blockquote>
<ol>
<li>cgroup是对进程分组管理的一种机制，一个cgroup包含一组进程，并可以在这个cgroup上增加subsystem的各种参数配置，将一组进程和一组subsystem的系统参数关联起来</li>
<li>subsystem是一组资源控制的模块，一般包含以下几项：<ol>
<li>blkio：设置对块设备输入输出的访问控制</li>
<li>cpu：设置cgroup中进程的cpu被调度的策略</li>
<li>cpuacct：可以统计cgroup中进程的cpu占用</li>
<li>cpuset：在多核机器上设置cgroup中进程可以使用的cpu和内存</li>
<li>devices：控制cgroup中进程对设备的访问</li>
<li>freezer：用于挂起和恢复cgroup中的进程</li>
<li>memory：用于控制cgroup中进程的内存占用</li>
<li>net_cls：用于将cgroup中进程产生的网络包分类，以便Linux的tc(traffic controller)可以根据分类区分出来自某个cgroup的包并做限流或监控</li>
<li>net_prio：设置cgroup中进程产生的网络流量的优先级</li>
<li>ns：使cgroup中的进程在新的Namespace中fork新进程时，创建一个新的cgroup，这个cgroup包含新的Namespace中的进程</li>
</ol>
</li>
<li>hierarchy的功能是把一组cgroup串成一个树状结构，通过树状结构Cgroup可以做到集成</li>
</ol>
</blockquote>
<h2 id="三个组件相互关系"><a href="#三个组件相互关系" class="headerlink" title="三个组件相互关系"></a>三个组件相互关系</h2><blockquote>
<ol>
<li>系统在创建了新的hierarchy后，系统中所有进程都会加入这个hierarchy的cgroup根节点，这个cgroup根节点是hierarchy默认创建的</li>
<li>一个subsystem只能附加到一个hierarchy上</li>
<li>一个hierarchy能附加多个subsystem</li>
<li>一个进程可以作为多个cgroup成员，但这些cgroup必须在不同的hierarchy中</li>
<li>一个进程fork出子进程时，子进程和父进程是在同一个cgroup中，也可移到其他cgroup中</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker资源隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之镜像存储</title>
    <url>/blog/2019/06/16/20190616225014.html</url>
    <content><![CDATA[<h1 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h1><h2 id="什么是Union-File-System"><a href="#什么是Union-File-System" class="headerlink" title="什么是Union File System"></a>什么是Union File System</h2><blockquote>
<p>Union File System简称 UnionFS，是一种为Linux，FreeBSD，NetBSD操作系统设计的，把其他文件系统联合到一个挂载点的文件系统服务。它使用<code>branch</code>将不同文件和目录透明地覆盖，形成一个单一一致的文件系统。这些<code>branch</code>都是readonly或read-write的，当对这个虚拟后的联合文件系统进行写操作时，系统是真正写到了一个新的文件中，看起来这个虚拟的联合文件系统是对任何文件进行操作的，但实际上并未改变原来的文件，unionFS使用了写时复制技术。</p>
<p>写时复制（copy on write，简称CoW），也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。主要思想：如果一个资源是重复的，没有任何修改，这时并不需要立即创建一个新资源，这个资源可以被共享，一旦有写操作发生时，就会将该资源复制一份，而且写操作发生在新copy的资源上。通过这种方式，可以减少未修改资源复制带来的消耗和硬盘存储的消耗。</p>
</blockquote>
<h2 id="Aufs"><a href="#Aufs" class="headerlink" title="Aufs"></a>Aufs</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>aufs(Advanced multi layered unification filesystem)是一种支持联合挂载的文件系统，aufs将不同目录分层挂载到同一个目录下，每一层都是一个普通的文件系统。</p>
</blockquote>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><blockquote>
<p>当需要读写一个文件时，会从最顶层开始向下寻找，本层没有，则根据层之间的关系到下一层找，直到找到第一个文件并打开它。</p>
<p>当写入一个文件时，如果文件不存在，则在读写层新建一个，否则向上边一个过程一样从顶层开始查找，直到找到最近的文件，aufs会将其复制到读写层进行修改。</p>
<p>当删除一个文件时，若文件仅存在于读写层，则可以直接删除，否则删除其在读写层的北方，再在读写层创建一个whiteout文件来标识文件不存在。</p>
<p>当新建一个文件时，若文件在读写层存在whiteout文件，则先删除之再新建，否则直接新建。</p>
</blockquote>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Device Mapper是一种从逻辑设备到物理设备的映射框架，通过使用它，用户可以很方便地根据自己的需要制定实现存储资源的管理策略。</p>
<p>它主要包括3个概念：映射设备、映射表、目标设备。</p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote>
<p>docker使用Device Mapper的CopyOnWrite发生在块存储级别。Device mapper驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个叫用时分配。当要修改已有文件时，再使用CoW为容器快照分配块空间，将要修改的数据复制到在容器快照中新的块里再进行修改。Device mapper 驱动默认会创建一个100G的文件包含镜像和容器。每一个容器被限制在10G大小的卷内，可以自己配置调整。</p>
<p>DeviceMapper 根据使用的基础块设备是真正的块设备哈斯稀疏文件挂载的loop设备分为两种模式：direct-lvm模式和loop-lvm模式，两者性能差别很大。</p>
</blockquote>
<h2 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Overlay主要目录结构：lower，upper，work，merge：</p>
<ol>
<li>lower：在docker中用于存放镜像分层文件，只读。可以有多个</li>
<li>upper：在docker中用于存放修改的文件，新增、修改、删除等，对应docker存储的 diff目录</li>
<li>work：</li>
<li>merge：存放多个lower、upper合并后的文件和目录，对应docker的 merge目录</li>
</ol>
<p>对联合挂载在merge目录下的文件操作规则：</p>
<ol>
<li>新增：新增文件会直接将新增的文件写入到upper目录下</li>
<li>修改：如果对lower层中的文件修改，则会引起copy，文件copy到upper目录下，所有修改操作在upper目录下完成；如果对upper目录文件修改（包括新增的文件和已经从底层copy出的文件），则直接修改</li>
<li>删除：在upper目录中会对文件标记删除（使用ll查看文件标识为<code>c --- --- ---</code>，正常文件第一个标识位为-，目录为d），合并到merge目录下的效果为删除。</li>
</ol>
</blockquote>
<h3 id="大文件修改"><a href="#大文件修改" class="headerlink" title="大文件修改"></a>大文件修改</h3><blockquote>
<p>对lower层大文件修改时，会产生一个<code>.file.swp</code>（<code>.</code>前缀和<code>.swp</code>后缀）文件，修改文件在该文件操作，当执行保存时，首先将文件从lower层该文件复制到upper层中，命名为<code>file~</code>（在文件后加<code>~</code>后缀），然后将<code>file~</code>与<code>.file.swp</code>文件合并生成最终文件并删除<code>file~</code>。<br>本地测试显示，当保存文件时，新<code>file</code>和<code>file~</code>与<code>lower</code>层<code>file</code>曾同时共存。当文件从<code>file~</code> 完全copy到<code>file</code>时，会被删除。</p>
</blockquote>
<hr>
<blockquote>
<p>本地测试记录：<br>当使用vim打开大文件时，对应的upper目录中生成了 <code>.file.swp</code>文件，当对其编辑时，所有修改操作都在该文件中记录（随着新增内容，swp文件大小随之改变）；当执行保存时，<code>upper</code>中生成了<code>file~</code>文件，当该文件大小不再变动时查看大小，发现与lower层中文件大小一致，说明该文件为lower层文件的副本。</p>
<p>此过程与Linux写大文件操作基本一致：本地生成.swp文件，然后直接将源文件重命名为<code>file~</code>，再合并两者为最终文件，然后删除<code>file~</code>。在OverlayFS中区别为，<code>file~</code>文件在OverlayFS中是从底层复制的[当修改upper层文件时与Linux中写大文件操作一致]，而在Linux中写大文件时<code>file~</code>是直接把源文件重命名的</p>
</blockquote>
<h3 id="自己动手使用Overlay"><a href="#自己动手使用Overlay" class="headerlink" title="自己动手使用Overlay"></a>自己动手使用Overlay</h3><blockquote>
<p>实验环境：centos7，内核：4.4.169-1.el7.elrepo.x86_64</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">文件路径： /app/overlayfs-test</span><br><span class="line">目录结构：</span><br><span class="line">.</span><br><span class="line">├── layer1</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer2</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer3</span><br><span class="line">│   ├── 3.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer4</span><br><span class="line">│   ├── 4.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── mnt</span><br><span class="line">├── upper</span><br><span class="line">└── work</span><br><span class="line">   └── work</span><br><span class="line">文件内容： </span><br><span class="line">1. layer&#123;n&#125;/&#123;n&#125;.txt 内容里的内容为 n</span><br><span class="line">2. layer&#123;n&#125;/tmp.txt 内容里的内容为 n </span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t overlay -o lowerdir=/app/overlayfs-test/layer1:/app/overlayfs-test/layer2:/app/overlayfs-test/layer3:/app/overlayfs-test/layer4,upperdir=/app/overlayfs-test/upper,workdir=/app/overlayfs-test/work overlay /app/overlayfs-test/mnt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令格式： <code>(格式：mount -t overlay -o lowerdir=pwd1:pwd2,upperdir=pwd3,workdir=pwd4 overlay pwd5)</code></p>
<p>格式说明：命令中 <code>pwd{n}</code>部分均为变量，根据自己挂载情况修改，lowerdir=pwd1:pwd2，当pwd1和pwd2中有同名文件，则显示的是pwd1中的文件。upperdir指定了upper文件的目录，workdir指定了work目录，最后一个参数指定了merge目录。</p>
<p>执行后的目录结构：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── layer1</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer2</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer3</span><br><span class="line">│   ├── 3.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer4</span><br><span class="line">│   ├── 4.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── mnt</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   ├── 3.txt</span><br><span class="line">│   ├── 4.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── upper</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上， {n}.txt都挂载到了 mnt目录下，tmp.txt文件则只有一个，<code>cat mnt/tmp.txt</code>输出<code>1</code></p>
<p>在mnt目录新增文件<code>x.txt</code>输入x，删除<code>1.txt</code>，编辑<code>2.txt</code>输入x2，新的目录结构：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── layer1</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer2</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer3</span><br><span class="line">│   ├── 3.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── layer4</span><br><span class="line">│   ├── 4.txt</span><br><span class="line">│   └── tmp.txt</span><br><span class="line">├── mnt</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   ├── 3.txt</span><br><span class="line">│   ├── 4.txt</span><br><span class="line">│   ├── tmp.txt</span><br><span class="line">│   └── x.txt</span><br><span class="line">├── upper</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   ├── 2.txt</span><br><span class="line">│   └── x.txt</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br><span class="line">``` </span><br><span class="line">&gt; upper目录中，执行命令：</span><br><span class="line">&gt; </span><br><span class="line">```bash</span><br><span class="line">[root@node2 upper]# ll</span><br><span class="line">总用量 8</span><br><span class="line">c--------- 1 root root 0, 0 6月  16 23:36 1.txt</span><br><span class="line">-rw-r--r-- 1 root root    3 6月  16 23:36 2.txt</span><br><span class="line">-rw-r--r-- 1 root root    2 6月  16 23:36 x.txt</span><br><span class="line">[root@node2 upper]# cat 2.txt </span><br><span class="line">x2</span><br><span class="line">[root@node2 upper]# cat x.txt </span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，<code>1.txt</code>标记为删除，<code>2.txt</code>内容改为x2，<code>x.txt</code>是新增的文件</p>
<p>在<code>mnt</code>目录下，文件<code>1.txt</code>也确实被删除了，<code>x.txt</code>文件也添加进来了，<code>2.txt</code>内容也改为x2。反观<code>layer1</code>目录下，<code>1.txt</code>文件还存在，<code>layer2</code>目录中<code>2.txt</code>内容仍然为<code>2</code></p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker镜像存储</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码阅读00——client-go之-controller(+简单实现)</title>
    <url>/blog/2019/06/06/20190606154010.html</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简单介绍controller实现过程中涉及到的client-go中的几个组件，并尝试使用简单的方式手撸一个可以实现一个类似client-go中<code>controller</code>功能的demo。</p>
<p>注：本文client-go是从<code>kubernetes 1.13</code>的项目源码中拷贝出来的，文中标记的代码行数以此为准。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>NewIndexerInformer()是定义在<code>client-go/tools/cache/shared_informer</code>中的一个函数，返回值为<code>indexer,controller</code>，本文主要讲controller的功能实现(也会简单提到indexer)，它用来监听k8s集群中的某一种资源，针对资源对象的不同事件(add/update/delete)执行用户自定义的事件处理函数。</p>
<p>其在k8s中的应用十分广泛</p>
<ol>
<li>k8s里的系统组件：k8s调度器里通过监听pod资源对象来对其进行调度、k8s的kube-proxy通过监听service/endpoints资源对象的变化来配置各个节点的网络等等；</li>
<li><code>CRD</code></li>
<li>使用该组件对k8s中的资源进行状态监控(deployment、daemonSet、pod等)</li>
<li>使用该组件对k8s中的资源配额进行监控</li>
<li>其他</li>
</ol>
</blockquote>
<h1 id="controller-基本组成部分介绍"><a href="#controller-基本组成部分介绍" class="headerlink" title="controller 基本组成部分介绍"></a>controller 基本组成部分介绍</h1><blockquote>
<p>先讲几个在<code>controller</code>中引用到的几个结构体</p>
</blockquote>
<h2 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h2><blockquote>
<p>首先看一下如何<code>New</code>一个<code>Indexer</code>对象：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// client-go/tools/cache/store.go  line: 112</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">	cacheStorage ThreadSafeStore</span><br><span class="line">	<span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">	<span class="comment">// should be deterministic.</span></span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// client-go/tools/cache/store.go  line: 239</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注KeyFunc定义： type KeyFunc func(obj interface&#123;&#125;) (string, error)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，<code>NewIndexer</code>返回的是一个<code>cache</code>对象，而<code>cache</code>实现了<code>Indexer</code>接口。<br>再结合cache的定义可以知道，此处的<code>Indexer</code>就是一个线程安全的存储，<code>keyFunc</code>的作用就是给定一个对象，然后返回该对象的<code>key</code>值。暂时简单地理解<code>Indexer</code>不去深究其内部其他逻辑，将其视为一个线程安全的<code>map</code>存储即可，这个<code>map</code>的<code>key</code>值可以通过调用<code>keyFunc(val)</code>获得。</p>
</blockquote>
<h2 id="ListWatch"><a href="#ListWatch" class="headerlink" title="ListWatch"></a>ListWatch</h2><blockquote>
<p>首先看下 ListWatch的定义：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListWatch knows how to list and watch a set of apiserver resources.  It satisfies the ListerWatcher interface.</span></span><br><span class="line"><span class="comment">// It is a convenience function for users of NewReflector, etc.</span></span><br><span class="line"><span class="comment">// ListFunc and WatchFunc must not be nil</span></span><br><span class="line"><span class="keyword">type</span> ListWatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	ListFunc  ListFunc</span><br><span class="line">	WatchFunc WatchFunc</span><br><span class="line">	<span class="comment">// DisableChunking requests no chunking for this list watcher.</span></span><br><span class="line">	DisableChunking <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要包括两个函数对象(先不去理会DisableChunking)，<code>ListFunc</code>作用主要是列出k8s集群中的资源对象，<code>WatchFunc</code>作用主要是监听k8s集群中的资源对象。</p>
<p>先看下创建<code>ListWatch</code>的代码吧：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredListWatchFromClient</span><span class="params">(c Getter, resource <span class="keyword">string</span>, namespace <span class="keyword">string</span>, optionsModifier <span class="keyword">func</span>(options *metav1.ListOptions)</span>) *<span class="title">ListWatch</span></span> &#123;</span><br><span class="line">	listFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">		optionsModifier(&amp;options)</span><br><span class="line">		<span class="keyword">return</span> c.Get().</span><br><span class="line">			Namespace(namespace).</span><br><span class="line">			Resource(resource).</span><br><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span><br><span class="line">			Do().</span><br><span class="line">			Get()</span><br><span class="line">	&#125;</span><br><span class="line">	watchFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">		options.Watch = <span class="literal">true</span></span><br><span class="line">		optionsModifier(&amp;options)</span><br><span class="line">		<span class="keyword">return</span> c.Get().</span><br><span class="line">			Namespace(namespace).</span><br><span class="line">			Resource(resource).</span><br><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span><br><span class="line">			Watch()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;ListWatch&#123;ListFunc: listFunc, WatchFunc: watchFunc&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从代码中可用看到，这里创建了两个函数对象，ListFunc和WatchFunc，这两个函数返回的都是向apiserver发请求的对象，不过其发送请求的<code>Action</code>不同，一个是<code>Get</code>，一个是<code>Watch</code>，那ListWatch对象如何知道去Get/Watch哪个集群的资源对象呢，这个就是通过参数<code>c</code>来指定了，k8s的ClientSet实现了<code>Getter</code>接口，可以作为参数传进来。</p>
<p>到此处是不是感觉接触到了controller的核心部分了呢？到这里就算是比较接近底层的部分了，再向底层分析就是client-go向apiserver发请求和解析请求结果的部分了，深度上先到此为止<br>（在本篇中，我们不去关心更底层是如何Watch到资源的变化情况的，也不关心数据是怎么在client和apiserver中传输和解析的<br>只需知道ListWatch已经能够<code>Get</code>和<code>Watch</code>到集群的资源就够了）。</p>
</blockquote>
<h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><blockquote>
<p><code>DeltaFIFO</code>，从名字可以看出这是一个变化的队列，且是先进先出的队列。稍微解释一下，这个队列实际包含两层队列。先看下定义的这部分：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/delta_fifo.go  96行</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// line：104</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 补充一下Deltas的定义：</span></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType  <span class="comment">// 字符串，Added,Updated,Deleted等</span></span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先介绍一下 keyFunc，keyFunc和上边的Indexer里的keyFunc作用类似，都是根据对象返回一个key值，这里求得的key值主要用于 queue中的值，还有items这个map中的键值，从而，当从queue中取出队列头部元素时，可以根据这个元素值从items中取出对应的具体value</p>
<p>以下分析DeltaFIFO的两层队列实现：<br>首先，queue是一个队列，数组保存队列，也很容易实现先进先出，queue队列中元素出队时，从item中取出<code>items[queue[0]]</code>元素并删除，queue也删除0号元素即可完成队列的<code>Pop</code>操作。从Deltas的定义看到，这是一个Delta数组，<code>items[queue[0]]</code>也是一个队列，这个队列存的是Delta对象，既然它们存储在同一个<code>items[key]</code>下，那么表示它们是同一个资源对象的<code>Delta</code>，即：这个队列表示的是同一个对象的事件队列。</p>
<p>综上： queue表示的是不同资源对象的队列，items的value值表示的是同一资源对象的事件队列。</p>
<p>有点拗口，想象一下这个场景： 假设有3个pod资源对象，记为 a,b,c，</p>
<ol>
<li>a发生变化deltaA1，此时a加入到queue队列，a的变化事件加到items[a]这个事件队列</li>
<li>b发生变化deltaB1，此时b假如到queue队列，b的变化事件加到items[b]这个事件队列</li>
<li>a又发生变化deltaA2，此时items中已经存在items[a]了，表示a已经在队列queue中了，此时，获取到items[a]事件队列，然后将这次变化加入队列<br>此时，queue和items中的数据为：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue : [a,b]</span><br><span class="line">items : &#123;a:[deltaA1,deltaA2], b: [deltaB1]&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果上边步骤<code>3</code>发生时，queue已经执行过一次出队操作，那么：<br>a发生变化deltaA2时，items中items[a]不存在，表示a不在队列中，便将a加到queue队列，deltaA2加到items[a]这个事件队列中去。此时，queue和items中的数据为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue: [b,a]</span><br><span class="line">items: &#123;a:[deltaA2], b: [deltaB1]&#125;</span><br><span class="line">// 注意：items是map，其内部的`k-v`键值对不分先后顺序，只有v的值分先后顺序，因为v是数组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>讲了这么多，大概应该能明白DeltaFIFO的作用了吧，简单点说就是存储k8s资源对象变化事件的队列。</p>
</blockquote>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><h3 id="controller初始化"><a href="#controller初始化" class="headerlink" title="controller初始化"></a>controller初始化</h3><blockquote>
<p>在controller里，存储了ListWatch，objType(监听的资源对象类型)，ResourceEventHandler(资源事件handler)，DeltaFIFO，以及Process</p>
<p>代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/controller.go line:345</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexerInformer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	lw ListerWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">	objType runtime.Object,</span></span></span><br><span class="line"><span class="function"><span class="params">	resyncPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	h ResourceEventHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">	indexers Indexers,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(Indexer, Controller)</span></span> &#123;</span><br><span class="line">	<span class="comment">// This will hold the client state, as we know it.</span></span><br><span class="line">	<span class="comment">// 定义Indexer（线程安全的存储）</span></span><br><span class="line">	clientState := NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// This will hold incoming changes. Note how we pass clientState in as a</span></span><br><span class="line">	<span class="comment">// KeyLister, that way resync operations will result in the correct set</span></span><br><span class="line">	<span class="comment">// of update/delete deltas.</span></span><br><span class="line">	<span class="comment">// 定义FIFO（事件队列）</span></span><br><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		<span class="comment">// 将ListWatch对象赋值到cfg，传递给controller</span></span><br><span class="line">		ListerWatcher:    lw,</span><br><span class="line">		ObjectType:       objType,</span><br><span class="line">		FullResyncPeriod: resyncPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 资源对象变化处理函数，obj类型是Deltas，就是上边降到DeltaFIFO中 items这个map对象的value的数据类型</span></span><br><span class="line">        <span class="comment">// 这个函数是在 fifo.queue这个队列出队的时候调用</span></span><br><span class="line">		Process: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="comment">// from oldest to newest</span></span><br><span class="line">			<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">				<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">				<span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">				    <span class="comment">// 判断Indexer中是否有该元素，有则表示是更新操作，没有表示是新增操作</span></span><br><span class="line">				    <span class="comment">// 该判断逻辑一定对的前提：下边Add事件时，Indexer同步add，Delete事件时，同步delete</span></span><br><span class="line">				    <span class="comment">// 此时更新Indexer中的数据，并调用 h.OnUpdate</span></span><br><span class="line">				    <span class="comment">// Indexer中存储数据的更重要的一点是，本地存储新更新到来之前的最新版本资源对象，那么当更新事件到来时，客户端可以有新旧对象供handler使用</span></span><br><span class="line">					<span class="keyword">if</span> old, exists, err := clientState.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">						<span class="comment">// update Indexer</span></span><br><span class="line">						<span class="keyword">if</span> err := clientState.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> err</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 调用handler事件</span></span><br><span class="line">						h.OnUpdate(old, d.Object)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					    <span class="comment">// add to Indexer</span></span><br><span class="line">						<span class="keyword">if</span> err := clientState.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> err</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 调用handler事件</span></span><br><span class="line">						h.OnAdd(d.Object)</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">case</span> Deleted:</span><br><span class="line">				    <span class="comment">// delete from Indexer</span></span><br><span class="line">					<span class="keyword">if</span> err := clientState.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 调用handler事件</span></span><br><span class="line">					h.OnDelete(d.Object)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clientState, New(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller运行"><a href="#controller运行" class="headerlink" title="controller运行"></a>controller运行</h3><blockquote>
<p>controller启动方法是 controller.Run()，首先看下源码：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/controller.go line:100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line">    <span class="comment">// 此处启动一个协程，运行 r.Run函数</span></span><br><span class="line">    <span class="comment">// r.Run即Reflector对象的Run方法，定义在 client-go/tools/cache/reflector.go line:121</span></span><br><span class="line">	<span class="comment">// 通过查看 r.Run可以知道，它又运行了 r.ListAndWatch</span></span><br><span class="line">	<span class="comment">// r.ListAndWatch里的逻辑就是真正获取k8s资源对象</span></span><br><span class="line">	<span class="comment">// 在该函数中又调用r.watchHandler 来监控着资源的事件，并将其加到r.store中(在本文描述场景中，r.store即为DeltaFIFO)</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处启动processLoop循环处理事件</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列(DeltaFIFO)中取出数据，执行 process（前边在NewIndexerInformer中定义的process）</span></span><br><span class="line"><span class="comment">// c.config.Queue.Pop方法定义在：client-go/tools/cache/delta_fifo.go line:411</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 controller.Run方法，整个资源状态监控的过程就完成了。</p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>通过以上讲informer中使用到的各个组件的功能及作用，整个informer工作流程大概如下：</p>
<ol>
<li>首先调用ListWatch中的List方法，初步将k8s中待监听资源拉到本地，将其加到本地存储Indexer和事件队列DeltaFIFO中(初始化时将这些资源的变化事件看做是ADD)</li>
<li>异步1：使用ListWatch中Watch方法不断去监听事件，监听到后将其加到 DeltaFIFO中</li>
<li>异步1：无限循环：<ol>
<li>阻塞方法去从队列中取出数据（使用到了sync.cond）</li>
<li>取到的数据类型是 Deltas，调用 controller中的Process方法（上边的NewIndexerInformer里定义的）</li>
<li>// 在Process方法里调用用户自定义的handler</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p>以上过程讲的比较简单，实际client-go的代码中很多出错逻辑处理、同步数据、以及多协程时的数据存储优化。</p>
</blockquote>
<h1 id="手撸实现"><a href="#手撸实现" class="headerlink" title="手撸实现"></a>手撸实现</h1><blockquote>
<p>client-go中，controller 部分代码使用了很多接口，而且封装的太深，看它的源码时没那么容易。</p>
<p>基于以上对 controller 的分析，自己实现了一个比较简单的 controller，弄懂这个后再去深究 client-go的实现会事半功倍。</p>
<p>代码地址：<a href="https://github.com/geedchin/client-go-src-learning" target="_blank" rel="noopener">https://github.com/geedchin/client-go-src-learning</a><br>核心部分在 02_watch中</p>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s源码阅读</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s源码阅读</tag>
        <tag>client-go controller</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的理解与运用</title>
    <url>/blog/2019/05/23/20190523000154.html</url>
    <content><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><blockquote>
<p>堆是一种完全二叉树，且每个节点都大于等于（小于等于）其子节点的值。</p>
<p>大顶堆：每个节点都大于等于其子节点的堆<br>小顶堆：每个节点都小于等于其子节点的堆</p>
</blockquote>
<h1 id="如何存储堆"><a href="#如何存储堆" class="headerlink" title="如何存储堆"></a>如何存储堆</h1><blockquote>
<p>根据堆的定义，其为完全二叉树，则可以使用数组来存储堆。<br>使用数组存储堆相比于链式存储有以下优点：</p>
<ol>
<li>访问任意位置元素时间复杂度为O(1)</li>
<li>访问每个节点的子(父)节点耗时与链式存储几乎无差异。假如某节点在数组的索引是<code>x</code>,则其父节点索引为 <code>(x+1)/2-1</code>，左右子节点分别为<code>(x+1)*2-1</code>与<code>(x+1)*2</code></li>
<li>数组在内存中按顺序存储，对CPU更友好，缓存命中高</li>
</ol>
</blockquote>
<h1 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h1><blockquote>
<p>以下涉及堆均默认为小顶堆，大顶堆与其类似，只是判断大小逻辑需调整</p>
</blockquote>
<h2 id="向堆中增加元素"><a href="#向堆中增加元素" class="headerlink" title="向堆中增加元素"></a>向堆中增加元素</h2><blockquote>
<p>把新的元素放至堆的末位，为使其仍然符合堆的定义，则需要对其进行调整。<br>这个过程叫做堆化(heapify)：</p>
<p>将新元素与其父元素做比较，如果比父节点值小，则与父节点交换位置，以此类推，通过不断的与新父节点作比较与交换，最终到达合适的位置，正好满足堆的定义。</p>
<p>Go语言实现自下而上的堆化过程代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自下而上的堆化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        parent := (x+<span class="number">1</span>)/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> arr[x] &lt; arr[parent] &#123;</span><br><span class="line">            arr[x], arr[parent] = arr[parent], arr[x]</span><br><span class="line">        &#125;</span><br><span class="line">        x = parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><blockquote>
<p>从堆的定义中可知，对顶元素即为堆中的最小值，当删除该值时，需将剩下元素的最小值放到堆顶，而且其最小值必定是堆顶元素的子节点;<br>将最小值移上去后，还需填充该位置以满足其完全二叉树的性质，再去从该位置的子节点中找最小元素… 最终将堆中最后一行中的某个元素移到上一层，但此时可能不满足满二叉树的性质，又要将最后一个位置的值移到该位置（移了之后又可能不满足堆的性质，又要堆化），此过程还是比较麻烦的。</p>
<p>如果考虑将堆顶元素删除后，直接将最后一个元素移到此位置，则只需对其自上而下堆化即可:<br>0. 将堆顶元素删除，并将堆中最后一个元素放到堆顶</p>
<ol>
<li>从堆顶开始，将堆顶视为当前元素</li>
<li>比较当前元素与子节点元素的大小，取出最小的，如果最小的为本身，则直接结束；</li>
<li>否则，交换最小的子节点元素与当前元素值，</li>
<li>将最小子节点作为当前节点，重复2，直到当前节点为叶子节点</li>
</ol>
<p>Go语言实现自上而下的堆化过程代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify2</span><span class="params">(arr []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	arrLen := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		right := (n + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">		left := right - <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> left &gt;= arrLen &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		mini := n</span><br><span class="line">		<span class="comment">// 判断左右子节点，找出最小节点</span></span><br><span class="line">		<span class="keyword">if</span> right &lt; arrLen &amp;&amp; arr[right] &lt; arr[mini] &#123;</span><br><span class="line">			mini = right</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> arr[left] &lt; arr[mini] &#123;</span><br><span class="line">			mini = left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果最小节点是当前节点，则退出</span></span><br><span class="line">		<span class="keyword">if</span> mini == n &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小位置的值与当前位置交换</span></span><br><span class="line">		arr[mini], arr[n] = arr[n], arr[mini]</span><br><span class="line">		n = mini</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何基于堆实现排序"><a href="#如何基于堆实现排序" class="headerlink" title="如何基于堆实现排序"></a>如何基于堆实现排序</h1><blockquote>
<p>大致过程分为两步：建堆和排序</p>
</blockquote>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><blockquote>
<p>建堆有两种方法：</p>
<ol>
<li>堆中元素从1个不断增加，增加到指定长度，这个过程使用了自下向上的堆化过程。时间复杂度为O(nlg(n))</li>
<li>从数组中间开始遍历到数组0索引位置，对每个位置实行自上而下的堆化过程。时间复杂度O(n)</li>
</ol>
<p>第二种建堆方法Go实现：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitHeap</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	arrLen := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := arrLen/<span class="number">2</span> + <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(arr, i) <span class="comment">// 调前边的实现</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>不断从堆中取出最小值，取得数据的序列即为从小到大的排序结果</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveTop</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ret := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(arr)</span><br><span class="line">	arr[<span class="number">0</span>] = arr[<span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">	arr = arr[<span class="number">0</span> : <span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">	heapify(arr, <span class="number">0</span>) <span class="comment">// 调前边的实现</span></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>go接口中的‘陷阱’</title>
    <url>/blog/2019/04/10/20190410140732.html</url>
    <content><![CDATA[<h1 id="接口值陷阱"><a href="#接口值陷阱" class="headerlink" title="接口值陷阱"></a>接口值陷阱</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>接口值共有两部分组成：具体的类型、该类型的值。它们称之为接口值的动态类型和动态值。</p>
</blockquote>
<h2 id="接口值判断陷阱"><a href="#接口值判断陷阱" class="headerlink" title="接口值判断陷阱"></a>接口值判断陷阱</h2><blockquote>
<p>既然接口值有两部分组成，那么，接口值的相等性判断是否也要类型及值均相等才算相等呢？</p>
<p>答案是肯定的，以下两个示例：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公共部分</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123; &#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; &#125;</span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 均无方法，方便测试</span></span><br><span class="line"><span class="comment">// 可以看作Student Teacher都实现了 People接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1, p2 People</span><br><span class="line"><span class="keyword">var</span> s *Student</span><br><span class="line"><span class="keyword">var</span> t *Teacher</span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>, t == <span class="literal">nil</span>) <span class="comment">// true true</span></span><br><span class="line">p1 = s</span><br><span class="line">p2 = t</span><br><span class="line">fmt.Println(p1 == p2) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// p1 p2 值均为空，但其类型不同，因此判断相等结果为false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 People</span><br><span class="line"><span class="keyword">var</span> s *Student</span><br><span class="line">fmt.Println(p1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br><span class="line">p1 = s</span><br><span class="line">fmt.Println(p1 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// p1 值为nil，但类型不为nil，所以p1与nil做相等比较结果false</span></span><br><span class="line"><span class="comment">// 此处要注意，在函数中用接口类型做为形参时，如果直接将其与nil做比较来判断其是否为空，可能会有意想不到的结果，且不易排查</span></span><br></pre></td></tr></table></figure>

<h1 id="接口不同实现方式"><a href="#接口不同实现方式" class="headerlink" title="接口不同实现方式"></a>接口不同实现方式</h1><ol>
<li>使用指针接收者实现</li>
<li>使用类型接收者实现</li>
</ol>
<h2 id="指针接收者实现"><a href="#指针接收者实现" class="headerlink" title="指针接收者实现"></a>指针接收者实现</h2><blockquote>
<p>使用指针接收者实现，则只有该实体类型的指针实现了该接口。<br>不能将实体类型的值赋值给该接口类型变量。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHello()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Student)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p People</span><br><span class="line">	<span class="comment">// p =  Student&#123;&#125; // 编译报错</span></span><br><span class="line">	p = &amp;Student&#123;&#125;</span><br><span class="line">	p.SayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型接收者实现"><a href="#类型接收者实现" class="headerlink" title="类型接收者实现"></a>类型接收者实现</h2><blockquote>
<p>能够将实体类型和实体类型的指针赋值给接口类型变量。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHello()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Student)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p People</span><br><span class="line">	p =  Student&#123;&#125;</span><br><span class="line">	p.SayHello()</span><br><span class="line">	p = &amp;Student&#123;&#125;</span><br><span class="line">	p.SayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go接口</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言接口简介</title>
    <url>/blog/2019/04/10/20190410133551.html</url>
    <content><![CDATA[<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><br> 

<blockquote>
<p>接口是一种描述一类事物具有相同操作的抽象：即某一类的事物都具有相同的操作合集。</p>
</blockquote>
<h2 id="go接口"><a href="#go接口" class="headerlink" title="go接口"></a>go接口</h2><br> 

<blockquote>
<p>在大多数语言中，实现某接口必须用 implement 显示地声明自己实现的是声明接口，而在go语言中，则无需声明实现接口，这种特性可称之为 <code>duck typing</code>。<br>比如，假设一只鸭子类型的接口有 <code>游泳</code> <code>呱呱叫</code> <code>走路</code> 等方法，任何一个对象如果包含这些方法，我们可以认为它是鸭子。</p>
</blockquote>
<h2 id="go接口类型"><a href="#go接口类型" class="headerlink" title="go接口类型"></a>go接口类型</h2><br> 

<blockquote>
<p>在go语言中，可以定义接口类型，它描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。<br>有点抽象，可以这么理解：现在定义一个接口类型叫 <code>Animal</code>，其包含方法 <code>Breath</code>，那么所有包含 <code>Breath</code>方法的具体类型可视为一个<code>Animal</code>的实例。</p>
<p>接口类型还可以嵌套，例如，go自带io包里的接口 <code>io.Writer</code>、<code>io.Reader</code>、<code>io.ReadWriter</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Writer interface&#123;</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line">type Reader interface &#123;</span><br><span class="line">	Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><br> 

<blockquote>
<p>一个类型如果拥有一个接口的所有方法，那么这个类型就实现了这个接口。</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile</title>
    <url>/blog/2019/04/01/20190401023114.html</url>
    <content><![CDATA[<p>#逐步介绍 Dockerfile里的命令</p>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><code>ENV</code></h2><blockquote>
<p>格式： <code>ENV &lt;key&gt; &lt;val&gt;</code> 或 ENV <code>&lt;key&gt;=&lt;val&gt; ...</code></p>
<p><code>ENV</code>指令可以为镜像创建出来的容器声明环境变量，可被后边的指令解释使用，<br>使用格式为 <code>$variable_name</code>或<code>${variable_name}</code>。如果是带<code>$</code>的字符串，可使用<code>\</code>来转义。</p>
</blockquote>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><blockquote>
<p>格式： <code>FROM &lt;image&gt;</code> 或 <code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<p><code>FROM</code>指令为后边的指令提供基础镜像</p>
</blockquote>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><code>COPY</code></h2><blockquote>
<p>格式:  <code>COPY &lt;src&gt; &lt;dest&gt;</code></p>
<p><code>COPY</code>指令复制<code>&lt;src&gt;</code>所指向的文件或目录，将它添加到新镜像中，<code>src</code>所指向的源必须在上下文中。</p>
<p><code>context</code>上下文： 当构建镜像时，会执行 <code>docker build PATH|-|URL</code>命令，最后的<code>PATH|-|URL</code>即为上下文环境，在构建过程中，<br><code>docker</code>程序会将指定目录的所有文件(可用.dockerignore文件来忽略文件)复制到构建环境(实际是由docker-client提交到daemon去构建镜像)，这些文件作为构建镜像的上下文。</p>
<p>可同时拷贝多个文件，如 <code>COPY src1 src2 workdir/</code>，如果<code>src1</code>,<code>src2</code>是目录，则执行时会将<code>src1</code>,<code>src2</code>两个目录下的文件复制到 <code>workdir/</code>中去。</p>
</blockquote>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><code>ADD</code></h2><blockquote>
<p>格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code><br><code>ADD</code>与<code>COPY</code> 功能上很相似，都支持将本地文件复制到镜像中，但<code>ADD</code>还支持其他功能，<br><code>src</code>可以是一个指向网络文件的 URL，此时若<code>dest</code>指向目录，则URL必须是完全路径；还可以是本地压缩归档文件，该文件复制到容器时会被解压提取，但URL中的归档文件不会被解压。</p>
<p>推荐使用<code>COPY</code>，相比之下它更透明</p>
</blockquote>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><code>RUN</code></h2><blockquote>
<p>两种格式：</p>
<ol>
<li><code>RUN &lt;command&gt;</code> shell格式</li>
<li><code>RUN [&quot;exec&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> exec格式</li>
</ol>
</blockquote>
<blockquote>
<p>RUN命令会在前一条命令创建的镜像基础上创建一个容器，并在容器中运行命令，在命令结束后提交容器为新镜像，新镜像被Dockerfile中的下一条指令使用。</p>
<p>当使用shell格式，时，命令通过 <code>/bin/sh -c</code>运行，当使用exec格式时，命令是直接运行的，exec中参数会被当成json数组解析，因此必须使用双引号。因为其不在shell中执行，因此环境变量不会被替换。如果希望运行shell程序，可写成<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;progress&quot;]</code></p>
</blockquote>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><code>CMD</code></h2><blockquote>
<p>三种格式：</p>
<ol>
<li><code>CMD &lt;command&gt;</code> shell格式</li>
<li><code>CMD [&quot;exec&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> exec格式，推荐</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 为ENTRYPOINT指令提供参数</li>
</ol>
<p>可以有多条CMD命令，但只有一条会被执行。前两种执行方式一致，但执行时机不通：RUN 是在构建过程中执行命令并生成新镜像，CMD 在构建时不执行而是在容器启动时作为第一条命令执行。<br>使用第三种格式时，会将值作为参数传给ENTRYPOINT指令</p>
</blockquote>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a><code>ENTRYPOINT</code></h2><blockquote>
<p>两种格式：</p>
<ol>
<li><code>ENTRYPOINT &lt;command&gt;</code> shell格式</li>
<li><code>ENTRYPOINT [&quot;exec&quot;,&quot;param&quot;]</code> exec格式，推荐</li>
</ol>
<p><code>ENTRYPOINT</code>与<code>CMD</code>命令类似，都可以让容器在启动时执行相同的命令，但又有区别。<code>ENTRYPOINT</code>指令可以有多条，但只有最后一条有效，当使用shell格式时，<br>会忽略所有<code>CMD</code>指令和<code>docker run</code>参数，并运行在 <code>/bin/sh -c</code>中，这意味着该指令进程是 <code>/bin/sh -c</code>的子进程，在容器中的PID将不再是1，且不能接受UNIX信号，即使使用<code>docker stop</code>命令，也收不到SIGTERM信号。</p>
</blockquote>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a><code>ONBUILD</code></h2><blockquote>
<p>格式： <code>ONBUILD [INSTRUCTION]</code></p>
<p>添加一个将来执行的触发器指令到镜像中，当该镜像作为FROM指令的参数时，这些触发器指令就会在FROM指令执行时假如到构建过程中。</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s网络插件——flannel</title>
    <url>/blog/2019/01/10/20190110150506.html</url>
    <content><![CDATA[<h1 id="pod容器间通信"><a href="#pod容器间通信" class="headerlink" title="pod容器间通信"></a>pod容器间通信</h1><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>功能组件</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s网络</tag>
        <tag>flannel</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-ha 搭建</title>
    <url>/blog/2019/01/07/20190107123609.html</url>
    <content><![CDATA[<h1 id="机器准备"><a href="#机器准备" class="headerlink" title="机器准备"></a>机器准备</h1><blockquote>
<p>6台虚拟机<br>IP地址：</p>
<ol>
<li>10.1.1.10~12</li>
<li>10.1.1.20~22</li>
</ol>
<p>内核：4.4.169-1.el7.elrepo.x86_64（3.10以上能装docker都可）  </p>
</blockquote>
<h1 id="基本软件安装"><a href="#基本软件安装" class="headerlink" title="基本软件安装"></a>基本软件安装</h1><h2 id="keepalived安装"><a href="#keepalived安装" class="headerlink" title="keepalived安装"></a>keepalived安装</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="ssh实现集群机器间互相访问"><a href="#ssh实现集群机器间互相访问" class="headerlink" title="ssh实现集群机器间互相访问"></a>ssh实现集群机器间互相访问</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><blockquote>
<p>本文用的<code>docker</code>版本：19.03.0-ce<br>过程：略<br>安装成功后继续下一步</p>
</blockquote>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><blockquote>
<p>进入 <code>step2-conf</code> 目录下，执行 <code>basic_conf.sh</code>（脚本代码如下，加了注释）：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置docker开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙并关闭开机启动</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久关闭 selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed "s/^SELINUX=enforcing$/SELINUX=disabled/g" /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭swap</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络设置</span></span><br><span class="line">swapoff -a</span><br><span class="line">yes|cp /etc/fstab /etc/fstab.bak</span><br><span class="line">cat /etc/fstab.bak |grep -v swap &gt; /etc/fstab</span><br><span class="line"></span><br><span class="line">echo '''</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness=0''' &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 ipvs的依赖模块</span></span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ipset 和ipvsadm</span></span><br><span class="line">yum install -y ipset</span><br><span class="line">yum install -y ipvsadm</span><br></pre></td></tr></table></figure>

<h2 id="导入系统镜像"><a href="#导入系统镜像" class="headerlink" title="导入系统镜像"></a>导入系统镜像</h2><blockquote>
<p>k8s集群master需要镜像：kube-apiserver  kube-controller-manager   kube-scheduler kube-proxy pause，根据安装k8s版本选取对应版本的镜像<br>k8s 组件安装：<br>master节点组件： kubeadm、kubectl、kubelet、<br>node节点组件： kubelet</p>
<p>配置开机启动<code>kubelet</code> </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
<h2 id="安装外部etcd集群（不使用kubeadm自动生成的etcd）"><a href="#安装外部etcd集群（不使用kubeadm自动生成的etcd）" class="headerlink" title="安装外部etcd集群（不使用kubeadm自动生成的etcd）"></a>安装外部etcd集群（不使用kubeadm自动生成的etcd）</h2><h3 id="安装cfslsl工具"><a href="#安装cfslsl工具" class="headerlink" title="安装cfslsl工具"></a>安装cfslsl工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget -O /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget -O /usr/local/bin/cfssl-certinfo  https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">for cfssl in `ls /usr/local/bin/cfssl*`;do chmod +x $cfssl;done;</span><br></pre></td></tr></table></figure>
<h3 id="生成etcd证书："><a href="#生成etcd证书：" class="headerlink" title="生成etcd证书："></a>生成etcd证书：</h3><blockquote>
<p>根据实际情况修改shell中的hosts</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gen-cert.sh</span></span><br><span class="line"></span><br><span class="line">mkdir -p /opt/etcd/&#123;ssl,bin,cfg&#125;</span><br><span class="line">cd /opt/etcd/ssl</span><br><span class="line"><span class="meta">#</span><span class="bash"> ca config</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br><span class="line">cat &gt; ca-config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  "signing": &#123;</span><br><span class="line">    "default": &#123;</span><br><span class="line">      "expiry": "87600h"</span><br><span class="line">    &#125;,</span><br><span class="line">    "profiles": &#123;</span><br><span class="line">      "www": &#123;</span><br><span class="line">         "expiry": "87600h",</span><br><span class="line">         "usages": [</span><br><span class="line">            "signing",</span><br><span class="line">            "key encipherment",</span><br><span class="line">            "server auth",</span><br><span class="line">            "client auth"</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ca csr config</span></span><br><span class="line">cat &gt; ca-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    "CN": "etcd CA",</span><br><span class="line">    "key": &#123;</span><br><span class="line">        "algo": "rsa",</span><br><span class="line">        "size": 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    "names": [</span><br><span class="line">        &#123;</span><br><span class="line">            "C": "CN",</span><br><span class="line">            "L": "SZ",</span><br><span class="line">            "ST": "SZ"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gen</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据实际情况修改hosts</span></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line">cat &gt; server-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    "CN": "etcd",</span><br><span class="line">    "hosts": [</span><br><span class="line">      "10.1.1.10",</span><br><span class="line">      "10.1.1.20",</span><br><span class="line">      "10.1.1.21"</span><br><span class="line">    ],</span><br><span class="line">    "key": &#123;</span><br><span class="line">        "algo": "rsa",</span><br><span class="line">        "size": 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    "names": [</span><br><span class="line">        &#123;</span><br><span class="line">            "C": "CN",</span><br><span class="line">            "L": "SZ",</span><br><span class="line">            "ST": "SZ"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ca.csr            <span class="comment">#ca证书签名请求</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ca.pem            <span class="comment">#ca证书（公钥）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ca-key.pem      <span class="comment">#ca私钥</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> server.csr        <span class="comment">#server证书签名请求</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> server.pem        <span class="comment">#server证书（公钥）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> server-key.pem    <span class="comment">#server私钥</span></span></span><br></pre></td></tr></table></figure>

<h3 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h3><h4 id="节点1："><a href="#节点1：" class="headerlink" title="节点1："></a>节点1：</h4><blockquote>
<p>从github上下载etcd的release版本，解压后进入目录，将etcd二进制文件复制到 /opt/etcd/bin 目录下</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">cp bin/etcd bin/etcdctl /opt/etcd/bin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装脚本 install-etcd.sh：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> example: ./etcd.sh etcd01 IP1 etcd02=https://IP2:2380,etcd03=https://IP3:2380</span></span><br><span class="line"></span><br><span class="line">ETCD_NAME=$1</span><br><span class="line">ETCD_IP=$2</span><br><span class="line">ETCD_CLUSTER=$3</span><br><span class="line"></span><br><span class="line">WORK_DIR=/opt/etcd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建etcd配置文件</span></span><br><span class="line">cat &lt;&lt;EOF &gt;$WORK_DIR/cfg/etcd</span><br><span class="line"><span class="meta">#</span><span class="bash">[Member]</span></span><br><span class="line">ETCD_NAME="$&#123;ETCD_NAME&#125;"</span><br><span class="line">ETCD_DATA_DIR="/var/lib/etcd/default.etcd" # </span><br><span class="line">ETCD_LISTEN_PEER_URLS="https://$&#123;ETCD_IP&#125;:2380"</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS="https://$&#123;ETCD_IP&#125;:2379"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS="https://$&#123;ETCD_IP&#125;:2380"</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS="https://$&#123;ETCD_IP&#125;:2379"</span><br><span class="line">ETCD_INITIAL_CLUSTER="etcd01=https://$&#123;ETCD_IP&#125;:2380,$&#123;ETCD_CLUSTER&#125;"</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE="new"</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建systemctl服务管理etcd</span></span><br><span class="line">cat &lt;&lt;EOF &gt;/usr/lib/systemd/system/etcd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=$&#123;WORK_DIR&#125;/cfg/etcd</span><br><span class="line">ExecStart=$&#123;WORK_DIR&#125;/bin/etcd \</span><br><span class="line">--name=\$&#123;ETCD_NAME&#125; \</span><br><span class="line">--data-dir=\$&#123;ETCD_DATA_DIR&#125; \</span><br><span class="line">--listen-peer-urls=\$&#123;ETCD_LISTEN_PEER_URLS&#125; \</span><br><span class="line">--listen-client-urls=\$&#123;ETCD_LISTEN_CLIENT_URLS&#125;,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls=\$&#123;ETCD_ADVERTISE_CLIENT_URLS&#125; \</span><br><span class="line">--initial-advertise-peer-urls=\$&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125; \</span><br><span class="line">--initial-cluster=\$&#123;ETCD_INITIAL_CLUSTER&#125; \</span><br><span class="line">--initial-cluster-token=\$&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125; \</span><br><span class="line">--initial-cluster-state=new \</span><br><span class="line">--cert-file=$&#123;WORK_DIR&#125;/ssl/server.pem \</span><br><span class="line">--key-file=$&#123;WORK_DIR&#125;/ssl/server-key.pem \</span><br><span class="line">--peer-cert-file=$&#123;WORK_DIR&#125;/ssl/server.pem \</span><br><span class="line">--peer-key-file=$&#123;WORK_DIR&#125;/ssl/server-key.pem \</span><br><span class="line">--trusted-ca-file=$&#123;WORK_DIR&#125;/ssl/ca.pem \</span><br><span class="line">--peer-trusted-ca-file=$&#123;WORK_DIR&#125;/ssl/ca.pem</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable etcd</span><br><span class="line">systemctl restart etcd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处我使用的IP是 10.1.1.10-12 ，所以执行命令就是 <code>./install-etcd.sh etcd01 10.1.1.10 etcd02=https://10.1.1.11:2380,etcd03=10.1.1.12:2380</code></p>
</blockquote>
<h4 id="节点2、3"><a href="#节点2、3" class="headerlink" title="节点2、3"></a>节点2、3</h4><blockquote>
<p>将etcd执行文件及配置复制到其他两个节点：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /opt/etcd/  root@10.1.1.11:/opt/etcd/</span><br><span class="line">scp -r /opt/etcd/  root@10.1.1.12:/opt/etcd/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@10.1.1.11:/usr/lib/systemd/system/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@10.1.1.12:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改配置：</p>
<ol>
<li>修改/opt/etcd/cfg/etcd 配置文件，MEMBER配置块内容改为该节点自身的配置</li>
<li>Clustering配置块中，ETCD_INITIAL_ADVERTISE_PEER_URLS  ETCD_ADVERTISE_CLIENT_URLS 的IP改成当前机器的IP</li>
</ol>
</blockquote>
<h4 id="节点状态查看"><a href="#节点状态查看" class="headerlink" title="节点状态查看"></a>节点状态查看</h4><blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=https://10.1.1.10:2379 member list</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果显示：<br>66a8527f13b8fecc, started, etcd03, <a href="https://10.1.1.12:2380" target="_blank" rel="noopener">https://10.1.1.12:2380</a>, <a href="https://10.1.1.12:2379" target="_blank" rel="noopener">https://10.1.1.12:2379</a><br>a6a292fe93a0085d, started, etcd01, <a href="https://10.1.1.10:2380" target="_blank" rel="noopener">https://10.1.1.10:2380</a>, <a href="https://10.1.1.10:2379" target="_blank" rel="noopener">https://10.1.1.10:2379</a><br>da873601634f4a11, started, etcd02, <a href="https://10.1.1.11:2380" target="_blank" rel="noopener">https://10.1.1.11:2380</a>, <a href="https://10.1.1.11:2379" target="_blank" rel="noopener">https://10.1.1.11:2379</a></p>
</blockquote>
<h2 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h2><blockquote>
<p>进入 /etc/kubernetes 目录，<code>vim kubeadm-config.yaml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.2</span></span><br><span class="line"><span class="attr">controlPlaneEndpoint:</span> <span class="string">"10.1.1.10:6443"</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">certSANs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.12</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">k8s.local</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">external:</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.10:2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.11:2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.12:2379</span></span><br><span class="line">    <span class="attr">caFile:</span> <span class="string">/opt/etcd/ssl/ca.pem</span></span><br><span class="line">    <span class="attr">certFile:</span> <span class="string">/opt/etcd/ssl/server.pem</span></span><br><span class="line">    <span class="attr">keyFile:</span> <span class="string">/opt/etcd/ssl/server-key.pem</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">ipvs</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行初始化命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --config /etc/kubernetes/kubeadm-config.yaml --upload-certs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令执行完会生成两个带token 的join命令</p>
<ol>
<li>kubeadm join xxxx –control-plane xxxx</li>
<li>kubeadm join xxxx<br>分别用于master节点、node节点加入集群。当加入master节点时如果报证书错误，把执行init节点的 /etc/kubernetes/pki 文件夹复制到待加入的master节点。</li>
</ol>
</blockquote>
<h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><h2 id="初始化集群失败后，清理etcd数据："><a href="#初始化集群失败后，清理etcd数据：" class="headerlink" title="初始化集群失败后，清理etcd数据："></a>初始化集群失败后，清理etcd数据：</h2><blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=https://10.1.1.10:2379  del /  --prefix</span><br></pre></td></tr></table></figure>


<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>[1]. <a href="https://www.cnblogs.com/LouisZJ/articles/11178153.html" target="_blank" rel="noopener">etcd集群安装</a></p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s高可用搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine(1)</title>
    <url>/blog/2019/01/06/20190106083354.html</url>
    <content><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote>
<p>介绍协程之前，首先回顾一下进程与线程</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote>
<p><red>进程</red>： 通俗点讲，进程就是一个程序运行的实例，进程拥有自己运行时打开的各种资源和独立的内存空间。每个进程通过PCB（process control block）来保存自己的基本信息（在Linux中，该结构叫task_struct）<br>PCB包含了进程运行的基本信息：标示符、状态、优先级、程序计数器、内存指针、上下文、IO信息、记账信息等  </p>
<p><red>线程</red>： 线程属于进程，是程序的实际执行者，一个程序可以包含多个线程，线程具有自己的栈空间，其基本信息存储在TCB（thread control block）  </p>
<p>对OS来说，进程是最小的资源管理单元，线程是最小的执行单元</p>
<p>线程切换比进程切换更加轻量：线程进程切换时，都会调用内核切换上下文，不同进程之间内存空间相互独立，而不同线程之间共享进程的内存空间，因此线程上下文切换效率更高</p>
<p>进程和线程的切换都是抢占式的，由OS管理</p>
</blockquote>
<h2 id="go语言协程"><a href="#go语言协程" class="headerlink" title="go语言协程"></a>go语言协程</h2><blockquote>
<p>协程,是一种比线程更轻量级的运行单元。<br>主要特点：</p>
<ol>
<li>轻量级“线程”</li>
<li>非抢占式多任务处理，由协程调度器来调度任务也可主动交出控制权</li>
<li>编译器、解释器、虚拟机层面的多任务</li>
<li>多个协程可以在一个或多个线程上运行</li>
</ol>
</blockquote>
<h3 id="非抢占式测试"><a href="#非抢占式测试" class="headerlink" title="非抢占式测试"></a>非抢占式测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束时间大于2秒，因为是非抢占式，main的协程无法及时得到执行</span></span><br><span class="line"><span class="comment">// 打印属于IO操作，执行打印时会释放CPU资源给其他协程使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_01</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				fmt.Println(x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该程序不会退出，执行到最后一行打印之前，启动了4个协程，这些协程均不会释放CPU资源，没有空闲的线程用于主协程执行，因此不会退出</span></span><br><span class="line"><span class="comment">// 当启动的协程数 &lt; runtime.NumCPU() ，可以正常退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_02</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// N值要大于等于机器支持线程数（大于等于runtime.NumCPU()）</span></span><br><span class="line">	<span class="comment">// 测试机为2核4线程，这里设置成4</span></span><br><span class="line">	<span class="keyword">const</span> N = <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> a [N]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[x]++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此处休眠1秒是为了让前边循环中的协程都启动</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主动交出控制权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_03</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">const</span> N = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> a [N]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[x]++</span><br><span class="line">				<span class="comment">// 主动交出控制权</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>任何函数只要加上<code>go</code>就可以交给调度器执行</li>
<li>调度器会在指定的点进行切换<br> 可能切换点：（可能切换）<ol>
<li>IO,select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用(当协程运行过长时会打标记，在函数调用时检测标记并根据标记决定是否调度)</li>
<li>runtime.Gosched()</li>
<li>系统调用</li>
</ol>
</li>
<li>可以通过使用 <code>-race</code>参数来进行数据多线程的读写竞争进行检测 </li>
</ol>
</blockquote>
<h1 id="go语言协程模型"><a href="#go语言协程模型" class="headerlink" title="go语言协程模型"></a>go语言协程模型</h1><!--[图片来源](https://stackoverflow.com/questions/48638663/what-is-relationship-between-goroutine-and-thread-in-kernel-and-user-state)
-->
<h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><blockquote>
<p>如下图，go语言协程的模型<br><img src="/resources/post_pic/2019/01/goroutine_model.jpg" alt="go协程模型" title="go协程模型"></p>
</blockquote>
<blockquote>
<ol>
<li>M：系统线程（内核线程）</li>
<li>P：执行Go协程所必须的资源（上下文环境，逻辑处理器）</li>
<li>G：Go协程  </li>
</ol>
<p>可以把<code>Go协程</code>视为“用户线程”，它由用户态的Go调度器来实现在P上的调度，由于P中的协程队列同处于一个上下文环境（在同一个线程）没有内核切换的开销。调度器通过将Go协程映射到内核线程中，使程序运行时“看起来”是在并发执行。</p>
<p>由于Go协程是非抢占式的，而且基本在指定的几种情况下才会释放CPU，所以在协程之间切换时程序上下文复制开销较小且不用进行内核调用，因此更轻量级。</p>
</blockquote>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><blockquote>
<p>在并发执行程序时，调度器除了正常从协程队列里取出协程放到自己的执行队里中外，还有其他的执行调度行为：</p>
<ol>
<li>Work-sharing：当处理器生成新线程时，它会尝试着将一些工作任务交给其他闲置的线程执行，充分利用资源</li>
<li>Work-stealing：调度器主动“偷取”其他线程上执行任务来执行</li>
</ol>
</blockquote>
<blockquote>
<p>在Go语言中有一个<code>global goroutine queue</code>，每个内核线程又有一个<code>local goroutine queue</code>，<br>对于每一个内核线程来说，在该线程上等待执行的协程是串行的，而对于外部来说，这些协程是并发的。</p>
<p>协程之于内核线程，有点像进程之于CPU（单核CPU上对于CPU来说进程是串行的，对于外部来说是并行的）</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>列表(list)——可快速增删的非连续空间的容器</title>
    <url>/blog/2018/12/23/20181223104815.html</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element is an element of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line">	<span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line">	<span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line">	<span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line">	<span class="comment">// element (l.Front()).</span></span><br><span class="line">	next, prev *Element</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The list to which this element belongs.</span></span><br><span class="line">	list *List</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The value stored with this element.</span></span><br><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List represents a doubly linked list.</span></span><br><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line">	<span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>Element</code>，封装保存在<code>list</code>中的值，  <ol>
<li><code>Element</code>中的变量<code>next</code>,<code>prev</code>是指针，分别指向当前元素的下一个元素与前一个元素  </li>
<li><code>Element</code>中的变量<code>list</code>是指针，指向该<code>Element</code>所属的<code>list</code></li>
<li><code>Value</code>存储的为<code>List</code>中存放的值</li>
</ol>
</li>
<li><code>List</code>，<code>list</code>本身<ol>
<li><code>List</code>中的变量<code>root</code>变量存储着<code>List</code>中的第一个元素，该元素<code>Value</code>为<code>nil</code>，只做为根，不存储数据</li>
<li><code>List</code>中的变量<code>len</code>变量表示<code>List</code>的长度</li>
</ol>
</li>
<li>本质就是数据结构中的双向循环链表</li>
</ol>
</blockquote>
<h1 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h1><h2 id="Remove-e-Element"><a href="#Remove-e-Element" class="headerlink" title="Remove(e *Element)"></a><code>Remove(e *Element)</code></h2><blockquote>
<p>移除元素</p>
</blockquote>
<h2 id="PushFront-v-interface"><a href="#PushFront-v-interface" class="headerlink" title="PushFront(v interface{})"></a><code>PushFront(v interface{})</code></h2><blockquote>
<p>在列表头部增加元素</p>
</blockquote>
<h2 id="PushBack-v-interface"><a href="#PushBack-v-interface" class="headerlink" title="PushBack(v interface{})"></a><code>PushBack(v interface{})</code></h2><blockquote>
<p>在列表尾部增加元素</p>
</blockquote>
<h2 id="InsertBefore-v-interface-mark-Element-Element"><a href="#InsertBefore-v-interface-mark-Element-Element" class="headerlink" title="InsertBefore(v interface{},mark *Element)*Element"></a><code>InsertBefore(v interface{},mark *Element)*Element</code></h2><blockquote>
<p>在<code>mark</code>前增加元素</p>
</blockquote>
<h2 id="InsertAfter-v-interface-mark-Element-Element"><a href="#InsertAfter-v-interface-mark-Element-Element" class="headerlink" title="InsertAfter(v interface{},mark *Element)*Element"></a><code>InsertAfter(v interface{},mark *Element)*Element</code></h2><blockquote>
<p>在<code>mark</code>后增加元素</p>
</blockquote>
<h2 id="MoveToFront-e-Element"><a href="#MoveToFront-e-Element" class="headerlink" title="MoveToFront(e *Element)"></a><code>MoveToFront(e *Element)</code></h2><blockquote>
<p>将元素移至列表头部</p>
</blockquote>
<h2 id="MoveToBack-e-Element"><a href="#MoveToBack-e-Element" class="headerlink" title="MoveToBack(e *Element)"></a><code>MoveToBack(e *Element)</code></h2><blockquote>
<p>将元素移至列表尾部</p>
</blockquote>
<h2 id="MoveBefore-e-mark-Element"><a href="#MoveBefore-e-mark-Element" class="headerlink" title="MoveBefore(e mark *Element)"></a><code>MoveBefore(e mark *Element)</code></h2><blockquote>
<p>将元素<code>e</code>移至<code>mark</code>前边</p>
</blockquote>
<h2 id="MoveAfter-e-mark-Element"><a href="#MoveAfter-e-mark-Element" class="headerlink" title="MoveAfter(e mark *Element)"></a><code>MoveAfter(e mark *Element)</code></h2><blockquote>
<p>将元素<code>e</code>移至<code>mark</code>后边</p>
</blockquote>
<h2 id="PushBackList-other-List"><a href="#PushBackList-other-List" class="headerlink" title="PushBackList(other *List)"></a><code>PushBackList(other *List)</code></h2><blockquote>
<p>将列表<code>other</code>放入当前列表尾部</p>
</blockquote>
<h2 id="PushFrontList-other-List"><a href="#PushFrontList-other-List" class="headerlink" title="PushFrontList(other *List)"></a><code>PushFrontList(other *List)</code></h2><blockquote>
<p>将列表<code>other</code>放至当前列表头部</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sync.Map 底层实现分析</title>
    <url>/blog/2018/12/17/20181217141509.html</url>
    <content><![CDATA[<h1 id="sync-Map的数据结构"><a href="#sync-Map的数据结构" class="headerlink" title="sync.Map的数据结构"></a>sync.Map的数据结构</h1><blockquote>
<p>首先看一下<code>sync.Map</code>的底层数据结构</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 互斥锁，锁定 dirty</span></span><br><span class="line">	mu Mutex                        </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 优先读</span></span><br><span class="line">	read atomic.Value               </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保存最新map</span></span><br><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry   </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 记录从read中读取不到数据次数</span></span><br><span class="line">	<span class="comment">// 当misses&gt;=len(dirty)时，会将dirty作为read,然后dirty=nil</span></span><br><span class="line">	<span class="comment">// (源码中 missLocked函数)</span></span><br><span class="line">	misses <span class="keyword">int</span>                      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 主要用于存储</span></span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    <span class="comment">// 如果数据在dirty中但没有在read中，该值为true,作为修改标识</span></span><br><span class="line">    amended <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nil: 表示为被删除，调用Delete()可以将read map中的元素置为nil</span></span><br><span class="line">    <span class="comment">// expunged: 也是表示被删除，但是该键只在read而没有在dirty中，这种情况出现在将read复制到dirty中，即复制的过程会先将nil标记为expunged，然后不将其复制到dirty</span></span><br><span class="line">    <span class="comment">//  其他: 表示存着真正的数据</span></span><br><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>mu</code> 用于数据存取数据加锁</li>
<li><code>read</code> </li>
<li><code>dirty</code></li>
<li><code>misses</code></li>
</ol>
</blockquote>
<h1 id="sync-Map的操作"><a href="#sync-Map的操作" class="headerlink" title="sync.Map的操作"></a>sync.Map的操作</h1><h2 id="存数据，Store-key-val"><a href="#存数据，Store-key-val" class="headerlink" title="存数据，Store(key,val)"></a>存数据，<code>Store(key,val)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	read, _ = m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">			<span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line">			<span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line">			m.dirty[key] = e</span><br><span class="line">		&#125;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">			<span class="comment">// We're adding the first new key to the dirty map.</span></span><br><span class="line">			<span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">			m.dirtyLocked()</span><br><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		m.dirty[key] = newEntry(value)</span><br><span class="line">	&#125;</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>首先判断是否在<code>map.read</code>中，如果在，则调用<code>entry</code>的<code>tryStore</code>方法，<code>tryStore</code>方法使用了<code>atomic.CompareAndSwapPointer</code>操作，保证了操作原子性。如果成功，则直接返回<sup>①</sup>。当该<code>key</code>值已删去时<code>tryStore</code>方法返回<code>false</code>继续执行<sup>②</sup></li>
<li>加锁，重新获取<code>map.read</code>值保证锁定操作期间数据最新且不会发生变化。</li>
<li>如果<code>key</code>存在于<code>map.read</code>中：<ol>
<li>如果<code>read</code>中数据被删除<sup>③</sup>，则将<code>k-v</code>放到<code>dirty</code>中(<code>dirty</code>中没有该<code>key</code>)</li>
<li>如果<code>read</code>中数据未被删除<sup>④</sup>不处理</li>
<li>将<code>v</code>放到<code>read</code>中</li>
</ol>
</li>
<li>如果<code>key</code>不存在于<code>map.read</code>中，存在于<code>dirty</code>中<sup>⑤</sup>，更新<code>dirty</code>中的值</li>
<li>如果<code>key</code>既不存在于<code>map.read</code>中，也不存在于<code>map.dirty</code>中：<ol>
<li><code>read</code>与<code>dirty</code>中<code>key</code>一致（<code>amended</code>为<code>false</code>）<sup>⑥</sup>，初始化<code>read</code>，并标记<code>amended</code>参数为<code>true</code>，将数据存到<code>dirty</code>中</li>
<li>否则不做处理 <sup>⑦</sup></li>
<li>将数据存入<code>dirty</code>中</li>
</ol>
</li>
<li>解锁返回</li>
</ol>
</blockquote>
<h2 id="删除数据-Delete-key"><a href="#删除数据-Delete-key" class="headerlink" title="删除数据 Delete(key)"></a>删除数据 <code>Delete(key)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		e.<span class="built_in">delete</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>判断如果待删除的<code>key</code>不在<code>map.read</code>中且<code>map.dirty</code>中含有<code>map.read</code>中不存在的<code>key</code>，则：<ol>
<li>锁定，重新判断<code>map.read</code>中是否有<code>key</code>，如果同上，则调用从<code>map.dirty</code>中删除的函数，然后解锁</li>
</ol>
</li>
<li>否则，若<code>key</code>存在于<code>map.read</code>中，则调用<code>entry</code>中的<code>delete</code>（<code>entry</code>里只有一个参数，应该是<code>val</code>的指针）</li>
</ol>
</blockquote>
<h2 id="访问map数据-Load-key"><a href="#访问map数据-Load-key" class="headerlink" title="访问map数据 Load(key)"></a>访问map数据 <code>Load(key)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load returns the value stored in the map for a key, or nil if no</span></span><br><span class="line"><span class="comment">// value is present.</span></span><br><span class="line"><span class="comment">// The ok result indicates whether value was found in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		<span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></span><br><span class="line">		<span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it's</span></span><br><span class="line">		<span class="comment">// not worth copying the dirty map for this key.)</span></span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line">			<span class="comment">// map.</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>判断如果待访问的<code>key</code>不在<code>map.read</code>中且<code>map.dirty</code>中含有<code>map.read</code>中不存在的<code>key</code>，则<ol>
<li>对<code>map</code>加锁，再次判断为真，则调用<code>map.missLocked()</code>，（通过判断在<code>map.read</code>中miss的次数来决定是否将<code>map.dirty</code>替换掉<code>map.read</code>）</li>
<li>解锁</li>
</ol>
</li>
<li>判断前边是否获得到<code>val</code>值，未获取到，则返回 <code>nil,false</code></li>
<li>若前边取到<code>val</code>，则返回</li>
</ol>
</blockquote>
<h2 id="LoadOrStore-key-val"><a href="#LoadOrStore-key-val" class="headerlink" title="LoadOrStore(key,val)"></a>LoadOrStore(key,val)</h2><blockquote>
<ol>
<li>如果<code>map</code>中存在<code>key</code>，则返回对应的<code>val</code></li>
<li>否则，保存参数中的<code>key,val</code>，并返回参数中的<code>val</code></li>
</ol>
</blockquote>
<h2 id="遍历Map-range"><a href="#遍历Map-range" class="headerlink" title="遍历Map: range"></a>遍历Map: range</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := sync.Map&#123;&#125;</span><br><span class="line">	m.Store(<span class="string">"k1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">	m.Store(<span class="string">"k2"</span>, <span class="string">"v2"</span>)</span><br><span class="line"></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="map-read与map-dirty中数据一致性："><a href="#map-read与map-dirty中数据一致性：" class="headerlink" title="map.read与map.dirty中数据一致性："></a><code>map.read</code>与<code>map.dirty</code>中数据一致性：</h2><blockquote>
<ol>
<li><code>map.dirty</code>包含<code>map.read</code>中没有的<code>key</code>，<code>map.read.amended</code>为<code>false</code>，表明两者底层<code>val</code>引用是一致的，此时对数据的 更新、删除（此时删除操作实际是将底层<code>val</code>的指针置位<code>nil</code>，相当于只删除了<code>val</code>未删除<code>key</code>） 做<code>cas</code>操作即可</li>
<li>否则，<code>map.read.amended</code>为<code>true</code>，此时操作数据要考虑<code>map.read</code>与<code>map.dirty</code>中数据一致性<ol>
<li><code>load</code>数据时，在<code>map.read</code>中访问不到次数大于等于<code>map.dirty</code>长度时，会用<code>map.dirty</code>替换<code>map.read</code>，并将<code>map.dirty</code>置为<code>nil</code>，此时<code>map.read.amended</code>为<code>false</code>（因为<code>map.dirty</code>中不包含<code>map.read</code>中不存在的<code>key</code>）</li>
<li><code>store</code>数据时，当<code>map.dirty</code>数据为空时，会将<code>map.read</code>中的<code>key</code>的<code>val</code>引用复制过来（此时会判断是否标记未删除，标记删除则不复制，删除了<code>val</code>的<code>key</code>也删除掉），再在<code>map.dirty</code>中增加<code>k-v</code>，此时<code>map.read.amended</code>为<code>true</code></li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>map基础</title>
    <url>/blog/2018/12/16/20181216153850.html</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map实现方式"><a href="#map实现方式" class="headerlink" title="map实现方式"></a><code>map</code>实现方式</h2><blockquote>
<p>go语言中<code>map</code>使用<code>hash</code>（散列表）实现</p>
</blockquote>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个 map 变量，其值为nil，(m1==nil)为true</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空map （可在&#123;&#125;中填写map中的元素）</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空map</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<h2 id="map的key类型限制"><a href="#map的key类型限制" class="headerlink" title="map的key类型限制"></a><code>map</code>的<code>key</code>类型限制</h2><blockquote>
<p><code>map</code>使用<code>hash表</code>存储实现，<code>key</code>类型必须可比较相等。<br><code>map</code>的<code>key</code>类型必须不为<code>function</code>,<code>slice</code>,<code>map</code>，在定义时，如果使用这些类型会报错。<br><code>struct类型</code>也可作为<code>key</code>类型，但如果使用带有这些类型属性的<code>struct</code>不可以作为<code>key</code>。可能编译不会报错，但运行时会报错。</p>
<p><img src="/resources/post_pic/2018/12/keyOfMapCantBeTheseTypes.png" alt="map使用错误的key类型报错" title="map使用错误的key类型报错"></p>
</blockquote>
<h2 id="Map操作"><a href="#Map操作" class="headerlink" title="Map操作"></a><code>Map</code>操作</h2><h3 id="map长度"><a href="#map长度" class="headerlink" title="map长度"></a><code>map</code>长度</h3><blockquote>
<p>获取长度方法：<code>len(map)</code></p>
</blockquote>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="number">3</span>: <span class="number">6</span>,</span><br><span class="line">		<span class="number">5</span>: <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 直接访问不存在的元素</span></span><br><span class="line">	m4v := m[<span class="number">4</span>]</span><br><span class="line">	fmt.Println(m4v)</span><br><span class="line">	<span class="comment">// 使用ok参数接收是否取得正确的值</span></span><br><span class="line">	m4v, ok := m[<span class="number">4</span>]</span><br><span class="line">	fmt.Println(m4v, ok)</span><br><span class="line">	<span class="comment">// 使用ok参数接收是否取得正确的值</span></span><br><span class="line">	m5v, ok := m[<span class="number">5</span>]</span><br><span class="line">	fmt.Println(m5v, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">&lt;nil&gt; false</span><br><span class="line">&lt;nil&gt; true</span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote>
<ol>
<li>不使用<code>ok</code>参数接收是否取得值时，如果不存在<code>key</code>值对应的<code>val</code>，则返回对应类型的空：<code>int</code>返回<code>0</code>，<code>string</code>返回<code>&quot;&quot;</code>，引用类型返回<code>nil</code>等。</li>
<li>使用<code>ok</code>参数可以通过判断<code>ok</code>知道<code>map</code>中是否存在<code>key</code></li>
<li>不使用<code>ok</code>时可能存在的问题，如上代码，<code>m[4]</code>不存在于<code>map</code>中，取得结果为<code>nil</code>，<code>m[5]</code>存在于<code>map</code>中，其本身对应的值为<code>nil</code>所以取得结果也为<code>nil</code>，这种情况下可能会存在问题</li>
</ol>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="number">3</span>: <span class="number">6</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><blockquote>
<p>每次运行程序输出顺序可能不一致，<code>map</code>不能保证遍历的顺序性</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><blockquote>
<p>删除方法 <code>delete</code></p>
</blockquote>
<h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(m, <span class="number">0</span>)</span><br><span class="line">	_, ok := m[<span class="number">0</span>]</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	<span class="comment">// 测试删除不存在的元素，不会报错</span></span><br><span class="line">	<span class="built_in">delete</span>(m,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><blockquote>
<p>输出：false</p>
</blockquote>
<h1 id="安全map——sync-Map"><a href="#安全map——sync-Map" class="headerlink" title="安全map——sync.Map"></a>安全map——sync.Map</h1><blockquote>
<p>普通<code>map</code>类型在只读的情况下是线程安全的，但同时读写时非线程安全。</p>
</blockquote>
<h2 id="普通线程安全性"><a href="#普通线程安全性" class="headerlink" title="普通线程安全性"></a>普通线程安全性</h2><h3 id="普通map线程安全测试"><a href="#普通map线程安全测试" class="headerlink" title="普通map线程安全测试"></a>普通<code>map</code>线程安全测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 无限向map写数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 无限从map读数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 让主线程不退出，并发程序后台执行</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		_ = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果-报错"><a href="#测试结果-报错" class="headerlink" title="测试结果:报错"></a>测试结果:报错</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></table></figure>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><blockquote>
<p>方法：<code>Store(key,val)</code>；<code>LoadOrStore(key,val)</code></p>
<ol>
<li><code>Store(key,val)</code>方法，将<code>key:val</code>对存入<code>map</code>中；</li>
<li><code>LoadOrStore(key,val)</code>方法，返回值有两个 <code>(val,ok)</code>，<code>val</code>表示在<code>map</code>中<code>key</code>对应的值（如果已存在，则为原<code>map</code>中的值，如果不存在，则先将<code>key:val</code>对存入<code>map</code>，再返回<code>val</code>）；<code>ok</code>表示<code>map</code>中是否已存在<code>key</code>值及其对应的<code>val</code>。</li>
</ol>
</blockquote>
<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><blockquote>
<p>方法： <code>Delete(key)</code></p>
<p>删除<code>map</code>中<code>key</code>及其对应的<code>val</code></p>
</blockquote>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><blockquote>
<p>方法： <code>Load(key)</code>；<code>LoadOrStore(key,val)</code></p>
<ol>
<li>直接调用<code>Load</code>方法，返回值有两个<code>(val,ok)</code>，值以及是否存在</li>
<li><code>LoadOrStore</code>方法在添加元素部分已解释</li>
</ol>
</blockquote>
<h4 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h4><blockquote>
<p>方法： <code>Range(f func(key, value interface{}) bool)</code></p>
<p>参数是一个函数，在函数中执行遍历操作</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go-slice操作</title>
    <url>/blog/2018/12/16/20181216012715.html</url>
    <content><![CDATA[<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><h2 id="方法：append-slice-elems"><a href="#方法：append-slice-elems" class="headerlink" title="方法：append(slice,elems...)"></a>方法：<code>append(slice,elems...)</code></h2><blockquote>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未触发扩容</span></span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">	s := arr[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	news := <span class="built_in">append</span>(s, <span class="number">100</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"news ptr : %p\ts ptr : %p\n"</span>,news,s)</span><br><span class="line">	fmt.Println(<span class="string">"s\t"</span>,s)</span><br><span class="line">	fmt.Println(<span class="string">"news\t"</span>,news)</span><br><span class="line">	fmt.Println(<span class="string">"arr\t"</span>,arr)</span><br><span class="line">	fmt.Println(<span class="string">"===================="</span>)</span><br><span class="line">	<span class="comment">// 触发扩容</span></span><br><span class="line">	arr = []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	s = arr[:]</span><br><span class="line">	news = <span class="built_in">append</span>(s,<span class="number">100</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"news ptr : %p\ts ptr : %p\n"</span>,news,s)</span><br><span class="line">	fmt.Println(<span class="string">"s\t"</span>,s)</span><br><span class="line">	fmt.Println(<span class="string">"news\t"</span>,news)</span><br><span class="line">	fmt.Println(<span class="string">"arr\t"</span>,arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">news ptr : 0xc00007a0a0	s ptr : 0xc00007a0a0</span><br><span class="line">s	 [0 1]</span><br><span class="line">news 	 [0 1 100]</span><br><span class="line">arr	 [0 1 100 3 4 5 6 7 8 9]</span><br><span class="line">====================</span><br><span class="line">news ptr : 0xc000072030	s ptr : 0xc00004a0e0</span><br><span class="line">s	 [0 1 2]</span><br><span class="line">news 	 [0 1 2 100]</span><br><span class="line">arr	 [0 1 2]</span><br></pre></td></tr></table></figure>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li><code>append</code>方法会创建一个新<code>slice</code>，原<code>slice</code>不变。</li>
<li>调用<code>append</code>方法如果未触发扩容，则底层array对应位置会做出相应改变</li>
<li>调用<code>append</code>方法如果触发扩容，则原底层array对应位置不发生变化，因为新的<code>slice</code>底层array也已变化  </li>
</ol>
</blockquote>
<h1 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h1><h2 id="方法：copy-dst-type-src-type"><a href="#方法：copy-dst-type-src-type" class="headerlink" title="方法：copy(dst []type,src []type)"></a>方法：<code>copy(dst []type,src []type)</code></h2><blockquote>
</blockquote>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// len(src) &gt; len(dst)</span></span><br><span class="line">	fmt.Println(<span class="string">"before\tdst :"</span>,s1,<span class="string">"src :"</span>,s2)</span><br><span class="line">	<span class="built_in">copy</span>(s1,s2)</span><br><span class="line">	fmt.Println(<span class="string">"after\tdst :"</span>,s1,<span class="string">"src :"</span>,s2)</span><br><span class="line">	fmt.Println(<span class="string">"====================="</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// len(src) &lt; len(dst)</span></span><br><span class="line">	s1 = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">"before\tdst :"</span>,s2,<span class="string">"src :"</span>,s1)</span><br><span class="line">	<span class="built_in">copy</span>(s2,s1)</span><br><span class="line">	fmt.Println(<span class="string">"after\tdst :"</span>,s2,<span class="string">"src :"</span>,s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果：-1"><a href="#测试结果：-1" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before	dst : [0] src : [1 2 3]</span><br><span class="line">after	dst : [1] src : [1 2 3]</span><br><span class="line">=====================</span><br><span class="line">before	dst : [1 2 3] src : [0]</span><br><span class="line">after	dst : [0 2 3] src : [0]</span><br></pre></td></tr></table></figure>
<h2 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li>将<code>src</code>数据拷贝到<code>dst</code>中</li>
<li>如果<code>src</code>长度大于<code>dst</code>长度，则只会复制<code>len(dst)</code>个数据到<code>dst</code>中</li>
<li>如果<code>src</code>长度小于<code>dst</code>长度，则<code>dst</code>的前<code>len(src)</code>个数据会被<code>src</code>的数据覆盖，后边不变</li>
</ol>
</blockquote>
<h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><blockquote>
<p>无默认删除操作，可通过<code>append</code>实现</p>
</blockquote>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"before del s1's ptr :\t%p\n"</span>,s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(<span class="string">"============="</span>)</span><br><span class="line">	<span class="comment">// do delete</span></span><br><span class="line">	s1 = <span class="built_in">append</span>(s1[:<span class="number">2</span>],s1[<span class="number">3</span>:]...)</span><br><span class="line">	fmt.Printf(<span class="string">"after del s1's ptr :\t%p\n"</span>,s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果：-2"><a href="#测试结果：-2" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before del s1&apos;s ptr :	0xc000072030</span><br><span class="line">[0 1 2 3 4 5]</span><br><span class="line">=============</span><br><span class="line">after del s1&apos;s ptr :	0xc000072030</span><br><span class="line">[0 1 3 4 5]</span><br></pre></td></tr></table></figure>
<h2 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li>删除元素<code>slice</code>长度只会减小不会增大，因此底层数组不会发生变化。</li>
</ol>
</blockquote>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><h2 id="方法：无方法，直接通过-slice-i-val-修改"><a href="#方法：无方法，直接通过-slice-i-val-修改" class="headerlink" title="方法：无方法，直接通过 slice[i] = val 修改"></a>方法：无方法，直接通过 <code>slice[i] = val</code> 修改</h2><h2 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h2><blockquote>
<p>略</p>
</blockquote>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="方法：-for-i-v-range-slice遍历"><a href="#方法：-for-i-v-range-slice遍历" class="headerlink" title="方法： for i,v := range slice遍历"></a>方法： <code>for i,v := range slice</code>遍历</h2><h2 id="测试：-2"><a href="#测试：-2" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="comment">// 只用 index</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d,"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// index,value都用</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d:%d,\t"</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 只用value</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d,"</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,</span><br><span class="line">0:0,	1:2,	2:4,	3:6,	4:8,	5:10,	</span><br><span class="line">0,2,4,6,8,10,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go slice原理</title>
    <url>/blog/2018/12/15/20181215204437.html</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>go语言<code>slice</code>是底层数组的一个视图。<br><code>slice</code>主要参数有3个:</p>
<ol>
<li><code>ptr</code>指向<code>slice</code>的首个元素；</li>
<li><code>len</code>表示<code>slice</code>长度；</li>
<li><code>cap</code>表示<code>slice</code>容量。</li>
</ol>
<p>当向<code>slice</code>里<code>append</code>元素的时候，如果元素个数大于容量的某个百分比，将会扩容。其<code>ptr</code>值也会变。<br><code>slice</code>扩容的原理其实就是更换该<code>slice</code>底层<code>array</code>数组（因为<code>slice</code>只是某一数组的视图）</p>
</blockquote>
<h1 id="定义时与数组的区别"><a href="#定义时与数组的区别" class="headerlink" title="定义时与数组的区别"></a>定义时与数组的区别</h1><blockquote>
<p><code>array</code>与<code>slice</code>的定义</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array定义</span></span><br><span class="line">array1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice定义</span></span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">slice3 := array1[:] <span class="comment">// array1 := [3]int&#123;1,2,3&#125;</span></span><br><span class="line">slice4 := slice1[:]</span><br><span class="line"><span class="keyword">var</span> slice5 = []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><blockquote>
<p>测试<code>slice</code>与<code>array</code>定义区别</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	array1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	array2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">	slice3 := array1[:]</span><br><span class="line">	slice4 := slice1[:]</span><br><span class="line">	<span class="keyword">var</span> slice5 []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"array1 type : %v\n"</span>,reflect.TypeOf(array1).Kind())</span><br><span class="line">	fmt.Printf(<span class="string">"array2 type : %v\n"</span>,reflect.TypeOf(array2).Kind())</span><br><span class="line">	fmt.Println(<span class="string">"==================="</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"slice1 type : %v\n"</span>,reflect.TypeOf(slice1).Kind())</span><br><span class="line">	fmt.Printf(<span class="string">"slice2 type : %v\n"</span>,reflect.TypeOf(slice2).Kind())</span><br><span class="line">	fmt.Printf(<span class="string">"slice3 type : %v\n"</span>,reflect.TypeOf(slice3).Kind())</span><br><span class="line">	fmt.Printf(<span class="string">"slice4 type : %v\n"</span>,reflect.TypeOf(slice4).Kind())</span><br><span class="line">	fmt.Printf(<span class="string">"slice5 type : %v\n"</span>,reflect.TypeOf(slice5).Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array1 type : array</span><br><span class="line">array2 type : array</span><br><span class="line">===================</span><br><span class="line">slice1 type : slice</span><br><span class="line">slice2 type : slice</span><br><span class="line">slice3 type : slice</span><br><span class="line">slice4 type : slice</span><br><span class="line">slice5 type : slice</span><br></pre></td></tr></table></figure>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><blockquote>
<p>测试<code>slice</code>扩容条件</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	tmp := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	arr := tmp[<span class="number">1</span>:]</span><br><span class="line">	Cap := <span class="built_in">cap</span>(arr)</span><br><span class="line">	lastCap := Cap</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++ &#123;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span><br><span class="line">		Cap = <span class="built_in">cap</span>(arr)</span><br><span class="line">		<span class="keyword">if</span> Cap == lastCap &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"%p\tlen:%v\t\tlastCap:%v\t\tcap:%v\n"</span>, arr, <span class="built_in">len</span>(arr), lastCap, Cap)</span><br><span class="line">		lastCap = Cap</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc000072030	len:4		lastCap:3		cap:6</span><br><span class="line">0xc00003e060	len:7		lastCap:6		cap:12</span><br><span class="line">0xc00008a000	len:13		lastCap:12		cap:24</span><br><span class="line">0xc00008c000	len:25		lastCap:24		cap:48</span><br><span class="line">0xc00008e000	len:49		lastCap:48		cap:96</span><br><span class="line">0xc000090000	len:97		lastCap:96		cap:192</span><br><span class="line">0xc000092000	len:193		lastCap:192		cap:384</span><br><span class="line">0xc000098000	len:385		lastCap:384		cap:768</span><br><span class="line">0xc00009e000	len:769		lastCap:768		cap:1536</span><br><span class="line">0xc0000a4000	len:1537		lastCap:1536		cap:2048</span><br><span class="line">0xc0000a8000	len:2049		lastCap:2048		cap:2560</span><br><span class="line">0xc0000b2000	len:2561		lastCap:2560		cap:3408</span><br><span class="line">0xc0000c6000	len:3409		lastCap:3408		cap:5120</span><br><span class="line">0xc0000d0000	len:5121		lastCap:5120		cap:7168</span><br><span class="line">0xc0000de000	len:7169		lastCap:7168		cap:9216</span><br><span class="line">0xc0000f0000	len:9217		lastCap:9216		cap:12288</span><br><span class="line">0xc000108000	len:12289		lastCap:12288		cap:15360</span><br><span class="line">0xc000126000	len:15361		lastCap:15360		cap:19456</span><br><span class="line">0xc00014c000	len:19457		lastCap:19456		cap:24576</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：</p>
<ol>
<li>当扩容时，<code>ptr</code>指针变（即<code>slice</code>这个视图所在的<code>array</code>发生变化）</li>
<li>只有当<code>cap</code>大小等于<code>len</code>的时候才会扩容，扩容大小视<code>cap</code>大小而定：<code>cap</code>较小时，直接扩容一倍，稍大时，扩容比例较小</li>
</ol>
</blockquote>
<h2 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h2><blockquote>
<p>测试扩容前后的<code>slice</code>与原<code>slice</code>有什么不同以及两个相同的<code>slice</code>执行某些操作后，另一个的变化情况</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">16</span>)</span><br><span class="line">	arr2 := arr</span><br><span class="line">	<span class="comment">// 扩容前两者地址一样，修改一个，另一个值也修改</span></span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">	fmt.Printf(<span class="string">"arr\t%p\t[0] : %v\tlen : %v\tcap : %v\n"</span>, arr, arr[<span class="number">0</span>], <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">	fmt.Printf(<span class="string">"ar2\t%p\t[0] : %v\tlen : %v\tcap : %v\n\n"</span>, arr2, arr2[<span class="number">0</span>], <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span><br><span class="line">	<span class="comment">// 扩容前，当一个增加元素时，另一个slice长度不变</span></span><br><span class="line">	arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"arr\t%p\t[0] : %v\tlen : %v\tcap : %v\n"</span>, arr, arr[<span class="number">0</span>], <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">	fmt.Printf(<span class="string">"ar2\t%p\t[0] : %v\tlen : %v\tcap : %v\n\n"</span>, arr2, arr2[<span class="number">0</span>], <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span><br><span class="line">	<span class="comment">// 循环，令arr扩容</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 扩容后，arr变成一个新的slice，修改其中一个slice的值，另一个不会变</span></span><br><span class="line">	fmt.Printf(<span class="string">"arr\tptr : %p\tlen : %v\tcap : %v\n"</span>, arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">	fmt.Printf(<span class="string">"ar2\tptr : %p\tlen : %v\tcap : %v\n\n"</span>, arr2, <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"arr\t[0] : %v\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(<span class="string">"ar2\t[0] : %v\n"</span>, arr2[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr	0xc00007e080	[0] : 5	len : 2	cap : 16</span><br><span class="line">ar2	0xc00007e080	[0] : 5	len : 2	cap : 16</span><br><span class="line"></span><br><span class="line">arr	0xc00007e080	[0] : 5	len : 3	cap : 16</span><br><span class="line">ar2	0xc00007e080	[0] : 5	len : 2	cap : 16</span><br><span class="line"></span><br><span class="line">arr	ptr : 0xc00008c000	len : 103	cap : 128</span><br><span class="line">ar2	ptr : 0xc00007e080	len : 2	cap : 16</span><br><span class="line"></span><br><span class="line">arr	[0] : 100</span><br><span class="line">ar2	[0] : 5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论</p>
<ol>
<li>未发生扩容，两个<code>slice</code>相同，改变其中一个<code>slice</code>，另一个也变</li>
<li>未发生扩容，向其中一个增加元素，另一个len不变</li>
<li>发生扩容，新生成<code>slice</code>，地址变，改变其中一个<code>slice</code>另一个不变</li>
</ol>
</blockquote>
<h2 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h2><blockquote>
<p>测试对于两个引用同一个数组但<code>len</code>不同的<code>slice</code>，能否取到超出自身<code>len</code>的元素</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	tmp := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">	s1 := tmp[<span class="number">2</span>:<span class="number">6</span>]	<span class="comment">// s1 : [2,3,4,5]</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1))	<span class="comment">// s1 长度只有1</span></span><br><span class="line">	s2 := s1[<span class="number">3</span>:<span class="number">6</span>]   <span class="comment">// s2 : [5,6,7]</span></span><br><span class="line">	<span class="comment">// fmt.Println(s2[3])  // 报错</span></span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">[5 6 7]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：</p>
<ol>
<li>如实例，<code>s1</code>长度为<code>1</code>，使用<code>[:]</code>操作，能取到后边的数字</li>
<li>如实例，<code>s1</code>长度为<code>1</code>，无法使用<code>s1[1]</code>取到对应位置的数据</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>博客next主题侧边菜单栏设置</title>
    <url>/blog/2018/12/15/20181215023114.html</url>
    <content><![CDATA[<h1 id="增加菜单"><a href="#增加菜单" class="headerlink" title="增加菜单"></a>增加菜单</h1><blockquote>
<p>增加菜单 tags、categories、等</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建页面</span></span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<h1 id="增加链接"><a href="#增加链接" class="headerlink" title="增加链接"></a>增加链接</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在主题config里去掉menu里相关注释</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br></pre></td></tr></table></figure>
<h1 id="修改新建的tags、categories目录下的md文件"><a href="#修改新建的tags、categories目录下的md文件" class="headerlink" title="修改新建的tags、categories目录下的md文件"></a>修改新建的tags、categories目录下的md文件</h1><blockquote>
<p>在md文件中增加type 属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-12-15 02:22:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="使用标签和分类"><a href="#使用标签和分类" class="headerlink" title="使用标签和分类"></a>使用标签和分类</h1><blockquote>
<p>在post里增加tags和categories属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 博客next主题侧边菜单栏设置</span><br><span class="line">date: 2018-12-15 02:31:14</span><br><span class="line">tags: </span><br><span class="line">    - github博客</span><br><span class="line">categories: </span><br><span class="line">    - github博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：tags、categories均可用数组[1,2,3]的形式代替列表形式。tags列表里内容同级，categories列表里内容不同级</p>
</blockquote>
<h1 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h1><blockquote>
<p>主要在blog根目录下的<code>_config.yml</code>文件中配置，默认配置是 <code>年/月/日/标题/</code>，用标题作为url一部分不是很合理，如果标题发生改变，那链接也跟着变化了。  </p>
<p>所以要使用一个唯一标示且不会发生改变的值作为url。hexo自带的有id，可使用id，但id生成规则不是很清楚，测试过修改题目后，id也发生变化。  </p>
<p>本网站使用的方法是：给每个md文件增加一个属性，记为<code>pid</code>，然后使用<code>pid</code>作为url一部分。</p>
<p>首先，修改blog根目录下的<code>_config.yml</code>文件如下：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 永久化链接。（最后加 .html 有利于搜索引擎收录）</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:year/:month/:day/:pid.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line">  <span class="attr">pid:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，修改新增<code>post</code>时的模板文件<code>blog/scaffolds/post.md</code>，增加<code>pid</code>属性，这里把<code>pid</code>设置成时间了，直接用<code>date</code>在转化后不是我们想要的格式，这里就用这种笨方法。或者留白，新建文件后自己填写也可。  </p>
<p>使用这种方法，<code>pid</code>是与文章内容无任何关系的属性，只要我们不修改<code>pid</code>和永久链接规则，文章的链接就不会变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">pid: &#123;&#123;date[0]&#125;&#125;&#123;&#123;date[1]&#125;&#125;&#123;&#123;date[2]&#125;&#125;&#123;&#123;date[3]&#125;&#125;&#123;&#123;date[5]&#125;&#125;&#123;&#123;date[6]&#125;&#125;&#123;&#123;date[8]&#125;&#125;&#123;&#123;date[9]&#125;&#125;&#123;&#123;date[11]&#125;&#125;&#123;&#123;date[12]&#125;&#125;&#123;&#123;date[14]&#125;&#125;&#123;&#123;date[15]&#125;&#125;&#123;&#123;date[17]&#125;&#125;&#123;&#123;date[18]&#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>github博客</category>
      </categories>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title>在GitHub上创建博客</title>
    <url>/blog/2018/12/15/20181215005754.html</url>
    <content><![CDATA[<h1 id="GitHub搭建博客"><a href="#GitHub搭建博客" class="headerlink" title="GitHub搭建博客"></a>GitHub搭建博客</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><blockquote>
<p>安装完成后测试</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.4.1</span></span><br><span class="line">node -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> v10.14.2</span></span><br></pre></td></tr></table></figure>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>全局安装hexo</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装完查看</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Windows_NT 10.0.17763 win32 x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.14.2</span><br><span class="line">v8: 6.8.275.32-node.45</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0j</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure>
<h2 id="GitHub创建项目，并拉至本地"><a href="#GitHub创建项目，并拉至本地" class="headerlink" title="GitHub创建项目，并拉至本地"></a>GitHub创建项目，并拉至本地</h2><blockquote>
<p>注意：项目名格式必须为    用户名.github.io  </p>
</blockquote>
<h2 id="初始化hexo环境"><a href="#初始化hexo环境" class="headerlink" title="初始化hexo环境"></a>初始化hexo环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建blog目录，在目录下执行命令</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成后安装依赖</span></span><br><span class="line">npm install </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="配置ssh，让本地可免密push到GitHub"><a href="#配置ssh，让本地可免密push到GitHub" class="headerlink" title="配置ssh，让本地可免密push到GitHub"></a>配置ssh，让本地可免密push到GitHub</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="新建博客，并上传到git"><a href="#新建博客，并上传到git" class="headerlink" title="新建博客，并上传到git"></a>新建博客，并上传到git</h2><h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post "博客名"</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在_config.yml最后配置</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<h2 id="增加搜索功能"><a href="#增加搜索功能" class="headerlink" title="增加搜索功能"></a>增加搜索功能</h2><h3 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog配置文件</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># 主题配置文件 themes/主题名/_config.yml</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="安装mermaid插件："><a href="#安装mermaid插件：" class="headerlink" title="安装mermaid插件："></a>安装mermaid插件：</h3><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams -u</span><br></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><code>_config.yml</code>中增加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>
<p>在页面加入引用：<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">github地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ol>
<li>ERROR Deployer not found: git<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>github博客</category>
      </categories>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言与其他语言不一样的地方</title>
    <url>/blog/2018/10/23/20181210104815.html</url>
    <content><![CDATA[<h2 id="没有：类、继承、多态、重载-的概念"><a href="#没有：类、继承、多态、重载-的概念" class="headerlink" title="没有：类、继承、多态、重载  的概念"></a>没有：类、继承、多态、重载  的概念</h2><blockquote>
<ol>
<li>不同世界观： go语言中使用 duck typing，面向接口编程、函数式编程</li>
<li>面向对象的世界里，也流行变继承为组合的思维</li>
<li>面向对象的元素容易被滥用</li>
<li>为组合提供了便捷的支持</li>
</ol>
</blockquote>
<h2 id="没有：try-catch-finally"><a href="#没有：try-catch-finally" class="headerlink" title="没有：try/catch/finally"></a>没有：try/catch/finally</h2><blockquote>
<ol>
<li>太多错误被当作异常</li>
<li>很多C++项目组禁用try/catch</li>
<li>正确的使用try/catch处理错误，导致代码混乱</li>
<li>在产品代码中try/catch并不能减小开发人员负担</li>
<li>真正异常情况有 defer/panic/recover 模式处理</li>
</ol>
</blockquote>
<h2 id="没有构造-析构-RAII"><a href="#没有构造-析构-RAII" class="headerlink" title="没有构造/析构/RAII"></a>没有构造/析构/RAII</h2><blockquote>
<ol>
<li>大型项目很少使用构造函数，多使用工厂函数，如果需要，可直接使用结构体初始化语法实现</li>
<li>go有gc，不需要析构</li>
</ol>
</blockquote>
<h2 id="没有泛型"><a href="#没有泛型" class="headerlink" title="没有泛型"></a>没有泛型</h2><blockquote>
<ol>
<li>泛型实际想实现duck typing，go语言提供了duck typing及接口组合支持</li>
<li>使用来约束参数类型：本身复杂，但go自带slice,map,channel 类似泛型参数</li>
<li>type assertion、go generation来实现自己的泛型</li>
<li>泛型支持是作者唯一态度不强硬的点</li>
</ol>
</blockquote>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
</search>
