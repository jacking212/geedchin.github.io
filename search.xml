<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>K8S调度器（1）</title>
    <url>/blog/2019/08/03/20190803202810.html</url>
    <content><![CDATA[<h1 id="调度器概述"><a href="#调度器概述" class="headerlink" title="调度器概述"></a>调度器概述</h1><p>K8S调度器主要负责将Pod调度到某Node上运行。可以把调度器看做一个黑盒，输入为：pod,nodeList，输出为node，即给定pod和node列表，返回一个将pod调度到某node的结果。</p>
<p>整个调度流程大致如下：</p>
<pre class="mermaid">graph LR;
id1((Start))-->预选
预选-->优选
优选-->id2{是否调度到}
id2-->|是|id3
id2-->|否|抢占
抢占-->id3((结束))</pre>

<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>本文基于14.3源码</p>
<p>入口文件是在 <code>cmd/kube-scheduler/scheduler.go</code>，加载配置逻辑是 <code>cmd/kube-scheduler/app</code> 文件夹下。整个调度过程逻辑是在 <code>pkg/scheduler</code>下。</p>
<p>源码阅读主要从以下几方面：启动前初始化、启动过程、调度过程(预选、优选、抢占)</p>
<h2 id="启动前初始化过程"><a href="#启动前初始化过程" class="headerlink" title="启动前初始化过程"></a>启动前初始化过程</h2><p>启动前初始化函数不少，重点关注<code>pkg/scheduler/algorithmprovider/defaults</code>包下的3个文件里的init()。</p>
<ol>
<li><code>default.go/init()</code>方法主要注册了算法provider，目前有两个算法provider，分别是<code>DefaultProvider</code>和<code>ClusterAutoscalerProvider</code>。provider是一组算法的组合，包括预选、优选过程中的众多算法。此处注册过程只用到了算法的名字，到真正用到算法时会根据算法名取算法实现。</li>
<li><code>register_predicates.go/init()</code>方法主要注册多种预选算法，此处注册的方法通过名字与1中关联</li>
<li><code>register_priorities.go/init()</code>方法主要注册多种优选算法，此处注册的方法通过名字与1中关联</li>
</ol>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	rand.Seed(time.Now().UnixNano())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	command := app.NewSchedulerCommand()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// utilflag.InitFlags()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	logs.InitLogs()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>首先从main函数(<code>cmd/kube-scheduler/scheduler.go</code>)看起：如上，可以看到main函数核心在 command.Execute，再找到command的类型是SchedulerCommand，然后追踪到该command的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := &amp;cobra.Command&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Use: <span class="string">"kube-scheduler"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Long: <span class="string">`...`</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> err := runCommand(cmd, args, opts); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> cmd</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>重点关注 <code>Run:func(cmd *cobra.Command,args []string)</code>，在这段代码里主要调用了 runCommand方法，再看这个方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCommand</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>, opts *options.Options)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	verflag.PrintAndExitIfRequested()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	utilflag.PrintFlags(cmd.Flags())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 加载启动配置参数、选主（同一时间只有一个调度器真正在调度）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c, err := opts.Config()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 根据配置的配置文件，complete配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cc := c.Complete()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 根据featureGate决定使用的算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	algorithmprovider.ApplyFeatureGates()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Configz registration.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cz, err := configz.New(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cz.Set(cc.ComponentConfig)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> Run(cc, stopCh)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>省略部分不重要代码，留下了核心代码并加了注释，应该很好懂了。最后执行Run方法，接下来看Run方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(cc schedulerserverconfig.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 创建调度器，初始化调度器参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sched, err := scheduler.New(cc.Client,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Core().V1().Nodes(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.PodInformer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Core().V1().PersistentVolumes(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Core().V1().PersistentVolumeClaims(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Core().V1().ReplicationControllers(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Apps().V1().ReplicaSets(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Apps().V1().StatefulSets(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Core().V1().Services(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.InformerFactory.Storage().V1().StorageClasses(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.Recorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cc.ComponentConfig.AlgorithmSource,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		stopCh,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		scheduler.WithName(cc.ComponentConfig.SchedulerName),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		scheduler.WithBindTimeoutSeconds(*cc.ComponentConfig.BindTimeoutSeconds))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 启动所有 informers.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> cc.PodInformer.Informer().Run(stopCh)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cc.InformerFactory.Start(stopCh)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Wait for all caches to sync before scheduling.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cc.InformerFactory.WaitForCacheSync(stopCh)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	controller.WaitForCacheSync(<span class="string">"scheduler"</span>, stopCh, cc.PodInformer.Informer().HasSynced)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Prepare a reusable runCommand function.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sched.Run()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;-ctx.Done()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ctx, cancel := context.WithCancel(context.TODO()) <span class="comment">// TODO once Run() accepts a context, it should be used here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> cancel()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Leader election is disabled, so runCommand inline until done.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	run(ctx)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"finished without leader elect"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如上，主要初始化了调度器的参数，定义了一个可stop的方法run，最后执行run(ctx)，查看run方法，里边的核心代码是 <code>sched.Run()</code>，此时代码进入到了 <code>pkg/scheduler</code>包里。继续追踪：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !sched.config.WaitForCacheSync() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.config.StopEverything)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>最后执行的代码 go wait.Until…，实际上调用了<code>sched.scheduleOne</code>方法，并无限循环。</p>
<p>至此，启动过程结束，代码真正进到了调度处。</p>
<h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm&#39;s host fitting.</span></pre></td></tr><tr><td class="code"><pre><span class="line">func (sched *Scheduler) scheduleOne() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 从待调度队列中取出一个待调度的pod，此处无数据时会阻塞</span></pre></td></tr><tr><td class="code"><pre><span class="line">	pod :&#x3D; sched.config.NextPod()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; Synchronously attempt to find a fit for the pod.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	start :&#x3D; time.Now()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 执行调度方法，返回调度结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">	scheduleResult, err :&#x3D; sched.schedule(pod)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 如果调度出错，则可能进入抢占逻辑。</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 无论什么类型错误，进入if后都会return，结束本轮调度</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if err !&#x3D; nil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; 如果错误类型是 FitError</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if fitError, ok :&#x3D; err.(*core.FitError); ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F; 如果不允许抢占，则报错</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if !util.PodPriorityEnabled() || sched.config.DisablePreemption &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				klog.V(3).Infof(&quot;Pod priority feature is not enabled or preemption is disabled by scheduler configuration.&quot; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&quot; No preemption is performed.&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#x2F;&#x2F; 否则，进入抢占</span></pre></td></tr><tr><td class="code"><pre><span class="line">				preemptionStartTime :&#x3D; time.Now()</span></pre></td></tr><tr><td class="code"><pre><span class="line">				sched.preempt(pod, fitError)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F; 否则，报错</span></pre></td></tr><tr><td class="code"><pre><span class="line">			klog.Errorf(&quot;error selecting node for pod: %v&quot;, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			metrics.PodScheduleErrors.Inc()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; ... 省略调度成功后绑定volume等操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">func (sched *Scheduler) schedule(pod *v1.Pod) (core.ScheduleResult, error) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	result, err :&#x3D; sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if err !&#x3D; nil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pod &#x3D; pod.DeepCopy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sched.recordSchedulingFailure(pod, err, v1.PodReasonUnschedulable, err.Error())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return core.ScheduleResult&#123;&#125;, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>主流程如上，先调度，再判断是否需要抢占，必要时进入抢占，调度成功则执行后续的收尾工作。再看一下调度方法(<code>sched.config.Algorithm.Schedule</code>)：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(result ScheduleResult, err error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	trace := utiltrace.New(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	nodes, err := nodeLister.List()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, ErrNoNodesAvailable</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := g.snapshot(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	trace.Step(<span class="string">"Computing predicates"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	startPredicateEvalTime := time.Now()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 核心代码，预选过程，找到可运行pod的nodes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 没找到，直接return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, &amp;FitError&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Pod:              pod,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			NumAllNodes:      <span class="built_in">len</span>(nodes),</span></pre></td></tr><tr><td class="code"><pre><span class="line">			FailedPredicates: failedPredicateMap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	trace.Step(<span class="string">"Prioritizing"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	startPriorityEvalTime := time.Now()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// When only one node after predicate, just use it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> ScheduleResult&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			SuggestedHost:  filteredNodes[<span class="number">0</span>].Name,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			EvaluatedNodes: <span class="number">1</span> + <span class="built_in">len</span>(failedPredicateMap),</span></pre></td></tr><tr><td class="code"><pre><span class="line">			FeasibleNodes:  <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	metaPrioritiesInterface := g.priorityMetaProducer(pod, g.nodeInfoSnapshot.NodeInfoMap)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 核心代码，优选过程，计算每个node的优先级得分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	priorityList, err := PrioritizeNodes(pod, g.nodeInfoSnapshot.NodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> result, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	trace.Step(<span class="string">"Selecting host"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 找到优先级得分最大的node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	host, err := g.selectHost(priorityList)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> ScheduleResult&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		SuggestedHost:  host,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		EvaluatedNodes: <span class="built_in">len</span>(filteredNodes) + <span class="built_in">len</span>(failedPredicateMap),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		FeasibleNodes:  <span class="built_in">len</span>(filteredNodes),</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文仅讲解了调度器启动前的初始化过程以及调度整体流程，细节实现还需读者自行了解。</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>功能组件</category>
        <category>调度器</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s调度器</tag>
      </tags>
  </entry>
  <entry>
    <title>sync.Mutex源码</title>
    <url>/blog/2019/07/06/20190706025011.html</url>
    <content><![CDATA[<p>TOC</p>
<p>首先看下源码文件 sync/mutex.go里边开头的注释</p>
<blockquote>
<p>sync包提供基本同步原语，如互斥锁，除了Once和WaitGroup外，大多数类型都是供低层级库的协程使用，更高级别的同步最好通过通道和通信来完成，不应复制包含此包中定义的类型的值。</p>
</blockquote>
<p>由注释可以看出，官方建议使用channel来做同步，而且此包中的值不允许复制，主要原因是，复制后加锁和解锁操作就不作用在同一个对象上，这样就会出问题。如下例子运行时会报<code>unlock of unlocked mutex</code>错误：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock := sync.Mutex&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Lock(lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock.Unlock()<span class="comment">// 此行panic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 调用此函数时会发生复制，这里加锁针对的是副本加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 源lock未加锁，因此上边调用加锁会发生panic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// sync包下其他类型复制会发生同样问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lock</span><span class="params">(lock sync.Mutex)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>再看下定义常量下边的注释：</p>
<blockquote>
<p>锁公平：</p>
<p>互斥可以有两种操作模式：正常和饥饿。</p>
<ol>
<li><p>在正常模式下，等待加锁的G按FIFO顺序排队，但被唤醒的waiter并不持有锁，它们与新来的G争夺所有权，新来的G有一个优势，它们已经在CPU上运行，而且可能有很多，所以一个被唤醒的G很有可能抢不到锁，在这种情况下，它将在等待队列前面排队，如果有waiter超过1ms无法获取互斥量，则互斥量mutex进入饥饿模式；</p>
</li>
<li><p>在饥饿模式下，互斥体的所有权直接从解锁的G移交给队列前边的waiter，新来的G不会去争夺锁，即使它看起来是解锁的，也不会去spinning，它们会在队尾排队。如果waiter收到互斥的所有权，并看到①它是队列中最后一个waiter或②它等待不到1ms，它将从互斥模式切换回正常模式。</p>
</li>
</ol>
<p>正常模式有相当好的性能，因为Goroutine可以连续多次获取互斥，即使有阻塞的等待程序。饥饿模式对预防尾部潜伏期病变具有重要意义。</p>
</blockquote>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	state <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sema  <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其中 Mutex.sema表示信号量，Mutex.status字段每一位含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state:   |32|31|...| |3|2|1|</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \__________&#x2F; | | |</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       | | |</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       | | +--- mutex的占用状态（1被占用，0可用）</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       | |</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       | +---mutex的当前goroutine是否被唤醒</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |       +---饥饿位，0正常，1饥饿</span></pre></td></tr><tr><td class="code"><pre><span class="line">              |</span></pre></td></tr><tr><td class="code"><pre><span class="line">              +---等待唤醒以尝试锁定的goroutine的计数，0表示没有等待者</span></pre></td></tr></table></figure>


<h1 id="加锁解锁方法源码"><a href="#加锁解锁方法源码" class="headerlink" title="加锁解锁方法源码"></a>加锁解锁方法源码</h1><p>Mutex一共有两个方法：<code>Lock()</code> 和 <code>Unlock()</code></p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a><code>Lock()</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁定Mutex.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// blocks until the mutex is available.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			race.Acquire(unsafe.Pointer(m))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	starving := <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	awoke := <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	iter := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	old := m.state</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Don't spin in starvation mode, ownership is handed off to waiters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// so we won't be able to acquire the mutex anyway.// 如果原状态为非饥饿模式的锁定状态，且canSpin，看样子是根据iter大小判断是否canSpin</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// Active spinning makes sense.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 尝试设置mutexWoken标记来通知Unlock，不去唤醒其他阻塞的G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; <span class="comment">// 再次确认未被唤醒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp; <span class="comment">// 确认有G在排队</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123; <span class="comment">// 将对象锁置为唤醒状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">				awoke = <span class="literal">true</span> <span class="comment">// 标记当前G awoke</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			runtime_doSpin() <span class="comment">// 空转，根据iter，重试一定次数将不再空转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			iter++<span class="comment">// 自旋次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			old = m.state <span class="comment">// 更新old</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">new</span> := old <span class="comment">// 不可空转、 或 ！非饥饿模式的锁定状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 不要试图获取饥饿的mutex，新来的G必须排队.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 若old是非饥饿模式，标记加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">new</span> |= mutexLocked</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123; <span class="comment">// 如果old 已加锁/饥饿模式/加锁数!=0 则加锁数+1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.当前G切换到饥饿模式，但若mutex当前未加锁，则不切换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don't do the switch.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// be true in this case.  Unlock期望饥饿模式下有等待者，这种情况下不会为true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123; <span class="comment">// 若处于饥饿模式，且(已加锁或有waiter)，则new饥饿位做标记</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">new</span> |= mutexStarving</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> awoke &#123; <span class="comment">// 如果唤醒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123; <span class="comment">// 如果new的mutexWoken位为0，则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				throw(<span class="string">"sync: inconsistent mutex state"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;<span class="comment">// 将唤醒位置0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;<span class="comment">// 获锁成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123; <span class="comment">// 如果old值锁位与饥饿位标志都为0，则说明获锁成功直接break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			queueLifo := waitStartTime != <span class="number">0</span> <span class="comment">// 如果队列不为0，则入队</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				waitStartTime = runtime_nanotime()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span></pre></td></tr><tr><td class="code"><pre><span class="line">			old = m.state</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					throw(<span class="string">"sync: inconsistent mutex state"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// Exit starvation mode.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// to starvation mode.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					delta -= mutexStarving</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			awoke = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			iter = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			old = m.state</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		race.Acquire(unsafe.Pointer(m))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock()"></a><code>Unlock()</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks m.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 一个加锁状态的mutex不会与特定的G关联，允许在一个G加锁在另一个G解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_ = m.state</span></pre></td></tr><tr><td class="code"><pre><span class="line">		race.Release(unsafe.Pointer(m))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Fast path: drop lock bit.  快速路径，删除锁标记</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 如果new的饥饿标记位为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		old := <span class="built_in">new</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// So get off the way.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 如果没有waiter或有G已经被唤醒或获得锁，不必再去唤醒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 在饥饿模式，解锁的G直接将锁所有权移交给下一个waiter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 我们不是</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || <span class="comment">// 没有waiter在排队</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;<span class="comment">// 处于锁定、唤醒、饥饿状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 抓住唤醒一个waiter的机会</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			old = m.state</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// so new coming goroutines won't acquire it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 饥饿模式：移交mutex所有权到下一个waiter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 注意：MutexLocked没有被设置，waiter将会在唤醒后设置它，但如果mutexStarving被设置的情况下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 需要考虑锁定mutex，因此新到达的G不会获得锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go-channel基础</title>
    <url>/blog/2019/07/01/20190701004200.html</url>
    <content><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><blockquote>
<p>首先看一下<code>channel</code>的结构定义</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// 队列长度，缓冲区中入队的数据长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列总长度，即缓冲区总长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	buf      unsafe.Pointer <span class="comment">// 队列中的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	elemsize <span class="keyword">uint16</span>			<span class="comment">//  chan中元素类型长度(unsafe.Sizeof(type))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	closed   <span class="keyword">uint32</span>			<span class="comment">//  是否关闭，0，1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	elemtype *_type <span class="comment">// chan中元素类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// 发送元素的索引 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// 接受元素的索引(配合sendx和buf，可以得到缓冲区真正的数据)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	recvq    waitq  <span class="comment">// 等待接收数据的g队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sendq    waitq  <span class="comment">// 等待发送数据的g队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// with stack shrinking.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock mutex      <span class="comment">// 锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="有缓冲channel"><a href="#有缓冲channel" class="headerlink" title="有缓冲channel"></a>有缓冲channel</h1><p>对于一个有缓冲的通道，有如下规则：</p>
<ol>
<li>发送操作会使通道复制被发送的元素。若因通道缓冲区已满而无法复制，则会阻塞发送操作的goroutine。复制的目的地有两种：①当通道缓冲区无数据且有接收方在等待接收数据时，数据将会被直接复制到接收方持有的内存地址；②否则，复制到通道的buf中</li>
<li>接收操作会使通道给出一个已发送给它的元素值的副本，如果通道无数据，则会阻塞接收操作的goroutine</li>
<li>对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道接受它的操作完成之前完成</li>
</ol>
<p>注意：</p>
<ol>
<li>channel变量是引用类型，因此它的初始值为nil，向一个nil的channel发送或接收数据将会导致永久阻塞</li>
<li>发送方向通道发送的数据会被复制，至少1次，最多两次。①1次的情形：A 已有接收方阻塞且通道无缓冲数据;B 无缓冲的channel ②2次情形：无缓冲channel不会复制2次，有缓冲channel只要缓冲区有数据，则都会发生两次</li>
</ol>
<h1 id="happen-before"><a href="#happen-before" class="headerlink" title="happen before"></a>happen before</h1><h2 id="发送操作与接收操作的happen-before"><a href="#发送操作与接收操作的happen-before" class="headerlink" title="发送操作与接收操作的happen before"></a>发送操作与接收操作的happen before</h2><ol>
<li>无缓冲channel：接收操作完成都在发送操作完成后</li>
<li>有缓冲channel：缓冲长度为k，第c个数据接收完成发送在第k+c个数据发送之前</li>
</ol>
<h2 id="发送操作前后代码的happen-before"><a href="#发送操作前后代码的happen-before" class="headerlink" title="发送操作前后代码的happen before"></a>发送操作前后代码的happen before</h2><pre class="mermaid">graph TD;
subgraph 协程 g1
1-->idch1(channel操作)
idch1-->A
A-->X
end
subgraph 协程 g2
2-->idch2(channel操作)
idch2-->B
B-->Y
end</pre>
<p>解释：<br>如上图两个协程 g1 和 g2，channel操作指的是读或者写操作，这里两个协程一读一写。happen-before会使代码执行有以下顺序：</p>
<ol>
<li>1 -&gt; B -&gt; Y  </li>
<li>2 -&gt; A -&gt; X </li>
<li>1 -&gt; A -&gt; X</li>
<li>2 -&gt; B -&gt; Y<br>其他顺序无法保证，比如： A与B、Y，B与A、X，1与2，整体顺序如下图：<pre class="mermaid">graph TD;
subgraph 协程 g1
1-->idch1(channel操作)
idch1-->A
A-->X
end
subgraph 协程 g2
2-->idch2(channel操作)
idch2-->B
B-->Y
end
1-->idch2
idch2-->A
2-->idch1
idch1-->B</pre>

</li>
</ol>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="向通道写数据"><a href="#向通道写数据" class="headerlink" title="向通道写数据"></a>向通道写数据</h2><ol>
<li><p>先判断是否有读channel的G阻塞到这里，如果有，则直接将数据复制到等待读数据的G的elem域，并将其标记为<code>_Grunnable</code>，结束</p>
</li>
<li><p>否则，判断channel中已有数据是否小于缓冲大小，如果小于，则将数据复制到channel的循环队列中，结束</p>
</li>
<li><p>否则，判断如果是非阻塞，则直接返回false，表示写数据失败</p>
</li>
<li><p>否则，获取当前g，封装sudog，并把sudog放到channel的sendq域，然后将其标记为<code>_Gwating</code>，等有数据被读取，这里会被唤醒，并执行后续代码，最后返回true</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 1  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		qp := chanbuf(c, c.sendx)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceacquire(qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			racerelease(qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		typedmemmove(c.elemtype, qp, ep)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.sendx++</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			c.sendx = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.qcount++</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !block &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 4  // Block on the channel. Some receiver will complete our operation for us.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg := acquireSudog()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.releasetime = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		mysg.releasetime = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.elem = ep</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.waitlink = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.g = gp</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.isSelect = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.c = c</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.waiting = mysg</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.param = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.sendq.enqueue(mysg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	releaseSudog(mysg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="从通道读数据"><a href="#从通道读数据" class="headerlink" title="从通道读数据"></a>从通道读数据</h2></li>
<li><p>如果channel已关闭，且缓冲区无数据，则直接返回</p>
</li>
<li><p>否则，判断通道是否有写数据的G阻塞，如果有，则调用recv()函数并直接返回<br>2.1 recv()  如果缓冲区无数据，则直接将数据从sudog的G.elem中copy到ep<br>2.2 recv()  否则，将缓冲区第一个数据copy到ep中，并将阻塞的G.elem数据copy到缓冲区队列<br>2.3 recv()  将sudog.g的状态从<code>_Gwaiting</code>转为<code>_Grunnable</code></p>
</li>
<li><p>否则，若缓冲区队列已有数据，则直接从缓冲区复制，直接返回</p>
</li>
<li><p>否则，若非阻塞，直接返回失败</p>
</li>
<li><p>否则，获取当前g，初始化sudog，将sudog放至channel.recvq队列中，并将状态转至<code>_Gwaiting</code>，等待唤醒</p>
</li>
<li><p>唤醒之后，执行后续逻辑，返回接收数据成功</p>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceacquire(c.raceaddr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			typedmemclr(c.elemtype, ep)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Receive directly from queue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		qp := chanbuf(c, c.recvx)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceacquire(qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			racerelease(qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			typedmemmove(c.elemtype, ep, qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		typedmemclr(c.elemtype, qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.recvx++</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			c.recvx = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.qcount--</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !block &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;c.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg := acquireSudog()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.releasetime = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		mysg.releasetime = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.elem = ep</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.waitlink = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.waiting = mysg</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.g = gp</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.isSelect = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.c = c</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.param = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.recvq.enqueue(mysg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// someone woke us up</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.waiting = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	closed := gp.param == <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.param = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mysg.c = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	releaseSudog(mysg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/select.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// A runtimeSelect is a single case passed to rselect.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// This must match ../reflect/value.go:/runtimeSelect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> runtimeSelect <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dir selectDir      <span class="comment">// selectSend、selectRecv、selectDefault 分别代表case里的事件 发送、接收、default</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	typ unsafe.Pointer <span class="comment">// channel type (not used here)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ch  *hchan         <span class="comment">// channel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	val unsafe.Pointer <span class="comment">// ptr to data (SendDir) or ptr to receive buffer (RecvDir)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		block()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		rc := &amp;cases[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">switch</span> rc.dir &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> selectDefault:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sel[i] = scase&#123;kind: caseDefault&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> selectSend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> selectRecv:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> raceenabled || msanenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			selectsetpc(&amp;sel[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Select case descriptor.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Known to compiler.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's scasetype.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c           *hchan         <span class="comment">// chan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	kind        <span class="keyword">uint16</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	releasetime <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上代码，初始时，会遍历select里的所有case，并将这些case放入scase数组，scase数组描述每个case的事件，最后将其作为参数调用<code>selectgo</code>方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// selectgo 实现了select的功能.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// selectgo 返回选中的nscase在数组cas0中的下标，它也是select调用语句中对应位置的序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 如果选中的scase事件是channel接收事件，第二个参数表示是否有值发送到接收方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">print</span>(<span class="string">"select: cas0="</span>, cas0, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	scases := cas1[:ncases:ncases]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	pollorder := order1[:ncases:ncases]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lockorder := order1[ncases:][:ncases:ncases]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cas := &amp;scases[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			*cas = scase&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		t0 = cputicks()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			scases[i].releasetime = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// generate permuted order</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pollorder[i] = pollorder[j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		j := i</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		c := scases[pollorder[i]].c</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			lockorder[j] = lockorder[k]</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j = k</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		lockorder[j] = pollorder[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		o := lockorder[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c := scases[o].c</span></pre></td></tr><tr><td class="code"><pre><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		j := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				k++</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				lockorder[j] = lockorder[k]</span></pre></td></tr><tr><td class="code"><pre><span class="line">				j = k</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		lockorder[j] = o</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="built_in">print</span>(<span class="string">"i="</span>, i, <span class="string">" x="</span>, lockorder[i], <span class="string">" y="</span>, lockorder[i+<span class="number">1</span>], <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				throw(<span class="string">"select: broken sort"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sellock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">		gp     *g</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg     *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c      *hchan</span></pre></td></tr><tr><td class="code"><pre><span class="line">		k      *scase</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sglist *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sgnext *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">		qp     unsafe.Pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">		nextp  **sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">	)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> dfli <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> dfl *scase</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> casi <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> cas *scase</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> recvOK <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		casi = <span class="keyword">int</span>(pollorder[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cas = &amp;scases[casi]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c = cas.c</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseNil:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseRecv:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sg = c.sendq.dequeue()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> recv</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> bufrecv</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> rclose</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseSend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> sclose</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sg = c.recvq.dequeue()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> send</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">goto</span> bufsend</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseDefault:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			dfli = casi</span></pre></td></tr><tr><td class="code"><pre><span class="line">			dfl = cas</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		casi = dfli</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cas = dfl</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp = getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		throw(<span class="string">"gp.waiting != nil"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	nextp = &amp;gp.waiting</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		casi = <span class="keyword">int</span>(casei)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cas = &amp;scases[casi]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c = cas.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg := acquireSudog()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg.g = gp</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg.isSelect = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg.elem = cas.elem</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg.releasetime = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			sg.releasetime = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg.c = c</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		*nextp = sg</span></pre></td></tr><tr><td class="code"><pre><span class="line">		nextp = &amp;sg.waitlink</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseRecv:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			c.recvq.enqueue(sg)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> caseSend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			c.sendq.enqueue(sg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// wait for someone to wake us up</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.param = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sellock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.selectDone = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sg = (*sudog)(gp.param)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.param = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// record the successful case, if any.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	casi = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cas = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sglist = gp.waiting</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg1.isSelect = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg1.elem = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		sg1.c = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gp.waiting = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		k = &amp;scases[casei]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			k.releasetime = sglist.releasetime</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			casi = <span class="keyword">int</span>(casei)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			cas = k</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			c = k.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				c.sendq.dequeueSudoG(sglist)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				c.recvq.dequeueSudoG(sglist)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sgnext = sglist.waitlink</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sglist.waitlink = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		releaseSudog(sglist)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sglist = sgnext</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// we'll see that it's now closed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// so we won't block again.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">goto</span> loop</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c = cas.c</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">print</span>(<span class="string">"wait-return: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">" cas="</span>, cas, <span class="string">" kind="</span>, cas.kind, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		recvOK = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			msanwrite(cas.elem, c.elemtype.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			msanread(cas.elem, c.elemtype.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">bufrecv:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// can receive from buffer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		raceacquire(chanbuf(c, c.recvx))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		racerelease(chanbuf(c, c.recvx))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	recvOK = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	qp = chanbuf(c, c.recvx)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	typedmemclr(c.elemtype, qp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.recvx++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.recvx = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.qcount--</span></pre></td></tr><tr><td class="code"><pre><span class="line">	selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">bufsend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// can send to buffer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		raceacquire(chanbuf(c, c.sendx))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		racerelease(chanbuf(c, c.sendx))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		msanread(cas.elem, c.elemtype.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.sendx++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.sendx = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.qcount++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">recv:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	recvOK = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">rclose:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// read at end of closed channel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	recvOK = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		typedmemclr(c.elemtype, cas.elem)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		raceacquire(c.raceaddr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">send:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		msanread(cas.elem, c.elemtype.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">goto</span> retc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">retc:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> casi, recvOK</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sclose:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// send on closed channel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	selunlock(scases, lockorder)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>channel</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine状态变换</title>
    <url>/blog/2019/06/27/20190627235500.html</url>
    <content><![CDATA[<h1 id="G状态变换"><a href="#G状态变换" class="headerlink" title="G状态变换"></a>G状态变换</h1><pre class="mermaid">graph TD;

id1((Start))-->|新建|Gidle
Gidle-->|初始化|Grunnable
Grunnable-->|开始运行|Grunning
Grunning-->|运行完成|Gdead

Gdead-->|结束|id100((End))

Grunning-->|等待事件|Gwaiting
Gwaiting-->|"事件到来，G去向「①p.runq ②sched.runq ③running」"|Grunnable

Grunning-->|"进入系统调用，此时如果可用M不够用会创建线程"|Gsyscall
Gsyscall-->|"退出系统调用，被放入调度器可运行队列"|id2{是否可直接运行}
id2-->|是|Grunning
id2-->|否|Grunnable
Grunning-->|需要扩展/收缩栈|Gcopystack
Gcopystack-->|扩展收缩栈完成|Grunning
Gdead-->|重新初始化|Grunnable</pre>
<h1 id="P状态变换"><a href="#P状态变换" class="headerlink" title="P状态变换"></a>P状态变换</h1><pre class="mermaid">graph TD;

id0((Start))-->|新建|Pgcstop
Pgcstop-->|完成初始化|Pidle
Pgcstop-->|启动调度|Pidle
Pidle-->|与某个M建立关联|Prunning
Prunning-->|与某个M断开关联|Pidle
Prunning-->|进入系统调用|Psyscall
Psyscall-->|退出系统调用|Prunning
Pdead-->|结束|id100((End))

Pidle-->|丢弃|Pdead
Prunning-->|丢弃|Pdead
Psyscall-->|丢弃|Pdead
Psyscall-->|停止调度|Pgcstop
Pidle-->|停止调度|Pgcstop
Prunning-->|停止调度|Pgcstop</pre>




]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>go程序启动过程分析</title>
    <url>/blog/2019/06/27/20190627220000.html</url>
    <content><![CDATA[<blockquote>
<p>os：osx 10.14.5</p>
<p>go version: 1.12.5 darwin/amd64</p>
<p>不加特说说明的文件都是在 runtime 包下</p>
</blockquote>
<h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><blockquote>
<p>整个程序入口是在 <code>rt0_darwin_amd64.s</code>的第8行。此处只有一行汇编<code>JMP _rt0_amd64(SB)</code>,跳转到<code>asm_amd64.s</code>中的第14行，配置好 <code>argc</code> <code>argv</code>后又跳转到 <code>rt0_go</code>(87行)。正式开始初始化go程序的运行时环境。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 将参数向前复制到一个偶数栈上</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	DI, AX		&#x2F;&#x2F; argc</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	SI, BX		&#x2F;&#x2F; argv</span></pre></td></tr><tr><td class="code"><pre><span class="line">	SUBQ	$(4*8+7), SP		&#x2F;&#x2F; 2args 2auto</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ANDQ	$~15, SP</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	AX, 16(SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	BX, 24(SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 从给定（操作系统）栈中创建 istack。</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; _cgo_init 可能更新 stackguard</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	$runtime·g0(SB), DI</span></pre></td></tr><tr><td class="code"><pre><span class="line">	LEAQ	(-64*1024+104)(SP), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	BX, g_stackguard0(DI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	BX, g_stackguard1(DI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 寻找正在运行的处理器信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVL	$0, AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CPUID</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVL	AX, SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; CPU 相关的一些检测</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#ifdef GOOS_darwin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 跳过 TLS 设置 on Darwin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	JMP ok</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·settls(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 使用它进行存储，确保能正常运行</span></pre></td></tr><tr><td class="code"><pre><span class="line">	get_tls(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	$0x123, g(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CMPQ	AX, $0x123</span></pre></td></tr><tr><td class="code"><pre><span class="line">	JEQ 2(PC)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·abort(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">ok:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 程序刚刚启动，此时位于主 OS 线程</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 设置 per-goroutine 和 per-mach 寄存器</span></pre></td></tr><tr><td class="code"><pre><span class="line">	get_tls(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	LEAQ	runtime·g0(SB), CX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	CX, g(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	LEAQ	runtime·m0(SB), AX</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 保存 m-&gt;g0 &#x3D; g0</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	CX, m_g0(AX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 保存 m0 to g0-&gt;m</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	AX, g_m(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CLD				&#x2F;&#x2F; 约定 D 总是被清除</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·check(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVL	16(SP), AX		&#x2F;&#x2F; 复制 argc</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVL	AX, 0(SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	24(SP), AX		&#x2F;&#x2F; 复制 argv</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	AX, 8(SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·args(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·osinit(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·schedinit(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 创建一个新的 goroutine 来启动程序</span></pre></td></tr><tr><td class="code"><pre><span class="line">	MOVQ	$runtime·mainPC(SB), AX		&#x2F;&#x2F; 入口</span></pre></td></tr><tr><td class="code"><pre><span class="line">	PUSHQ	AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	PUSHQ	$0			&#x2F;&#x2F; 参数大小</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·newproc(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	POPQ	AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">	POPQ	AX</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 启动这个 M</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·mstart(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	CALL	runtime·abort(SB)	&#x2F;&#x2F; mstart 应该永不返回</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RET</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RET</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">DATA	runtime·mainPC+0(SB)&#x2F;8,$runtime·main(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$8</span></pre></td></tr></table></figure>

<h1 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h1><blockquote>
<p>从上边汇编代码可以看出，整个过程按如下顺序执行：</p>
<ol>
<li>初始化系统运行时信息</li>
<li>初始化调度时全局变量 m0 g0及关联关系</li>
<li>runtime.check (实现在runtime1.go)对编译器工作进行校验，确保运行时类型正确</li>
<li>runtime.args (runtime1.go).处理程序参数</li>
<li>runtime.osinit (不同os在不同文件，os_darwin.go).获得CPU核心数</li>
<li>runtime.schedinit (proc.go). 初始化调度器</li>
<li>runtime.newproc (proc.go). 根据主goroutine入口地址创建G，并放至G队列中。</li>
<li>runtime.mstart (proc.go). 开始调度循环</li>
</ol>
</blockquote>
<h1 id="部分过程详细"><a href="#部分过程详细" class="headerlink" title="部分过程详细"></a>部分过程详细</h1><h2 id="runtime-schedinit-和-runtime-newproc"><a href="#runtime-schedinit-和-runtime-newproc" class="headerlink" title="runtime.schedinit 和 runtime.newproc"></a>runtime.schedinit 和 runtime.newproc</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	\_g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 最大系统线程数量（即 M），参考标准库 runtime/debug.SetMaxThreads</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sched.maxmcount = <span class="number">10000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 模块数据验证</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	moduledataverify()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 栈、内存分配器、调度器相关初始化。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 栈初始化，复用管理链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	stackinit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 内存分配器初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mallocinit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 初始化当前 M</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mcommoninit(_g_.m)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// cpu 相关的初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cpuinit() <span class="comment">// 必须在 alginit 之前运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	alginit() <span class="comment">// maps 不能在此调用之前使用，从 CPU 指令集初始化哈希算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 模块加载相关的初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	modulesinit()   <span class="comment">// 模块链接，提供 activeModules</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	typelinksinit() <span class="comment">// 使用 maps, activeModules</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	itabsinit()     <span class="comment">// 初始化 interface table，使用 activeModules</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 信号屏蔽字初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	msigsave(_g_.m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	initSigmask = _g_.m.sigmask</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 处理y命令行用户参数和环境变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	goargs()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	goenvs()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 处理 GODEBUG、GOTRACEBACK 调试相关的环境变量设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	parsedebugvars()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 垃圾回收器初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gcinit()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 网络的上次轮询时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 通过 CPU 核心数和 GOMAXPROCS 环境变量确定 P 的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	procs := ncpu</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		procs = n</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 调整 P 的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 这时所有 P 均为新建的 P，因此不能返回有本地任务的 P</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 不重要，调试相关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// For cgocheck &gt; 1, we turn on the write barrier at all times</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// and check all pointer writes. We can't do this until after</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// procresize because the write barrier needs a P.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> debug.cgocheck &gt; <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		writeBarrier.cgo = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		writeBarrier.enabled = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			p.wbBuf.reset()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> buildVersion == <span class="string">""</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 该条件永远不会被触发，此处只是为了防止 buildVersion 被编译器优化移除掉。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		buildVersion = <span class="string">"unknown"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="核心组件初始化"><a href="#核心组件初始化" class="headerlink" title="核心组件初始化"></a>核心组件初始化</h3><h4 id="msigsave"><a href="#msigsave" class="headerlink" title="msigsave"></a>msigsave</h4><h4 id="stackinit"><a href="#stackinit" class="headerlink" title="stackinit"></a>stackinit</h4><p>goroutine栈结构</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// stack 描述了实际的栈内存：[stack.lo, stack.hi)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	stack stack</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// stackguard0 是对比 Go 栈增长的 prologue 的栈指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 如果 sp 寄存器比 stackguard0 小（由于栈往低地址方向增长），会触发栈拷贝和调度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 通常情况下：stackguard0 = stack.lo + StackGuard，但被抢占时会变为 StackPreempt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	stackguard0 <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// stackguard1 是对比 C 栈增长的 prologue 的栈指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 当位于 g0 和 gsignal 栈上时，值为 stack.lo + StackGuard</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 在其他栈上值为 ~0 用于触发 morestackc (并 crash) 调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	stackguard1 <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// sched 描述了执行现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sched       gobuf</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>G的创建：(<code>proc.go</code>  <code>newproc()</code>)</p>
<blockquote>
<ol>
<li>首先检查go函数及其参数的合法性</li>
<li>尝试从本地P的自由G列表和调度器的自由G列表获取可用G(line3271:gfget(<code>_p_</code>))，如果未获取到，则新建G(line3273:malg(_StackMin))</li>
<li>初始化G，包括关联go函数及设置该G的状态和ID等</li>
<li>尝试将G放入本地P的runnext字段(line3348:runqput())：如果runnext为空，则直接放到runnext并返回；如果不为空，则替换，并将原runnext值放到本地P.runq末尾，如果满了将后一半的G移动至全局G队列</li>
</ol>
</blockquote>
<h4 id="mallocinit"><a href="#mallocinit" class="headerlink" title="mallocinit"></a>mallocinit</h4><p>内存分配器的初始化除去一些例行检查外，就是对堆的初始化了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 一些涉及内存分配器的常量的检查，包括</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// heapArenaBitmapBytes, physPageSize 等等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 初始化堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mheap_.init()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_g_.m.mcache = allocmcache()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 创建初始的 arena 增长 hint</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; GOARCH != <span class="string">"wasm"</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">var</span> p <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">switch</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span></pre></td></tr><tr><td class="code"><pre><span class="line">			hint.addr = p</span></pre></td></tr><tr><td class="code"><pre><span class="line">			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 32 位机器，不关心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>堆的初始化：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 初始化堆中各个组件的分配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.treapalloc.init(unsafe.Sizeof(treapNode&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 不对 mspan 的分配清零，后台扫描可以通过分配它来并发的检查一个 span</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 因此 span 的 sweepgen 在释放和重新分配时候能存活，从而可以防止后台扫描</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 不正确的将其从 0 进行 CAS。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 因为 mspan 不包含堆指针，因此它是安全的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	h.spanalloc.zero = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// h-&gt;mapcache 不需要初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		h.central[i].mcentral.init(spanClass(i))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="mcommoninit"><a href="#mcommoninit" class="headerlink" title="mcommoninit"></a>mcommoninit</h4><p>M初始化</p>
<blockquote>
<p>M 创建时机：</p>
<ol>
<li>程序运行之初的 M0，无需创建已经存在的系统线程，只需对其进行初始化即可。<br>1.1 schedinit –&gt; mcommoninit –&gt; mpreinit –&gt; msigsave –&gt; initSigmask –&gt; mstart</li>
<li>需要时创建的 M，某些特殊情况下一定会创建一个新的 M并进行初始化，而后创建系统线程：<br>2.1 startm 时没有空闲 m<br>2.2 startTemplateThread 时<br>2.3 startTheWorldWithSema 时 p 如果没有 m<br>2.4 main 时创建系统监控<br>2.5 oneNewExtraM 时<br>2.6 初始化过程： newm –&gt; allocm –&gt; mcommoninit –&gt; mpreinit –&gt; newm1 –&gt; newosproc –&gt; mstart</li>
</ol>
</blockquote>
<p>P初始化</p>
<blockquote>
</blockquote>
<p>G初始化</p>
<blockquote>
<p>创建 G 的过程也是相对比较复杂的，我们来总结一下这个过程：<br>首先尝试从 P 本地 gfree 链表或全局 gfree 队列获取已经执行过的、已经执行过的 g 初始化过程中程序无论是本地队列还是全局队列都不可能获取到 g，因此创建一个新的 g，并为其分配运行线程（执行栈）。<br>这时 g 处于 _Gidle 状态创建完成后，g 被更改为 _Gdead 状态，并根据要执行函数的入口地址和参数，初始化执行栈的 SP 和参数的入栈位置，并将需要的参数拷贝一份存入执行栈中根据 SP、参数，在 g.sched 中保存 SP 和 PC 指针来初始化 g 的运行现场将调用方、要执行的函数的入口 PC 进行保存，并将 g 的状态更改为 _Grunnable给 goroutine 分配 id，并将其放入 P 本地队列的队头或全局队列（初始化阶段队列肯定不是满的，因此不可能放入全局队列）检查空闲的 P，将其唤醒，准备执行 G，但我们目前处于初始化阶段，主 goroutine 尚未开始执行，因此这里不会唤醒 P。</p>
</blockquote>
<h4 id="gcinit"><a href="#gcinit" class="headerlink" title="gcinit"></a>gcinit</h4><h4 id="procresize"><a href="#procresize" class="headerlink" title="procresize"></a>procresize</h4><blockquote>
<ol>
<li>调用时已经 STW；</li>
<li>记录调整 P 的时间；</li>
<li>按需调整 allp 的大小；</li>
<li>按需初始化 allp 中的 P；</li>
<li>从 allp 移除不需要的 P，将释放的 P 队列中的任务扔进全局队列；</li>
<li>如果当前的 P 还可以继续使用（没有被移除），则将 P 设置为 _Prunning；</li>
<li>否则将第一个 P 抢过来给当前 G 的 M 进行绑定</li>
<li>最后挨个检查 P，将没有任务的 P 放入 idle 队列</li>
<li>出去当前 P 之外，将有任务的 P 彼此串联成链表，将没有任务的 P 放回到 idle 链表中</li>
</ol>
</blockquote>
<h2 id="runtime-mstart"><a href="#runtime-mstart" class="headerlink" title="runtime.mstart"></a>runtime.mstart</h2>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine实例与分析</title>
    <url>/blog/2019/06/25/20190625000000.html</url>
    <content><![CDATA[<h2 id="实例1：多个goroutine在单个P上运行时调度队列分析"><a href="#实例1：多个goroutine在单个P上运行时调度队列分析" class="headerlink" title="实例1：多个goroutine在单个P上运行时调度队列分析"></a>实例1：多个goroutine在单个P上运行时调度队列分析</h2><p>示例代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"runtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"sync"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	num := <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg := sync.WaitGroup&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.Add(num)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Printf(<span class="string">"%d "</span>,i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			wg.Done()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.Wait()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span></pre></td></tr></table></figure>
<blockquote>
<p>此处打印结果应该是不定的，大多数是 9012345678。</p>
<p>原因：在创建协程时，当前协程会先把它放到本地P的runnext中去，该字段用于存放新创建的G，以求更早地运行它，如果此时runnext字段已有一个G，那么这个已有的G就会被踢到P的可运行G队列末尾。此处协程里逻辑比较简单，运行速度很快，所以大多数情况都会按 9 0-8这样顺序调度，如果协程里逻辑比较复杂、CPU执行效率低下或调度器执行了调度了其他任务，结果就可能与这里有出入。</p>
<p>更改num的值，在num值改为小于等于257，都按上述流程工作，因为P本地G队列长度为256，再加上runnext，P本地就可以持有257个G，当大于257个G创建时，它们会被放到全局G队列中去（如果p.runq满，其中一半的G会被转移到调度器的可运行G队列中）</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine总结</title>
    <url>/blog/2019/06/24/20190624000000.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]go调度器源码分析</title>
    <url>/blog/2019/06/23/20190623220012.html</url>
    <content><![CDATA[<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>goroutine 在 runtime 中的数据结构:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 如果从传统内存布局的角度来讲，Go 的栈实际上是分配在 C 语言中的堆区的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 所以才能比 ulimit -s 的 stack size 还要大(1GB)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lo <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    hi <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// g 的运行现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp   <span class="keyword">uintptr</span>    <span class="comment">// sp 寄存器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pc   <span class="keyword">uintptr</span>    <span class="comment">// pc 寄存器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    g    guintptr   <span class="comment">// g 指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctxt unsafe.Pointer <span class="comment">// 这个似乎是用来辅助 gc 的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret  sys.Uintreg</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lr   <span class="keyword">uintptr</span>    <span class="comment">// 这是在 arm 上用的寄存器，不用关心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    bp   <span class="keyword">uintptr</span>    <span class="comment">// 开启 GOEXPERIMENT=framepointer，才会有这个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 简单数据结构，lo 和 hi 成员描述了栈的下界和上界内存地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack       stack</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在函数的栈增长 prologue 中用 sp 寄存器和 stackguard0 来做比较</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果 sp 比 stackguard0 小(因为栈向低地址方向增长)，那么就触发栈拷贝和调度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 正常情况下 stackguard0 = stack.lo + StackGuard</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 不过 stackguard0 在需要进行调度时，会被修改为 StackPreempt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 以触发抢占s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stackguard0 <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// stackguard1 是在 C 栈增长 prologue 作对比的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在 g0 和 gsignal 栈上，其值为 stack.lo+StackGuard</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在其它的栈上这个值是 ~0(按 0 取反)以触发 morestack 调用(并 crash)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stackguard1 <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _panic         *_panic</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _defer         *_defer</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m              *m             <span class="comment">// 当前与 g 绑定的 m</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sched          gobuf          <span class="comment">// goroutine 的现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    syscallsp      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    syscallpc      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stktopsp       <span class="keyword">uintptr</span>        <span class="comment">// expected sp at top of stack, to check in traceback</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    param          unsafe.Pointer <span class="comment">// wakeup 时的传入参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    atomicstatus   <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stackLock      <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    goid           <span class="keyword">int64</span>  <span class="comment">// goroutine id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waitsince      <span class="keyword">int64</span>  <span class="comment">// g 被阻塞之后的近似时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waitreason     <span class="keyword">string</span> <span class="comment">// if status==Gwaiting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    schedlink      guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    preempt        <span class="keyword">bool</span>     <span class="comment">// 抢占标记，这个为 true 时，stackguard0 是等于 stackpreempt 的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    throwsplit     <span class="keyword">bool</span>     <span class="comment">// must not split stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    raceignore     <span class="keyword">int8</span>     <span class="comment">// ignore race detection events</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sysblocktraced <span class="keyword">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sysexitticks   <span class="keyword">int64</span>    <span class="comment">// syscall 返回之后的 cputicks，用来做 tracing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    traceseq       <span class="keyword">uint64</span>   <span class="comment">// trace event sequencer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lockedm        muintptr <span class="comment">// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sig            <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    writebuf       []<span class="keyword">byte</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigcode0       <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigcode1       <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigpc          <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gopc           <span class="keyword">uintptr</span> <span class="comment">// 创建该 goroutine 的语句的指令地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    startpc        <span class="keyword">uintptr</span> <span class="comment">// goroutine 函数的指令地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    racectx        <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    labels         unsafe.Pointer <span class="comment">// profiler labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    timer          *timer         <span class="comment">// time.Sleep 缓存的定时器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    selectDone     <span class="keyword">uint32</span>         <span class="comment">// 该 g 是否正在参与 select，是否已经有人从 select 中胜出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当 g 遇到阻塞，或需要等待的场景时，会被打包成 sudog 这样一个结构。一个 g 可能被打包为多个 sudog 分别挂在不同的等待队列上:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 代表在等待列表里的 g，比如向 channel 发送/接收内容时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 之所以需要 sudog 是因为 g 和同步对象之间的关系是多对多的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 一个 g 可能会在多个等待队列中，所以一个 g 可能被打包为多个 sudog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 多个 g 也可以等待在同一个同步对象上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 因此对于一个同步对象就会有很多 sudog 了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 是从一个特殊的池中进行分配的。用 acquireSudog 和 releaseSudog 来分配和释放 sudog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 之后的这些字段都是被该 g 所挂在的 channel 中的 hchan.lock 来保护的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// shrinkstack depends on</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    g *g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// isSelect 表示一个 g 是否正在参与 select 操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 所以 g.selectDone 必须用 CAS 来操作，以胜出唤醒的竞争</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    isSelect <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    next     *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">    prev     *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 下面这些字段则永远都不会被并发访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 对于 channel 来说，waitlink 只会被 g 访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 对于信号量来说，所有的字段，包括上面的那些字段都只在持有 semaRoot 锁时才可以访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    acquiretime <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    releasetime <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ticket      <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    parent      *sudog <span class="comment">// semaRoot binary tree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waittail    *sudog <span class="comment">// semaRoot</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c           *hchan <span class="comment">// channel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>线程在 runtime 中的结构，对应一个 pthread，pthread 也会对应唯一的内核线程(task_struct):</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    g0      *g     <span class="comment">// 用来执行调度指令的 goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    procid        <span class="keyword">uint64</span>       <span class="comment">// for debuggers, but offset not hard-coded</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gsignal       *g           <span class="comment">// signal-handling g</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    goSigStack    gsignalStack <span class="comment">// Go-allocated signal handling stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigmask       sigset       <span class="comment">// storage for saved signal mask</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// thread-local storage (for x86 extern register)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    curg          *g       <span class="comment">// 当前运行的用户 goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nextp         puintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id            <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mallocing     <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    throwing      <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    preemptoff    <span class="keyword">string</span> <span class="comment">// 该字段不等于空字符串的话，要保持 curg 始终在这个 m 上运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    locks         <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    softfloat     <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dying         <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    profilehz     <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    helpgc        <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// m 失业了，正在积极寻找工作~</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    blocked       <span class="keyword">bool</span> <span class="comment">// m 正阻塞在 note 上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    inwb          <span class="keyword">bool</span> <span class="comment">// m 正在执行 write barrier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    printlock     <span class="keyword">int8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    incgo         <span class="keyword">bool</span>   <span class="comment">// m 正在执行 cgo call</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freeWait      <span class="keyword">uint32</span> <span class="comment">// if == 0, safe to free g0 and delete m (atomic)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fastrand      [<span class="number">2</span>]<span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    needextram    <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    traceback     <span class="keyword">uint8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ncgocall      <span class="keyword">uint64</span>      <span class="comment">// cgo 调用总计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ncgo          <span class="keyword">int32</span>       <span class="comment">// 当前正在执行的 cgo 订单计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cgoCallersUse <span class="keyword">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    park          note</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alllink       *m <span class="comment">// on allm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    schedlink     muintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mcache        *mcache</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lockedg       guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span>    <span class="comment">// stack that created this thread.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freglo        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] lsb and f[i]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freghi        [<span class="number">16</span>]<span class="keyword">uint32</span>     <span class="comment">// d[i] msb and f[i+16]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fflag         <span class="keyword">uint32</span>         <span class="comment">// floating point compare flags</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lockedExt     <span class="keyword">uint32</span>         <span class="comment">// tracking for external LockOSThread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lockedInt     <span class="keyword">uint32</span>         <span class="comment">// tracking for internal lockOSThread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nextwaitm     muintptr       <span class="comment">// 正在等待锁的下一个 m</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waitunlockf   unsafe.Pointer <span class="comment">// todo go func(*g, unsafe.pointer) bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waitlock      unsafe.Pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">    waittraceev   <span class="keyword">byte</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    waittraceskip <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    startingtrace <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    syscalltick   <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freelink      *m      <span class="comment">// on sched.freem</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// these are here because they are too large to be on the stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// of low-level NOSPLIT functions.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    libcall   libcall</span></pre></td></tr><tr><td class="code"><pre><span class="line">    libcallpc <span class="keyword">uintptr</span> <span class="comment">// for cpu profiler</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    libcallsp <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    libcallg  guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    syscall   libcall <span class="comment">// 存储 windows 平台的 syscall 参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mOS</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>抽象数据结构，可以认为是 processor 的抽象，代表了任务执行时的上下文，m 必须获得 p 才能执行:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    id          <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    link        puintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// 每次调用 schedule 时会加一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// 每次系统调用时加一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sysmontick  sysmontick <span class="comment">// 上次 sysmon 观察到的 tick 时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    m           muintptr   <span class="comment">// 和相关联的 m 的反向指针，如果 p 是 idle 的话，那这个指针是 nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mcache      *mcache</span></pre></td></tr><tr><td class="code"><pre><span class="line">    racectx     <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    goidcache    <span class="keyword">uint64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    goidcacheend <span class="keyword">uint64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// runnable 状态的 goroutine。访问时是不加锁的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqhead <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqtail <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runq     [<span class="number">256</span>]guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// runnext 非空时，代表的是一个 runnable 状态的 G，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这个 G 是被 当前 G 修改为 ready 状态的，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 并且相比在 runq 中的 G 有更高的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果当前 G 的还有剩余的可用时间，那么就应该运行这个 G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 运行之后，该 G 会继承当前 G 的剩余时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If a set of goroutines is locked in a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready'd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnext guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gfree    *g</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gfreecnt <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sudogcache []*sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tracebuf traceBufPtr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// traceSweep indicates the sweep events should be traced.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// This is used to defer the sweep start event until a span</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// has actually been swept.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    traceSweep <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    traceSwept, traceReclaimed <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Per-P GC state</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcBgMarkWorker       guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcMarkWorkerMode     gcMarkWorkerMode</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当前标记 worker 的开始时间，单位纳秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcw gcWork</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wbBuf wbBuf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pad [sys.CacheLineSize]<span class="keyword">byte</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>全局调度器，全局只有一个 schedt 类型的实例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 下面两个变量需以原子访问访问。保持在 struct 顶部，以使其在 32 位系统上可以对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    goidgen  <span class="keyword">uint64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lastpoll <span class="keyword">uint64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当修改 nmidle，nmidlelocked，nmsys，nmfreed 这些数值时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 需要记得调用 checkdead</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    midle        muintptr <span class="comment">// idle m's waiting for work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nmidle       <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的空闲 m 计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nmidlelocked <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的被 lock 的 m 计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mnext        <span class="keyword">int64</span>    <span class="comment">// 当前预缴创建的 m 数，并且该值会作为下一个创建的 m 的 ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    maxmcount    <span class="keyword">int32</span>    <span class="comment">// 允许创建的最大的 m 数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pidle      puintptr <span class="comment">// 空闲 p's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    npidle     <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 全局的可运行 g 队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqhead guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqtail guintptr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqsize <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// dead G 的全局缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gflock       mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gfreeStack   *g</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gfreeNoStack *g</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngfree       <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// sudog 结构的集中缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sudoglock  mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sudogcache *sudog</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 不同大小的可用的 defer struct 的集中缓存池</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    deferlock mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deferpool [<span class="number">5</span>]*_defer</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 被设置了 m.exited 标记之后的 m，这些 m 正在 freem 这个链表上等待被 free</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 链表用 m.freelink 字段进行链接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freem *m</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stopwait   <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stopnote   note</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sysmonwait <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sysmonnote note</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// safepointFn should be called on each P at the next GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// safepoint if p.runSafePointFn is set.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    safePointWait <span class="keyword">int32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    safePointNote note</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    profilehz <span class="keyword">int32</span> <span class="comment">// cpu profiling rate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    procresizetime <span class="keyword">int64</span> <span class="comment">// 上次修改 gomaxprocs 的纳秒时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    totaltime      <span class="keyword">int64</span> <span class="comment">// ∫gomaxprocs dt up to procresizetime</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="g-p-m-的关系"><a href="#g-p-m-的关系" class="headerlink" title="g/p/m 的关系"></a>g/p/m 的关系</h2><p>Go 实现了所谓的 M:N 模型，执行用户代码的 goroutine 可以认为都是对等的 goroutine。不考虑 g0 和 gsignal 的话，我们可以简单地认为调度就是将 m 绑定到 p，然后在 m 中不断循环执行调度函数(runtime.schedule)，寻找可用的 g 来执行，下图为 m 绑定到 p 时，可能得到的 g 的来源:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                  +---------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                  | binded  +-------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                  +----+----+             |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------------------------------+       |                  v                 +-----------------------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|                              |       |       +-------------------------+  |                             |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|         +------------------+ |       |       |                         |  |        +------------------+ |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|         | Local Run Queue  | |       |       |    +------------------+ |  |        | Global Run Queue | |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| other P +-+-+-+-+-+-+-+-+--+ |       |       | P  | Local Run Queue  | |  | schedt +--+-+-+-+-+-+-+---+ |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|           |G|G|G|G|G|G|G|    |       |       |    +-+-+-+-+-+-+-+-+--+ |  |           |G|G|G|G|G|G|     |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|           +-+-+-+-+-+-+-+    |       |       |      |G|G|G|G|G|G|G|    |  |           +-+-+-+-+-+-+     |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|            ^                 |       |       |      +-+-+-+-+-+-+-+    |  |            ^                |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------------+-----------------+       |       |       ^                 |  +------------+----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |       +-------+-----------------+               |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         |                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">             |                         v                              |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">      +------+-------+                .-.      +----------------+     |                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">      |    steal     +---------------( M )-----+    runqget     +-----+                  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">      +--------------+                &#96;-&#39;      +----------------+                        |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |                                                 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |                                         +-------+---------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       +-----------------------------------------+   globrunqget   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |                                         +-----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            +----------+--------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            |   get netpoll g   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            +----------+--------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        +--------------+--------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        |              |              |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        |   netpoll    v              |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        |             +-+-+-+-+       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        |             |G|G|G|G|       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        |             +-+-+-+-+       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        +-----------------------------+</span></pre></td></tr></table></figure>


<p>这张图展示了 g、p、m 三者之间的大致关系。m 是执行实体，对应的是操作系统线程。可以看到 m 会从绑定的 p 的本地队列、sched 中的全局队列、netpoll 中获取可运行的 g，实在找不着还会去其它的 p 那里去偷。</p>
<h2 id="p-如何初始化"><a href="#p-如何初始化" class="headerlink" title="p 如何初始化"></a>p 如何初始化</h2><p>程序启动时，会依次调用：</p>
<pre class="mermaid">graph TD
runtime.schedinit -->  runtime.procresize</pre>

<p>在 procresize 中会将全局 p 数组初始化，并将这些 p 串成链表放进 sched 全局调度器的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p := allp[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 设置 p 的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p.status = _Pidle</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化时，所有 p 的 runq 都是空的，所以一定会走这个 if</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> runqempty(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将 p 放到全局调度器的 pidle 队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pidleput(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>pidleput 也比较简单，没啥可说的:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(_p_ *p)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !runqempty(_p_) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"pidleput: P has non-empty run queue"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 简单的链表操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _p_.link = sched.pidle</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sched.pidle.set(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// pidle count + 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    atomic.Xadd(&amp;sched.npidle, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>所有 p 在程序启动的时候就已经被初始化完毕了，除非手动调用 runtime.GOMAXPROCS。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret := <span class="keyword">int</span>(gomaxprocs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> || n == ret &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ret</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    stopTheWorld(<span class="string">"GOMAXPROCS"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// newprocs will be processed by startTheWorld</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newprocs = <span class="keyword">int32</span>(n)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    startTheWorld()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ret</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 startTheWorld 中会调用 procresize。</p>
<h2 id="g-如何创建"><a href="#g-如何创建" class="headerlink" title="g 如何创建"></a>g 如何创建</h2><p>在用户代码里一般这么写:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// do the stuff</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;()</span></pre></td></tr></table></figure>

<p>实际上会被翻译成 <code>runtime.newproc</code>，特权语法只是个语法糖。如果你要在其它语言里实现类似的东西，只要实现编译器翻译之后的内容就好了。具体流程:</p>
<pre class="mermaid">graph TD
runtime.newproc --> runtime.newproc1</pre>

<p>newproc 干的事情也比较简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// add 是一个指针运算，跳过函数指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把栈上的参数起始地址找到</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pc := getcallerpc()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, pc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// funcval 是一个变长结构，第一个成员是函数指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 所以上面的 add 是跳过这个 fn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fn <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// variable-size, fn-specific data here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>runtime 里比较常见的 getcallerpc 和 getcallersp，代码里的注释写的比较明白了:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For example:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// func f(arg1, arg2, arg3 int) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    pc := getcallerpc()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    sp := getcallersp(unsafe.Pointer(&amp;arg1))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// These two lines find the PC and SP immediately following</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// the call to f (where f will return).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr></table></figure>

<p>getcallerpc 返回的是调用函数之后的那条程序指令的地址，即 callee 函数返回时要执行的下一条指令的地址。</p>
<p>systemstack 在 runtime 中用的也比较多，其功能为让 m 切换到 g0 上执行各种调度函数。至于啥是 g0，在讲 m 的时候再说。</p>
<p>newproc1 的工作流程也比较简单:</p>
<pre class="mermaid">graph TD
newproc1 --> newg
newg[gfget] --> nil{is nil?}
nil -->|yes|E[init stack]
nil -->|no|C[malg]
C --> D[set g status=> idle->dead]
D --> allgadd
E --> G[set g status=> dead-> runnable]
allgadd --> G
G --> runqput</pre>

<p>删掉了不关心的细节后的代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"go of nil func value"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    siz := narg</span></pre></td></tr><tr><td class="code"><pre><span class="line">    siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _p_ := _g_.m.p.ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg := gfget(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newg = malg(_StackMin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp := newg.stack.hi - totalSize</span></pre></td></tr><tr><td class="code"><pre><span class="line">    spArg := sp</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化 g，g 的 gobuf 现场，g 的 m 的 curg</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 以及各种寄存器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.sched.sp = sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.stktopsp = sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.gopc = callerpc</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.startpc = fn.fn</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newg.labels = _g_.m.curg.labels</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    casgstatus(newg, _Gdead, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _p_.goidcache++</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wakep()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_.m.locks--</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.stackguard0 = stackPreempt</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>所以 <code>go func</code> 执行的结果是调用 runqput 将 g 放进了执行队列。但在放队列之前还做了点小动作:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span></pre></td></tr></table></figure>

<h3 id="gostartcallfn"><a href="#gostartcallfn" class="headerlink" title="gostartcallfn"></a>gostartcallfn</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// and then did an immediate gosave.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> fn unsafe.Pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fn = unsafe.Pointer(fv.fn)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fn = unsafe.Pointer(funcPC(nilfunc))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// and then did an immediate gosave.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp := buf.sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sp -= sys.PtrSize</span></pre></td></tr><tr><td class="code"><pre><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp -= sys.PtrSize</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc <span class="comment">// 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    buf.sp = sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">    buf.pc = <span class="keyword">uintptr</span>(fn)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    buf.ctxt = ctxt</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>
<p>在之后的 m 的 schedule 讲解中会看到更详细的调度循环过程。</p>
<h3 id="runqput"><a href="#runqput" class="headerlink" title="runqput"></a>runqput</h3><p>因为是放 runq 而不是直接执行，因而什么时候开始执行并不是用户代码能决定得了的。再看看 runqput 这个函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runqput 尝试把 g 放到本地执行队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// next 参数如果是 false 的话，runqput 会将 g 放到运行队列的尾部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If next if false, runqput adds g to the tail of the runnable queue.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If next is true, runqput puts g in the _p_.runnext slot.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If the run queue is full, runnext puts g on the global queue.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Executed only by the owner P.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(_p_ *p, gp *g, next <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="number">2</span> == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        next = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> next &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    retryNext:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        oldnext := _p_.runnext</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">goto</span> retryNext</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 把之前的 runnext 踢到正常的 runq 中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp = oldnext.ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">retry:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    t := _p_.runqtail</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> t-h &lt; <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_.runq[t%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        atomic.Store(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 队列没有满的话，上面的 put 操作会成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">goto</span> retry</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="runqputslow"><a href="#runqputslow" class="headerlink" title="runqputslow"></a>runqputslow</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 slow，所以会一次性把本地队列里的多个 g (包含当前的这个) 放到全局队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 只会被 g 的 owner P 执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(_p_ *p, gp *g, h, t <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> batch [<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 先从本地队列抓一批 g</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    n := t - h</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = n / <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> n != <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"runqputslow: queue is not full"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        batch[i] = _p_.runq[(h+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;_p_.runqhead, h, h+n) &#123; <span class="comment">// cas-release, commits consume</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    batch[n] = gp</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">1</span>); i &lt;= n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j := fastrandn(i + <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            batch[i], batch[j] = batch[j], batch[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把这些 goroutine 构造成链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将链表放到全局队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    globrunqputbatch(batch[<span class="number">0</span>], batch[n], <span class="keyword">int32</span>(n+<span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>操作全局 sched 时，需要获取全局 sched.lock 锁，全局锁争抢的开销较大，所以才称之为 slow。p 和 g 在 m 中交互时，因为现场永远是单线程，所以很多时候不用加锁。</p>
<h2 id="m-工作机制"><a href="#m-工作机制" class="headerlink" title="m 工作机制"></a>m 工作机制</h2><p>在 runtime 中有三种线程，一种是主线程，一种是用来跑 sysmon 的线程，一种是普通的用户线程。主线程在 runtime 由对应的全局变量: <code>runtime.m0</code> 来表示。用户线程就是普通的线程了，和 p 绑定，执行 g 中的任务。虽然说是有三种，实际上前两种线程整个 runtime 就只有一个实例。用户线程才会有很多实例。</p>
<h3 id="主线程-m0"><a href="#主线程-m0" class="headerlink" title="主线程 m0"></a>主线程 m0</h3><p>主线程中用来跑 <code>runtime.main</code>，流程线性执行，没有跳转:</p>
<pre class="mermaid">graph TD
runtime.main --> A[init max stack size]
A --> B[systemstack execute -> newm -> sysmon]
B --> runtime.lockOsThread
runtime.lockOsThread --> runtime.init
runtime.init --> runtime.gcenable
runtime.gcenable --> main.init
main.init --> main.main</pre>

<h3 id="sysmon-线程"><a href="#sysmon-线程" class="headerlink" title="sysmon 线程"></a>sysmon 线程</h3><p>sysmon 是在 <code>runtime.main</code> 中启动的，不过需要注意的是 sysmon 并不是在 m0 上执行的。因为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newm(sysmon, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>创建了新的 m，但这个 m 又与普通的线程不一样，因为不需要绑定 p 就可以执行。是与整个调度系统脱离的。</p>
<p>sysmon 内部是个死循环，主要负责以下几件事情:</p>
<ol>
<li><p>checkdead，检查是否所有 goroutine 都已经锁死，如果是的话，直接调用 runtime.throw，强制退出。这个操作只在启动的时候做一次</p>
</li>
<li><p>将 netpoll 返回的结果注入到全局 sched 的任务队列</p>
</li>
<li><p>收回因为 syscall 而长时间阻塞的 p，同时抢占那些执行时间过长的 g</p>
</li>
<li><p>如果 span 内存闲置超过 5min，那么释放掉</p>
</li>
</ol>
<p>流程图:</p>
<pre class="mermaid">graph TD
sysmon --> usleep
usleep --> checkdead
checkdead --> |every 10ms|C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> injectglist
injectglist --> retake
C --> |no|retake
retake --> A[check forcegc needed]
A --> B[scavenge heap once in a while]
B --> usleep</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sysmon 不需要绑定 P 就可以运行，所以不允许 write barriers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sched.nmsys++</span></pre></td></tr><tr><td class="code"><pre><span class="line">    checkdead()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果一个 heap span 在一次GC 之后 5min 都没有被使用过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 那么把它交还给操作系统</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Scavenge-a-lot for testing.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lastscavenge := nanotime()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nscavenge := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// 初始化时 20us sleep</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            delay = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            delay *= <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// 最多到 10ms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        usleep(delay)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// Make wake-up period small enough</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// for the sampling to be correct.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                maxsleep := forcegcperiod / <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> scavengelimit &lt; forcegcperiod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    maxsleep = scavengelimit / <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                shouldRelax := <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> osRelaxMinNS &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    next := timeSleepUntil()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    now := nanotime()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> next-now &lt; osRelaxMinNS &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        shouldRelax = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    osRelax(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                notetsleep(&amp;sched.sysmonnote, maxsleep)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> shouldRelax &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    osRelax(<span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                noteclear(&amp;sched.sysmonnote)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                idle = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                delay = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// trigger libc interceptors if needed</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 如果 10ms 没有 poll 过 network，那么就 netpoll 一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        now := nanotime()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp := netpoll(<span class="literal">false</span>) <span class="comment">// 非阻塞 -- 返回一个 goroutine 的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// Need to decrement number of idle locked M's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// (pretending that one more is running) before injectglist.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// Otherwise it can lead to the following situation:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// injectglist grabs all P's but before it starts M's to run the P's,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// another M returns from syscall, finishes running its G,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// observes that there is no work to do and no other running M's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// and reports deadlock.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                incidlelocked(<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                injectglist(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                incidlelocked(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 接收在 syscall 状态阻塞的 P</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 抢占长时间运行的 G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            idle = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            idle++</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 检查是否需要 force GC(两分钟一次的)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;forcegc.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            forcegc.idle = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            forcegc.g.schedlink = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            injectglist(forcegc.g)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;forcegc.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 每过一段时间扫描一次堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> lastscavenge+scavengelimit/<span class="number">2</span> &lt; now &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mheap_.scavenge(<span class="keyword">int32</span>(nscavenge), <span class="keyword">uint64</span>(now), <span class="keyword">uint64</span>(scavengelimit))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lastscavenge = now</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nscavenge++</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lasttrace = now</span></pre></td></tr><tr><td class="code"><pre><span class="line">            schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="checkdead"><a href="#checkdead" class="headerlink" title="checkdead"></a>checkdead</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查死锁的场景</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 该检查基于当前正在运行的 M 的数量，如果 0，那么就是 deadlock 了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 检查的时候必须持有 sched.lock 锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 对于 -buildmode=c-shared 或者 -buildmode=c-archive 来说</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 没有 goroutine 正在运行也是 OK 的。因为调用这个库的程序应该是在运行的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> islibrary || isarchive &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If we are dying because of a signal caught on an already idle thread,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// freezetheworld will cause all running threads to block.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// And runtime will essentially enter into deadlock state,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// except that there is a thread that will call exit soon.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> panicking &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> run &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> run &lt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: checkdead: nmidle="</span>, sched.nmidle, <span class="string">" nmidlelocked="</span>, sched.nmidlelocked, <span class="string">" mcount="</span>, mcount(), <span class="string">" nmsys="</span>, sched.nmsys, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"checkdead: inconsistent counts"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    grunning := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;allglock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allgs); i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp := allgs[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> isSystemGoroutine(gp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s := readgstatus(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> s &amp;^ _Gscan &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> _Gwaiting:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            grunning++</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> _Grunnable,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _Grunning,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _Gsyscall:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;allglock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(<span class="string">"runtime: checkdead: find g "</span>, gp.goid, <span class="string">" in status "</span>, s, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"checkdead: runnable g"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;allglock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> grunning == <span class="number">0</span> &#123; <span class="comment">// possible if main goroutine calls runtime·Goexit()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"no goroutines (main called runtime.Goexit) - deadlock!"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Maybe jump time forward for playground.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp := timejump()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        globrunqput(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_ := pidleget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"checkdead: no p for timer"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mp := mget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// There should always be a free M since</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// nothing is running.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"checkdead: no m for timer"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mp.nextp.set(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        notewakeup(&amp;mp.park)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    getg().m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    throw(<span class="string">"all goroutines are asleep - deadlock!"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="retake"><a href="#retake" class="headerlink" title="retake"></a>retake</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forcePreemptNS is the time slice given to a G before it is</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// preempted.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> forcePreemptNS = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> <span class="comment">// 10ms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Prevent allp slice changes. This lock will be completely</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// uncontended unless we're already stopping the world.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;allpLock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// We can't use a range loop over allp because we may</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// temporarily drop the allpLock. Hence, we need to re-fetch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// allp each time around the loop.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_ := allp[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 在 procresize 修改了 allp 但还没有创建新的 p 的时候</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 会有这种情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pd := &amp;_p_.sysmontick</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s := _p_.status</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 从 syscall 接管 P，如果它进行 syscall 已经经过了一个 sysmon 的 tick(至少 20us)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            t := <span class="keyword">int64</span>(_p_.syscalltick)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pd.syscalltick = <span class="keyword">uint32</span>(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pd.syscallwhen = now</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 一方面如果没有其它工作可做的话，我们不想接管 p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 但另一方面为了避免 sysmon 线程陷入沉睡，我们最终还是会接管这些 p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 解开 allplock 的锁，然后就可以持有 sched.lock 锁了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;allpLock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Need to decrement number of idle locked M's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// (pretending that one more is running) before the CAS.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Otherwise the M from which we retake can exit the syscall,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// increment nmidle and report deadlock.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            incidlelocked(<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    traceGoSysBlock(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    traceProcStop(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                n++</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _p_.syscalltick++</span></pre></td></tr><tr><td class="code"><pre><span class="line">                handoffp(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            incidlelocked(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;allpLock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果 G 运行时间太长，那么抢占它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            t := <span class="keyword">int64</span>(_p_.schedtick)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pd.schedtick = <span class="keyword">uint32</span>(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pd.schedwhen = now</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            preemptone(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;allpLock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h3><p>普通线程就是我们 G/P/M 模型里的 M 了，M 对应的就是操作系统的线程。</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>上面在创建 sysmon 线程的时候也看到了，创建线程的函数是 newm。</p>
<pre class="mermaid">graph TD
newm --> newm1
newm1 --> newosproc
newosproc --> clone</pre>

<p>最终会走到 linux 创建线程的系统调用 <code>clone</code>，代码里大段和 cgo 相关的内容我们就不关心了，摘掉 cgo 相关的逻辑后的代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 m。该 m 会在启动时调用函数 fn，或者 schedule 函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// fn 需要是 static 类型，且不能是在堆上分配的闭包。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 运行 m 时，m.p 是有可能为 nil 的，所以不允许 write barriers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp := allocm(_p_, fn)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.nextp.set(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.sigmask = initSigmask</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newm1(mp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>传入的 p 会被赋值给 m 的 nextp 成员，在 m 执行 schedule 时，会将 nextp 拿出来，进行之后真正的绑定操作(其实就是把 nextp 赋值为 nil，并把这个 nextp 赋值给 m.p，把 m 赋值给 p.m)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    execLock.rlock() <span class="comment">// Prevent process clone.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    execLock.runlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m, stk unsafe.Pointer)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Disable signals during clone, so that the new thread starts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// with signals disabled. It will enable them in minit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> oset sigset</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: failed to create new OS thread (have "</span>, mcount(), <span class="string">" already; errno="</span>, -ret, <span class="string">")\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ret == -_EAGAIN &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">println</span>(<span class="string">"runtime: may need to increase max user processes (ulimit -u)"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"newosproc"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>首先空闲的 m 会被丢进全局调度器的 midle 队列中，在需要 m 的时候，会先从这里取:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试从 midle 列表中获取一个 m</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 必须锁全局的 sched</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 可能在 STW 期间执行，所以不允许 write barriers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span> *<span class="title">m</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp := sched.midle.ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sched.midle = mp.schedlink</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sched.nmidle--</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mp</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>取不到的话就会调用之前提到的 newm 来创建新线程，创建的线程是不会被销毁的，哪怕之后不需要这么多 m 了，也就只是会把 m 放在 midle 中。</p>
<p>什么时候会创建线程呢，可以追踪一下 newm 的调用方:</p>
<pre class="mermaid">graph TD
main --> |sysmon|newm
startTheWorld --> startTheWorldWithSema
gcMarkTermination --> startTheWorldWithSema
gcStart--> startTheWorldWithSema
startTheWorldWithSema --> |helpgc|newm
startTheWorldWithSema --> |run p|newm
startm --> mget
mget --> |if no free m|newm
startTemplateThread --> |templateThread|newm
LockOsThread --> startTemplateThread
main --> |iscgo|startTemplateThread
handoffp --> startm
wakep --> startm
injectglist --> startm</pre>

<p>基本上来讲，m 都是按需创建的。如果 sched.midle 中没有空闲的 m 了，现在又需要，那么就会去创建一个。</p>
<p>创建好的线程需要绑定到 p 之后才会开始执行，执行过程中也可能被剥夺掉 p。比如前面 retake 的流程，就会将 g 的 stackguard0 修改为 stackPreempt，待下一次进入 newstack 时，会判断是否有该抢占标记，有的话，就会放弃运行。这也就是所谓的<code>协作式抢占</code>。</p>
<p>工作线程执行的内容核心其实就只有俩: <code>schedule()</code> 和 <code>findrunnable()</code>。</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><pre class="mermaid">graph TD
schedule --> A[schedtick%61 == 0]
A --> |yes|globrunqget
A --> |no|runqget
globrunqget --> C[gp == nil]
C --> |no|execute
C --> |yes|runqget
runqget --> B[gp == nil]
B --> |no|execute
B --> |yes|findrunnable
findrunnable --> execute</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调度器调度一轮要执行的函数: 寻找一个 runnable 状态的 goroutine，并 execute 它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 调度函数是循环，永远都不会返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stoplockedm()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 执行 cgo 调用的 g 不能被 schedule 走</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 因为 cgo 调用使用 m 的 g0 栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">top:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gcstopm()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        runSafePointFn()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> gp *g</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp = traceReader()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 每调度几次就检查一下全局的 runq 来确保公平</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 否则两个 goroutine 就可以通过互相调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 完全占用本地的 runq 了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"schedule: spinning with local work"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// 在找到 goroutine 之前会一直阻塞下去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当前线程将要执行 goroutine，并且不会再进入 spinning 状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 所以如果它被标记为 spinning，我们需要 reset 这个状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 可能会重启一个新的 spinning 状态的 M</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        resetspinning()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Hands off own p to the locked m,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// then blocks waiting for a new p.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        startlockedm(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    execute(gp, inheritTime)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>m 中所谓的调度循环实际上就是一直在执行下图中的 loop:</p>
<pre class="mermaid">graph TD
schedule --> execute
execute --> gogo
gogo --> goexit
goexit --> goexit1
goexit1 --> goexit0
goexit0 --> schedule</pre>


<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Never returns.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// acquiring a P in several places.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_ := getg() <span class="comment">// 这个可能是 m 的 g0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp.waitsince = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp.preempt = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.m.p.ptr().schedtick++</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_.m.curg = gp <span class="comment">// 把当前 g 的位置让给 m</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp.m = _g_.m <span class="comment">// 把 gp 指向 m，建立双向关系</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gogo(&amp;gp.sched)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>比较简单，绑定 g 和 m，然后 gogo 执行绑定的 g 中的函数。</p>
<h4 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h4><p>runtime.gogo 是汇编完成的，功能就是执行 <code>go func()</code> 的这个 <code>func()</code>，可以看到功能主要是把 g 对象的 gobuf 里的内容搬到寄存器里。然后从 <code>gobuf.pc</code> 寄存器存储的指令位置开始继续向后执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void gogo(Gobuf*)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), BX        <span class="comment">// gobuf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_g(BX), DX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    <span class="number">0</span>(DX), CX        <span class="comment">// make sure g != nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    get_tls(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    DX, g(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_sp(BX), SP    <span class="comment">// restore SP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_ret(BX), AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_ctxt(BX), DX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_bp(BX), BP</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_sp(BX)    <span class="comment">// clear to help garbage collector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ret(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ctxt(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_bp(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    gobuf_pc(BX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JMP    BX</span></pre></td></tr></table></figure>

<p>当然，这里还是有一些和手写汇编不太一样的，看着比较奇怪的地方，<code>gobuf_sp(BX)</code> 这种写法按说标准 plan9 汇编中 <code>gobuf_sp</code> 只是个 <code>symbol</code>，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？</p>
<p>实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span></span></pre></td></tr></table></figure>

<p>这下知道怎么回事了吧，链接器会帮助我们把这个换成偏移量。。</p>
<h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><p>Goexit :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Goexit terminates the goroutine that calls it. No other goroutine is affected.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Goexit runs all deferred calls before terminating the goroutine. Because Goexit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// is not a panic, any recover calls in those deferred functions will return nil.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Calling Goexit from the main goroutine terminates that goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// without func main returning. Since func main has not returned,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// the program continues execution of other goroutines.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If all other goroutines exit, the program crashes.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Run all deferred functions for the current goroutine.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// This code is similar to gopanic, see that implementation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// for detailed comments.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d := gp._defer</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> d.started &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                d._panic.aborted = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                d._panic = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            d.fn = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp._defer = d.link</span></pre></td></tr><tr><td class="code"><pre><span class="line">            freedefer(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d.started = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp._defer != d &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"bad defer entry in Goexit"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d._panic = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        d.fn = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp._defer = d.link</span></pre></td></tr><tr><td class="code"><pre><span class="line">        freedefer(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Note: we ignore recovers here because Goexit isn't a panic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    goexit1()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        racegoend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        traceGoEnd()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mcall(goexit0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    CALL    runtime·goexit1(SB)    <span class="comment">// does not return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// traceback from goexit1 must hit code range of goexit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span></pre></td></tr></table></figure>

<p>mcall :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func mcall(fn func(*g))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Switch to m-&gt;g0's stack, call fn(g).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// to keep running g.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TEXT runtime·mcall(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    fn+<span class="number">0</span>(FP), DI</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    get_tls(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g(CX), AX    <span class="comment">// save state in g-&gt;sched</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    <span class="number">0</span>(SP), BX    <span class="comment">// caller's PC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    BX, (g_sched+gobuf_pc)(AX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LEAQ    fn+<span class="number">0</span>(FP), BX    <span class="comment">// caller's SP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    BX, (g_sched+gobuf_sp)(AX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    AX, (g_sched+gobuf_g)(AX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(AX)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// switch to m-&gt;g0 &amp; its stack, call fn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g(CX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g_m(BX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    m_g0(BX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CMPQ    SI, AX    <span class="comment">// if g == m-&gt;g0 call badmcall</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    JNE    <span class="number">3</span>(PC)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $runtime·badmcall(SB), AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JMP    AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    SI, g(CX)    <span class="comment">// g = m-&gt;g0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    (g_sched+gobuf_sp)(SI), SP    <span class="comment">// sp = m-&gt;g0-&gt;sched.sp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PUSHQ    AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    DI, DX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    <span class="number">0</span>(DI), DI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CALL    DI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    POPQ    AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $runtime·badmcall2(SB), AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JMP    AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RET</span></pre></td></tr></table></figure>

<h4 id="wakep"><a href="#wakep" class="headerlink" title="wakep"></a>wakep</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tries to add one more P to execute G's.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Called when a G is made runnable (newproc, ready).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// be conservative about spinning threads</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Schedules some M to run the p (creates an M if necessary).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If p==nil, tries to get an idle P, if no idle P's does nothing.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If spinning is set, the caller has incremented nmspinning and startm will</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// either decrement nmspinning or set m.spinning in the newly started M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_ = pidleget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">             <span class="keyword">if</span> spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="comment">// so it's okay to just undo the increment and give up.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     throw(<span class="string">"startm: negative nmspinning"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp := mget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            fn = mspinning</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newm(fn, _p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"startm: m is spinning"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"startm: m has p"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"startm: p has runnable gs"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.spinning = spinning</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.nextp.set(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    notewakeup(&amp;mp.park)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="goroutine-挂起"><a href="#goroutine-挂起" class="headerlink" title="goroutine 挂起"></a>goroutine 挂起</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// unlockf must not access this G's stack, as it may be moved between</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">string</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp := acquirem()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp := mp.curg</span></pre></td></tr><tr><td class="code"><pre><span class="line">    status := readgstatus(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"gopark: bad g status"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.waitlock = lock</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&amp;unlockf))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp.waitreason = reason</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.waittraceev = traceEv</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mp.waittraceskip = traceskip</span></pre></td></tr><tr><td class="code"><pre><span class="line">    releasem(mp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// can't do anything that might move the G between Ms here.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mcall(park_m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ready(gp, traceskip, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Mark gp ready to run.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>, next <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        traceGoUnpark(gp, traceskip)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    status := readgstatus(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Mark runnable.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dumpgstatus(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"bad g-&gt;status in ready"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runqput(_g_.m.p.ptr(), gp, next)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wakep()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_.m.locks--</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in Case we've cleared it in newstack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.stackguard0 = stackPreempt</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"notesleep not on g0"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ns := <span class="keyword">int64</span>(<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ns = <span class="number">10e6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> atomic.Load(key32(&amp;n.key)) == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp.m.blocked = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        futexsleep(key32(&amp;n.key), <span class="number">0</span>, ns)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp.m.blocked = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// One-time notifications.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noteclear</span><span class="params">(n *note)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n.key = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    old := atomic.Xchg(key32(&amp;n.key), <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> old != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"notewakeup - double wakeup ("</span>, old, <span class="string">")\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"notewakeup - double wakeup"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    futexwakeup(key32(&amp;n.key), <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h4><p>findrunnable 比较复杂，流程图先把 gc 相关的省略掉了:</p>
<pre class="mermaid">graph TD
runqget --> A[gp == nil]
A --> |no|return
A --> |yes|globrunqget
globrunqget --> B[gp == nil]
B --> |no| return
B --> |yes| C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> K[gp == nil]
K --> |no|return
K --> |yes|runqsteal
C --> |no|runqsteal
runqsteal --> D[gp == nil]
D --> |no|return
D --> |yes|E[globrunqget]
E --> F[gp == nil]
F --> |no| return
F --> |yes| G[check all p's runq]
G --> H[runq is empty]
H --> |no|runqget
H --> |yes|I[netpoll]
I --> J[gp == nil]
J --> |no| return
J --> |yes| stopm
stopm --> runqget</pre>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到一个可执行的 goroutine 来 execute</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 会尝试从其它的 P 那里偷 g，从全局队列中拿，或者 network 中 poll</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _g_ := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// The conditions here and in handoffp must agree: if</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// findrunnable would return a G to run, handoffp must start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// an M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">top:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _p_ := _g_.m.p.ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gcstopm()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        runSafePointFn()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 本地 runq</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> gp, inheritTime</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 全局 runq</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Poll network.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// netpoll 是我们执行 work-stealing 之前的一个优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果没有任何的 netpoll 等待者，或者线程被阻塞在 netpoll 中，我们可以安全地跳过这段逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果在阻塞的线程中存在任何逻辑上的竞争(e.g. 已经从 netpoll 中返回，但还没有设置 lastpoll)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 该线程还是会将下面的 netpoll 阻塞住</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp := netpoll(<span class="literal">false</span>); gp != <span class="literal">nil</span> &#123; <span class="comment">// 非阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// netpoll 返回 goroutine 链表，用 schedlink 连接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            injectglist(gp.schedlink.ptr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                traceGoUnpark(gp, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从其它 p 那里偷 g</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    procs := <span class="keyword">uint32</span>(gomaxprocs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// GOMAXPROCS=1 或者除了我们其它的 p 都是 idle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 新的工作可能从 syscall/cgocall，网络或者定时器中来。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 上面这些任务都不会被放到本地的 runq，所有没有可以 stealing 的点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> stop</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果正在自旋的 M 的数量 &gt;= 忙着的 P，那么阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这是为了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当 GOMAXPROCS 远大于 1，但程序的并行度又很低的时候</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 防止过量的 CPU 消耗</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> stop</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.m.spinning = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">stop:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 没有可以干的事情。如果我们正在 GC 的标记阶段，可以安全地扫描和加深对象的颜色，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这样可以进行空闲时间的标记，而不是直接放弃 P</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp := _p_.gcBgMarkWorker.ptr()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// which can change underfoot once we no longer block</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// safe-points. We don't need to snapshot the contents because</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// everything up to cap(allp) is immutable.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    allpSnapshot := allp</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回 P 并阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> releasep() != _p_ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"findrunnable: wrong p"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pidleput(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// to run the goroutine.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// than one starving goroutine). However, if after discovering new work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the system is fully loaded so no spinning threads are required.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wasSpinning := _g_.m.spinning</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _g_.m.spinning = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 再检查一下所有的 runq</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> !runqempty(_p_) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _p_ = pidleget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                acquirep(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> wasSpinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    _g_.m.spinning = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 再检查 gc 空闲 g</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _p_ = pidleget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pidleput(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _p_ = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            acquirep(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> wasSpinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _g_.m.spinning = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Go back to idle GC check.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">goto</span> stop</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// poll network</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"findrunnable: netpoll with p"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> _g_.m.spinning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp := netpoll(<span class="literal">true</span>) <span class="comment">// 阻塞到返回为止</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _p_ = pidleget()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                acquirep(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                injectglist(gp.schedlink.ptr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    traceGoUnpark(gp, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            injectglist(gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stopm()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">goto</span> top</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="m-和-p-解绑定"><a href="#m-和-p-解绑定" class="headerlink" title="m 和 p 解绑定"></a>m 和 p 解绑定</h2><h3 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h3><pre class="mermaid">graph TD

mexit --> A[is m0?]
A --> |yes|B[handoffp]
A --> |no| C[iterate allm]
C --> |m found|handoffp
C --> |m not found| throw

forEachP --> |p status == syscall| handoffp

stoplockedm --> handoffp

entersyscallblock --> entersyscallblock_handoff
entersyscallblock_handoff --> handoffp

retake --> |p status == syscall| handoffp</pre>

<p>最终会把 p 放回全局的 pidle 队列中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hands off P from syscall or locked M.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// handoffp must start an M in any situation where</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// findrunnable would return a G to run on _p_.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// if it has local work, start it straight away</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		startm(_p_, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// if it has GC work, start it straight away</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		startm(_p_, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// no local work, check that there are no spinning/idle M's,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// otherwise our help is not required</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		startm(_p_, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_p_.status = _Pgcstop</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sched.stopwait--</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			notewakeup(&amp;sched.stopnote)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sched.safePointFn(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sched.safePointWait--</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			notewakeup(&amp;sched.safePointNote)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		startm(_p_, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// If this is the last running P and nobody is polling network,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// need to wakeup another M to poll network.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> sched.npidle == <span class="keyword">uint32</span>(gomaxprocs<span class="number">-1</span>) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		startm(_p_, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	pidleput(_p_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	unlock(&amp;sched.lock)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="g-的状态迁移"><a href="#g-的状态迁移" class="headerlink" title="g 的状态迁移"></a>g 的状态迁移</h2><pre class="mermaid">graph LR
start{newg} --> Gidle
Gidle --> |oneNewExtraM|Gdead
Gidle --> |newproc1|Gdead

Gdead --> |newproc1|Grunnable
Gdead --> |needm|Gsyscall

Gscanrunning --> |scang|Grunning

Grunnable --> |execute|Grunning

Gany --> |casgcopystack|Gcopystack

Gcopystack --> |todotodo|Grunning

Gsyscall --> |dropm|Gdead
Gsyscall --> |exitsyscall0|Grunnable
Gsyscall --> |exitsyscall|Grunning

Grunning --> |goschedImpl|Grunnable
Grunning --> |goexit0|Gdead
Grunning --> |newstack|Gcopystack
Grunning --> |reentersyscall|Gsyscall
Grunning --> |entersyscallblock|Gsyscall
Grunning --> |markroot|Gwaiting
Grunning --> |gcAssistAlloc1|Gwaiting
Grunning --> |park_m|Gwaiting
Grunning --> |gcMarkTermination|Gwaiting
Grunning --> |gcBgMarkWorker|Gwaiting
Grunning --> |newstack|Gwaiting

Gwaiting --> |gcMarkTermination|Grunning
Gwaiting --> |gcBgMarkWorker|Grunning
Gwaiting --> |markroot|Grunning
Gwaiting --> |gcAssistAlloc1|Grunning
Gwaiting --> |newstack|Grunning
Gwaiting --> |findRunnableGCWorker|Grunnable
Gwaiting --> |ready|Grunnable
Gwaiting --> |findrunnable|Grunnable
Gwaiting --> |injectglist|Grunnable
Gwaiting --> |schedule|Grunnable
Gwaiting --> |park_m|Grunnable
Gwaiting --> |procresize|Grunnable
Gwaiting --> |checkdead|Grunnable</pre>

<p>图上的 Gany 代表任意状态，GC 时的状态切换比较多，如果只关注正常情况下的状态转换，可以把 markroot、gcMark 之类的先忽略掉。</p>
<h2 id="p-的状态迁移"><a href="#p-的状态迁移" class="headerlink" title="p 的状态迁移"></a>p 的状态迁移</h2><pre class="mermaid">graph LR

Pidle --> |acquirep1|Prunning

Psyscall --> |retake|Pidle
Psyscall --> |entersyscall_gcwait|Pgcstop
Psyscall --> |exitsyscallfast|Prunning

Pany --> |gcstopm|Pgcstop
Pany --> |forEachP|Pidle
Pany --> |releasep|Pidle
Pany --> |handoffp|Pgcstop
Pany --> |procresize release current p use allp 0|Pidle
Pany --> |procresize when init|Pgcstop
Pany --> |procresize when free old p| Pdead
Pany --> |procresize after resize use current p|Prunning
Pany --> |reentersyscall|Psyscall
Pany --> |stopTheWorldWithSema|Pgcstop</pre>

<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>函数执行是在 goroutine 的栈上，这个栈在函数执行期间是有可能溢出的，我们前面也看到了，如果一个函数用到了栈，会将 stackguard0 和 sp 寄存器进行比较，如果 sp &lt; stackguard0，说明栈已经增长到溢出，因为栈是从内存高地址向低地址方向增长的。</p>
<p>那么这个比较过程是在哪里完成的呢？这一步是由编译器完成的，我们看看一个函数编译后的结果，这段代码来自 go-internals:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000</span> TEXT    <span class="string">""</span>.main(SB), $<span class="number">24</span><span class="number">-0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ;; stack-split prologue</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0000</span> MOVQ    (TLS), CX</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x000d</span> JLS    <span class="number">58</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x000f</span> SUBQ    $<span class="number">24</span>, SP</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0013</span> MOVQ    BP, <span class="number">16</span>(SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0018</span> LEAQ    <span class="number">16</span>(SP), BP</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ;; ...omitted FUNCDATA stuff...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x001d</span> MOVQ    $<span class="number">137438953482</span>, AX</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0027</span> MOVQ    AX, (SP)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ;; ...omitted PCDATA stuff...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x002b</span> CALL    <span class="string">""</span>.add(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0030</span> MOVQ    <span class="number">16</span>(SP), BP</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0035</span> ADDQ    $<span class="number">24</span>, SP</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x0039</span> RET</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ;; stack-split epilogue</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x003a</span> NOP</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ;; ...omitted PCDATA stuff...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">0x003f</span> JMP    <span class="number">0</span></span></pre></td></tr></table></figure>

<p>函数开头被插的这段指令，即是将 g struct 中的 stackguard 与 SP 寄存器进行对比，JLS 表示 SP &lt; 16(CX) 的话即跳转。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">;; stack-split prologue</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x0000</span> MOVQ    (TLS), CX</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x0009</span> CMPQ    SP, <span class="number">16</span>(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x000d</span> JLS    <span class="number">58</span></span></pre></td></tr></table></figure>

<p>这里因为 CX 寄存器存储的是 g 的起始地址，而 16(CX) 指的是 g 结构体偏移 16 个字节的位置，可以回顾一下 g 结构体定义，16 个字节恰好是跳过了第一个成员 stack(16字节) 之后的 stackguard0 的位置。</p>
<p>58 转为 16 进制即是 0x3a。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">;; stack-split epilogue</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x003a</span> NOP</span></pre></td></tr><tr><td class="code"><pre><span class="line">;; ...omitted PCDATA stuff...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x003a</span> CALL    runtime.morestack_noctxt(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x003f</span> JMP    <span class="number">0</span></span></pre></td></tr></table></figure>

<p>morestack_noctxt:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// morestack but not preserving ctxt.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TEXT runtime·morestack_noctxt(SB),NOSPLIT,$<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVL    $<span class="number">0</span>, DX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JMP    runtime·morestack(SB)</span></pre></td></tr></table></figure>

<p>morestack:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Cannot grow scheduler stack (m-&gt;g0).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    get_tls(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g(CX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g_m(BX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    m_g0(BX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CMPQ    g(CX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JNE    <span class="number">3</span>(PC)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CALL    runtime·badmorestackg0(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    INT    $<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Cannot grow signal stack (m-&gt;gsignal).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    m_gsignal(BX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CMPQ    g(CX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JNE    <span class="number">3</span>(PC)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CALL    runtime·badmorestackgsignal(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    INT    $<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Called from f.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Set m-&gt;morebuf to f's caller.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    <span class="number">8</span>(SP), AX    <span class="comment">// f's caller's PC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    AX, (m_morebuf+gobuf_pc)(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LEAQ    <span class="number">16</span>(SP), AX    <span class="comment">// f's caller's SP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    AX, (m_morebuf+gobuf_sp)(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    get_tls(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    g(CX), SI</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    SI, (m_morebuf+gobuf_g)(BX)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Set g-&gt;sched to context in f.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    <span class="number">0</span>(SP), AX <span class="comment">// f's PC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    AX, (g_sched+gobuf_pc)(SI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    SI, (g_sched+gobuf_g)(SI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LEAQ    <span class="number">8</span>(SP), AX <span class="comment">// f's SP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    AX, (g_sched+gobuf_sp)(SI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    BP, (g_sched+gobuf_bp)(SI)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    DX, (g_sched+gobuf_ctxt)(SI)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Call newstack on m-&gt;g0's stack.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    m_g0(BX), BX</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    BX, g(CX)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    (g_sched+gobuf_sp)(BX), SP</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CALL    runtime·newstack(SB)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MOVQ    $<span class="number">0</span>, <span class="number">0x1003</span>    <span class="comment">// crash if newstack returns</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    RET</span></pre></td></tr></table></figure>

<p>newstack:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from runtime·morestack when more stack is needed.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate larger stack and relocate to new stack.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Stack growth is multiplicative, for constant amortized cost.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// If the GC is trying to stop this g then it will set preemptscan to true.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// This must be nowritebarrierrec because it can be called as part of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// stack growth from other nowritebarrierrec functions, but the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// compiler doesn't check this.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrierrec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    thisg := getg()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> double check all gp. shouldn't be getg().</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr().stackguard0 == stackFork &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"stack growth after fork"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> thisg.m.morebuf.g.ptr() != thisg.m.curg &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack called from g="</span>, hex(thisg.m.morebuf.g), <span class="string">"\n"</span>+<span class="string">"\tm="</span>, thisg.m, <span class="string">" m-&gt;curg="</span>, thisg.m.curg, <span class="string">" m-&gt;g0="</span>, thisg.m.g0, <span class="string">" m-&gt;gsignal="</span>, thisg.m.gsignal, <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        morebuf := thisg.m.morebuf</span></pre></td></tr><tr><td class="code"><pre><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"runtime: wrong goroutine in newstack"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gp := thisg.m.curg</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> thisg.m.curg.throwsplit &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Update syscallsp, syscallpc in case traceback uses them.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        morebuf := thisg.m.morebuf</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp.syscallsp = morebuf.sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gp.syscallpc = morebuf.pc</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pcname, pcoff := <span class="string">"(unknown)"</span>, <span class="keyword">uintptr</span>(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f := findfunc(gp.sched.pc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> f.valid() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pcname = funcname(f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pcoff = gp.sched.pc - f.entry</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack at "</span>, pcname, <span class="string">"+"</span>, hex(pcoff),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">" sp="</span>, hex(gp.sched.sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        thisg.m.traceback = <span class="number">2</span> <span class="comment">// Include runtime frames</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"runtime: stack split at bad time"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    morebuf := thisg.m.morebuf</span></pre></td></tr><tr><td class="code"><pre><span class="line">    thisg.m.morebuf.pc = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thisg.m.morebuf.lr = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thisg.m.morebuf.sp = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thisg.m.morebuf.g = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> stackguard0 may change underfoot, if another thread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// is about to try to preempt gp. Read it just once and use that same</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// value now and below.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Be conservative about where we preempt.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// We are interested in preempting user Go code, not runtime code.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If we're holding locks, mallocing, or preemption is disabled, don't</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// preempt.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// This check is very early in newstack so that even the status change</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// from Grunning to Gwaiting and back doesn't happen in this case.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// That status change by itself can be viewed as a small preemption,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// because the GC might change Gwaiting to Gscanwaiting, and then</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// this goroutine has to wait for the GC to finish before continuing.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If the GC is in some way dependent on this goroutine (for example,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// it needs a lock held by the goroutine), that small preemption turns</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// into a real deadlock.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> preempt &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">""</span> || thisg.m.p.ptr().status != _Prunning &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Let the goroutine keep running for now.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// gp-&gt;preempt is set, so it will be preempted next time.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"missing stack in newstack"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp := gp.sched.sp</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// The call to morestack cost a word.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        sp -= sys.PtrSize</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> || sp &lt; gp.stack.lo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: newstack sp="</span>, hex(sp), <span class="string">" stack=["</span>, hex(gp.stack.lo), <span class="string">", "</span>, hex(gp.stack.hi), <span class="string">"]\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"\tmorebuf=&#123;pc:"</span>, hex(morebuf.pc), <span class="string">" sp:"</span>, hex(morebuf.sp), <span class="string">" lr:"</span>, hex(morebuf.lr), <span class="string">"&#125;\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"\tsched=&#123;pc:"</span>, hex(gp.sched.pc), <span class="string">" sp:"</span>, hex(gp.sched.sp), <span class="string">" lr:"</span>, hex(gp.sched.lr), <span class="string">" ctxt:"</span>, gp.sched.ctxt, <span class="string">"&#125;\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> sp &lt; gp.stack.lo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: gp="</span>, gp, <span class="string">", gp-&gt;status="</span>, hex(readgstatus(gp)), <span class="string">"\n "</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: split stack overflow: "</span>, hex(sp), <span class="string">" &lt; "</span>, hex(gp.stack.lo), <span class="string">"\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"runtime: split stack overflow"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> preempt &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp == thisg.m.g0 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"runtime: preempt g0"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> thisg.m.p == <span class="number">0</span> &amp;&amp; thisg.m.locks == <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw(<span class="string">"runtime: g is running but p is not"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Synchronize with scang.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> gp.preemptscan &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// Likely to be racing with the GC as</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// it sees a _Gwaiting and does the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// stack scan. If so, gcworkdone will</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// be set and gcphasework will simply</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// return.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> !gp.gcscandone &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// gcw is safe because we're on the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// system stack.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                gcw := &amp;gp.m.p.ptr().gcw</span></pre></td></tr><tr><td class="code"><pre><span class="line">                scanstack(gp, gcw)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> gcBlackenPromptly &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    gcw.dispose()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                gp.gcscandone = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp.preemptscan = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp.preempt = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// This clears gcscanvalid.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gogo(&amp;gp.sched) <span class="comment">// never return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Act like goroutine called runtime.Gosched.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gopreempt_m(gp) <span class="comment">// never return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Allocate a bigger segment and move the stack.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    oldsize := gp.stack.hi - gp.stack.lo</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newsize := oldsize * <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> newsize &gt; maxstacksize &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"runtime: goroutine stack exceeds "</span>, maxstacksize, <span class="string">"-byte limit\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw(<span class="string">"stack overflow"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// The goroutine must be executing in order to call newstack,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// so it must be Grunning (or Gscanrunning).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    casgstatus(gp, _Grunning, _Gcopystack)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// The concurrent GC will not scan the stack while we are doing the copy since</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the gp is in a Gcopystack status.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    copystack(gp, newsize, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"stack grow done\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    casgstatus(gp, _Gcopystack, _Grunning)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gogo(&amp;gp.sched)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>总结一下流程:</p>
<pre class="mermaid">graph TD
start[entering func] --> cmp[sp < stackguard0]
cmp --> |yes| morestack_noctxt
cmp --> |no|final[execute func]
morestack_noctxt --> morestack
morestack --> newstack
newstack --> preempt</pre>

<p>抢占都是在 newstack 中完成，但抢占标记是在 Go 源代码中的其它位置来进行标记的:</p>
<p>我们来看看 stackPreempt 是在哪些位置赋值给 stackguard0 的:</p>
<pre class="mermaid">graph LR

unlock --> |in case cleared in newstack|restorePreempt
ready --> |in case cleared in newstack|restorePreempt
startTheWorldWithSema --> |in case cleared in newstack|restorePreempt
allocm --> |in case cleared in newstack|restorePreempt
exitsyscall --> |in case cleared in newstack|restorePreempt
newproc1--> |in case cleared in newstack|restorePreempt
releasem -->  |in case cleared in newstack|restorePreempt

scang --> setPreempt
reentersyscall --> setPreempt
entersyscallblock --> setPreempt
preemptone--> setPreempt

enlistWorker --> preemptone
retake --> preemptone
preemptall --> preemptone
freezetheworld --> preemptall
stopTheWorldWithSema --> preemptall
forEachP --> preemptall
startpanic_m --> freezetheworld
gcMarkDone --> forEachP</pre>

<p>可见只有 gc 和 retake 才会去真正地抢占 g，并没有其它的入口，其它的地方就只是恢复一下可能在 newstack 中被清除掉的抢占标记。</p>
<p>当然，这里 entersyscall 和 entersyscallblock 比较特殊，虽然这俩函数的实现中有设置抢占标记，但实际上这两段逻辑是不会被走到的。因为 syscall 执行时是在 m 的 g0 栈上，如果在执行时被抢占，那么会直接 throw，而无法恢复。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪goroutine调度器[翻译自：Scheduler Tracing In Go]</title>
    <url>/blog/2019/06/23/20190623003354.html</url>
    <content><![CDATA[<blockquote>
<p>能够生成分析和调试信息是我喜欢Go语言的原因之一。通过配置<code>GODEBUG</code>环境变量可以在程序运行期间打印出调试信息，包括gc和scheduler的详细或摘要。最棒的是你不必在程序里设置任何开关它就能够正常工作。</p>
</blockquote>
<h1 id="开始前"><a href="#开始前" class="headerlink" title="开始前"></a>开始前</h1><blockquote>
<p>在这篇文章中，我将向您展示如何使用示例并发Go程序中解释调度程序跟踪信息。 如果您对调度程序有基本的了解，这将有所帮助。 我建议在继续之前阅读这两篇文章：</p>
<ol>
<li><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">Concurrency, Goroutines and GOMAXPROCS</a></li>
<li><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">Go Scheduler</a></li>
</ol>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><blockquote>
<p>以下是我们检查和解释<code>GODEBUG</code>结果的示例程序。</p>
</blockquote>
<p>List1</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"sync"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"time"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	workNum := <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.Add(workNum)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workNum; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">go</span> work(&amp;wg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.Wait()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Wait to see the global run queue deplete.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> counter <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e10</span>; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		counter++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.Done()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>List1中的代码旨在针对我们希望运行时发出的调试信息进行预测。 在第12行，声明一个for循环创建十个goroutines。 然后主函数在第16行等待所有goroutines完成他们的工作。 第22行的工作函数休眠一秒钟，然后将局部变量增加100亿次。 递增完成后，该函数在等待组上调用Done并返回。</p>
<p>在设置<code>GODEBUG</code>来运行程序之前首先构建程序是一个不错的主意，该变量由运行时被设置，因此应用go命令也会产生跟踪输出。如果你使用<code>go run</code>来跟踪程序，那么在程序正式运行之前构建时的追踪信息也将被打印出来。</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>下边让我们来运行这个程序：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build example.go</span></pre></td></tr></table></figure>
<h2 id="追踪scheduler摘要信息"><a href="#追踪scheduler摘要信息" class="headerlink" title="追踪scheduler摘要信息"></a>追踪scheduler摘要信息</h2><blockquote>
<p>通过<code>schedtrace</code> 配置项可以让程序在运行时每隔 X 毫秒打印一行包括调度器状态和标准错误的摘要信息。让我们设置<code>GODEBUG</code>选项并运行这个程序吧：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS&#x3D;1 GODEBUG&#x3D;schedtrace&#x3D;1000 .&#x2F;example</span></pre></td></tr></table></figure>
<blockquote>
<p>一旦程序开始运行，我们就可以看到追踪(tracing)信息开始打印了。程序本身不输出任何内容，因此控制台输出的内容均为追踪信息，让我们看看前两次tracing信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs&#x3D;1 idleprocs&#x3D;0 threads&#x3D;2 spinningthreads&#x3D;0 idlethreads&#x3D;0 runqueue&#x3D;0 [1]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 1009ms: gomaxprocs&#x3D;1 idleprocs&#x3D;0 threads&#x3D;3 spinningthreads&#x3D;0 idlethreads&#x3D;1 runqueue&#x3D;0 [9]</span></pre></td></tr></table></figure>
<blockquote>
<p>让我们来分解一下每个字段的含义，并根据示例程序理解这些值的含义：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1009ms        : 从程序开始到打印该行信息经过的毫秒数.</span></pre></td></tr><tr><td class="code"><pre><span class="line">                此处是第1秒时打印的trace.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">gomaxprocs&#x3D;1  : 配置的P数量(注：需了解 goroutine调度模型中 M P G 概念).</span></pre></td></tr><tr><td class="code"><pre><span class="line">                在此次试验中，仅设置为1.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">特别注意:</span></pre></td></tr><tr><td class="code"><pre><span class="line">考虑在这里的processor是一个逻辑processor，而不是物理processor。</span></pre></td></tr><tr><td class="code"><pre><span class="line">调度器在这些逻辑processors运行程序，而它们都是通过操作系统与内核线程(os thread)绑定的。</span></pre></td></tr><tr><td class="code"><pre><span class="line">操作系统会在可用的物理processor上再次调度这些内核线程。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">threads&#x3D;3     : 运行时的线程数(注：我理解为goroutine调度模型中的M).</span></pre></td></tr><tr><td class="code"><pre><span class="line">                存在3个，一个用于processor，其他两个用于运行时</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 : 空闲线程的数量.</span></pre></td></tr><tr><td class="code"><pre><span class="line">                1个线程空闲，2个在运行.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">idleprocs&#x3D;0   : 空闲processor的数量.</span></pre></td></tr><tr><td class="code"><pre><span class="line">                0个空闲，1个运行.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">runqueue&#x3D;0    : 全局运行队列(runq)中goroutine的数量.</span></pre></td></tr><tr><td class="code"><pre><span class="line">                所有可运行的goroutine被移动到 P 的local运行队列(注：p.runq).</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[9]           : P 的local 运行队列中的 goroutine 数量（注：由于运行时配置了processor数量为1这里只打印1个，配置多个时会打印多个，对应每一个 P）.</span></pre></td></tr><tr><td class="code"><pre><span class="line">                在P的local 运行队列中有 9个goroutine.</span></pre></td></tr></table></figure>

<blockquote>
<p>程序在运行时给了我们很多非常棒的摘要信息。当我们在查看第一秒打印的追踪信息时，我们可以看到一个goroutine是如何运行而其他9个goroutine在 P的local 运行队列中等待。</p>
</blockquote>
<p>示例图1<br><img src="/resources/post_pic/2019/06/diagram1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="示例图1"></p>
<blockquote>
<p>在示例图1中，用字母 <code>P</code> 来表示processor，用字母 <code>M</code> 来表示线程，用字母 <code>G</code> 来表示goroutine。我们可以根据 <code>runqueue</code> 的值为0而推断出全局的运行队列(Global Run Queue)是空的。prcessor 的 <code>idleprocs</code> 值为0，而它正在运行着一个 goroutine ，我们后边新建的goroutine则在这个 processor的local 运行队列中（根据process 的<code>runqueue</code>值为9判断的）。</p>
<p>当我们把processor个数配置多个时会有怎样的追踪信息呢？让我们把<code>GOMAXPROCS</code>的值设置为2，再看一次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS&#x3D;2 GODEBUG&#x3D;schedtrace&#x3D;1000 .&#x2F;example</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs&#x3D;2 idleprocs&#x3D;1 threads&#x3D;2 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;0 runqueue&#x3D;0 [0 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 1002ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;1</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;0 [0 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 2006ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;0 [4 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">…</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 6024ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;2 [3 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">…</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 10049ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;4 [2 2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">…</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 13067ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;6 [1 1]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">…</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 17084ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;8 [0 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">…</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SCHED 21100ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span></pre></td></tr></table></figure>

<blockquote>
<p>运行新程序后，让我们着重看一下第二秒之后的信息:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 2002ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;1 runqueue&#x3D;0 [4 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2002ms        : 标志这是第二秒追踪的信息.</span></pre></td></tr><tr><td class="code"><pre><span class="line">gomaxprocs&#x3D;2  : 程序最大processor数是2.</span></pre></td></tr><tr><td class="code"><pre><span class="line">threads&#x3D;4     : 4个线程，2个用于运行processor，2个用于运行时.</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 : 1个空闲线程(3 threads running).</span></pre></td></tr><tr><td class="code"><pre><span class="line">idleprocs&#x3D;0   : 0个空闲processor (2 processors busy).</span></pre></td></tr><tr><td class="code"><pre><span class="line">runqueue&#x3D;0    : 所有可运行的goroutine被移动到 P的local运行队列(所以全局runqueue为0).</span></pre></td></tr><tr><td class="code"><pre><span class="line">[4 4]         : 每个P的local 运行队列有4个 goroutine等待运行.</span></pre></td></tr></table></figure>

<p>示例图2<br><img src="/resources/post_pic/2019/06/diagram2.png" alt="示例图2"></p>
<blockquote>
<p>让我们再看一下示例图2.我们能够看到goroutine是如何在两个 processor上运行的，其中有8个goroutine在runqueue中等待运行，它们分别在两个processor 的local 运行队列中(各4个)。</p>
</blockquote>
<blockquote>
<p>第6秒的时候，发生了一些变化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 6024ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;1 runqueue&#x3D;2 [3 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">idleprocs&#x3D;0 : 0 processors are idle (2 processors busy).</span></pre></td></tr><tr><td class="code"><pre><span class="line">runqueue&#x3D;2  : 2 goroutines returned and are waiting to be terminated.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[3 3]       : 3 goroutines are waiting inside each local run queue.</span></pre></td></tr></table></figure>

<p>示例图3<br><img src="/resources/post_pic/2019/06/diagram3.png" alt="示例图3"></p>
<blockquote>
<p>在此图中，我们创建的goroutine在完成工作之后被移动到 Golbal Run Queue 中。我们可以看到仍然有2个goroutine正在运行，每个processor各运行一个，每个processor的local 运行队列中有3个goroutine.</p>
</blockquote>
<p>特别注意：</p>
<blockquote>
<p>在许多情况下，goroutine在终止之前不会移回全局运行队列。 这个程序创建了一个特殊情况，因为for循环执行的逻辑运行时间超过10毫秒并且没有调用任何函数。 10ms是调度程序中的调度量。 执行10ms后，调度程序尝试抢占goroutines。 这些goroutine不能被抢占，因为它们不会调用任何函数。 在这种情况下，一旦goroutine到达wg.Done调用，goroutines立即被抢占并移动到全局运行队列以终止。</p>
</blockquote>
<blockquote>
<p>17秒的时候，我们可以看到在processor中正在运行着最后的两个goroutine。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 17084ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;1 runqueue&#x3D;8 [0 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">idleprocs&#x3D;0 : 0 processors are idle (2 processors busy).</span></pre></td></tr><tr><td class="code"><pre><span class="line">runqueue&#x3D;8  : 8 goroutines returned and are waiting to be terminated.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 0]       : No goroutines are waiting inside any local run queue.</span></pre></td></tr></table></figure>

<p>示例图4<br><img src="/resources/post_pic/2019/06/diagram4.png" alt="示例图4"></p>
<blockquote>
<p>在图4中，我们看到8个goroutine在全局运行队列中，剩下的最后2个goroutine正在运行。 这时每个processor的local 运行队列都为空。</p>
</blockquote>
<blockquote>
<p>第21秒的摘要信息：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 21100ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">idleprocs&#x3D;2 : 2 processors are idle (0 processors busy).</span></pre></td></tr><tr><td class="code"><pre><span class="line">runqueue&#x3D;0  : All the goroutines that were in the queue have been terminated.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 0]       : No goroutines are waiting inside any local run queue.</span></pre></td></tr></table></figure>

<p>示例图5<br><img src="/resources/post_pic/2019/06/diagram5.png" alt="示例图5"></p>
<blockquote>
<p>此时，所有的goroutine都完成工作，并且被终结。</p>
</blockquote>
<h2 id="追踪详细信息"><a href="#追踪详细信息" class="headerlink" title="追踪详细信息"></a>追踪详细信息</h2><blockquote>
<p>scheduler的摘要追踪信息非常有用，但是有时你需要更详细的信息。在这种情况下，我们可以增加<code>shceddetail</code>配置，它能够提供 thread、processor、goroutine的详细信息，让我们重新运行程序：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOMAXPROCS&#x3D;2 GODEBUG&#x3D;schedtrace&#x3D;1000,scheddetail&#x3D;1 .&#x2F;example</span></pre></td></tr></table></figure>

<p>以下是第4秒的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCHED 4028ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">idlethreads&#x3D;1 runqueue&#x3D;2 gcwaiting&#x3D;0 nmidlelocked&#x3D;0 stopwait&#x3D;0 sysmonwait&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">P0: status&#x3D;1 schedtick&#x3D;10 syscalltick&#x3D;0 m&#x3D;3 runqsize&#x3D;3 gfreecnt&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">P1: status&#x3D;1 schedtick&#x3D;10 syscalltick&#x3D;1 m&#x3D;2 runqsize&#x3D;3 gfreecnt&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">M3: p&#x3D;0 curg&#x3D;4 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0 spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">M2: p&#x3D;1 curg&#x3D;10 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0 spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">M1: p&#x3D;-1 curg&#x3D;-1 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;1 dying&#x3D;0 helpgc&#x3D;0 spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">M0: p&#x3D;-1 curg&#x3D;-1 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0 spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G1: status&#x3D;4(semacquire) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G2: status&#x3D;4(force gc (idle)) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G3: status&#x3D;4(GC sweep wait) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G4: status&#x3D;2(sleep) m&#x3D;3 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G5: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G6: status&#x3D;1(stack growth) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G7: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G8: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G9: status&#x3D;1(stack growth) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G10: status&#x3D;2(sleep) m&#x3D;2 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G11: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G12: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G13: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G17: status&#x3D;4(timer goroutine (idle)) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr></table></figure>
<blockquote>
<p>摘要的部分与前边的实验输出是相似的，但是我们现在有更详细的 thread、processor、goroutine信息。从 processor开始看吧：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P0: status&#x3D;1 schedtick&#x3D;10 syscalltick&#x3D;0 m&#x3D;3 runqsize&#x3D;3 gfreecnt&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">P1: status&#x3D;1 schedtick&#x3D;10 syscalltick&#x3D;1 m&#x3D;2 runqsize&#x3D;3 gfreecnt&#x3D;0</span></pre></td></tr></table></figure>

<blockquote>
<p>仍然用字母 P 表示 processor，由于<code>GOMAXPROCS</code>被设置为2，我们可以看到有两条关于P的信息。接下来我们看下线程：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M3: p&#x3D;0 curg&#x3D;4 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">M2: p&#x3D;1 curg&#x3D;10 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">M1: p&#x3D;-1 curg&#x3D;-1 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;1 dying&#x3D;0 helpgc&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">M0: p&#x3D;-1 curg&#x3D;-1 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr></table></figure>

<blockquote>
<p>M 表示线程。由于线程数被设置为4(注：并没看到那个地方配置了这个。。。)，我们可以看到4条关于M的详细信息。从这些详细信息中可以看出哪个P与哪个M关联。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在P的详情里P0的 m 值为3，表示P0与M3关联</span></pre></td></tr><tr><td class="code"><pre><span class="line">P0: status&#x3D;1 schedtick&#x3D;10 syscalltick&#x3D;0 m&#x3D;3 runqsize&#x3D;3 gfreecnt&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 反过来看M3，它的p值为0</span></pre></td></tr><tr><td class="code"><pre><span class="line">M3: p&#x3D;0 curg&#x3D;4 mallocing&#x3D;0 throwing&#x3D;0 gcing&#x3D;0 locks&#x3D;0 dying&#x3D;0 helpgc&#x3D;0</span></pre></td></tr><tr><td class="code"><pre><span class="line">spinning&#x3D;0 blocked&#x3D;0 lockedg&#x3D;-1</span></pre></td></tr></table></figure>

<blockquote>
<p>这里看到了M3和P0关联到一起，P 和 M都会记录这个信息。</p>
</blockquote>
<blockquote>
<p>G表示一个goroutine。在4秒标记处，我们看到目前存在14个goroutine，自程序启动以来已创建了17个goroutine。 我们知道由于跟踪中列出的最后一个G附加的数字而创建的goroutine总数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G17: status&#x3D;4(timer goroutine (idle)) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr></table></figure>

<blockquote>
<p>如果这个程序继续创建goroutines，我们会看到这个数字线性增加。 例如，如果该程序正在处理Web请求，我们可以使用这个数值来大致了解已处理的请求数。 如果程序在处理请求期间没有创建任何其他goroutine，则此估计值更接近真实的请求数。</p>
</blockquote>
<blockquote>
<p>接下来再看一下 main函数运行的 goroutine：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G1: status&#x3D;4(semacquire) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">30     wg.Done()</span></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，main函数所在的 goroutine状态是 4,阻塞在 semacquire，这是因为我们在代码中调用了 group.Wait。</p>
<p>为了更好地理解此跟踪中的其余goroutine，了解状态数字代表什么是有很有用的。 以下是在运行时头文件中声明的状态代码列表：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status: http:&#x2F;&#x2F;golang.org&#x2F;src&#x2F;runtime&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gidle,            &#x2F;&#x2F; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Grunnable,        &#x2F;&#x2F; 1 runnable and on a run queue</span></pre></td></tr><tr><td class="code"><pre><span class="line">Grunning,         &#x2F;&#x2F; 2 running</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gsyscall,         &#x2F;&#x2F; 3 performing a syscall</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gwaiting,         &#x2F;&#x2F; 4 waiting for the runtime</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gmoribund_unused, &#x2F;&#x2F; 5 currently unused, but hardcoded in gdb scripts</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gdead,            &#x2F;&#x2F; 6 goroutine is dead</span></pre></td></tr><tr><td class="code"><pre><span class="line">Genqueue,         &#x2F;&#x2F; 7 only the Gscanenqueue is used</span></pre></td></tr><tr><td class="code"><pre><span class="line">Gcopystack,       &#x2F;&#x2F; 8 in this state when newstack is moving the stack</span></pre></td></tr></table></figure>
<blockquote>
<p>当我们查看我们创建的10个goroutines时，我们现在可以查看它们的状态并更好地了解每个goroutine正在做什么：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Goroutines running in a processor. (idleprocs&#x3D;0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">G4: status&#x3D;2(sleep) m&#x3D;3 lockedm&#x3D;-1   – Thread M3 &#x2F; Processor P0</span></pre></td></tr><tr><td class="code"><pre><span class="line">G10: status&#x3D;2(sleep) m&#x3D;2 lockedm&#x3D;-1  – Thread M2 &#x2F; Processor P1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Goroutines waiting to be run on a particular processor. (runqsize&#x3D;3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">G5: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G7: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G8: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Goroutines waiting to be run on a particular processor. (runqsize&#x3D;3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">G11: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G12: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G13: status&#x3D;1(sleep) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Goroutines waiting on the global run queue. (runqueue&#x3D;2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">G6: status&#x3D;1(stack growth) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">G9: status&#x3D;1(stack growth) m&#x3D;-1 lockedm&#x3D;-1</span></pre></td></tr></table></figure>


<blockquote>
<p>通过对调度程序的基本了解以及了解程序的行为，我们可以详细了解事情的调度方式以及程序中每个处理器，线程和goroutine的状态。</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<p><code>GODEBUG</code>是在程序运行时窥视调度程序思维的好方法。 它可以告诉你很多关于程序的行为方式。 如果您想了解更多信息，请首先编写一些可用于预测来自调度程序的跟踪的简单程序。 在尝试查看更复杂程序的跟踪之前，了解期望的内容。</p>
</blockquote>
<p><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之网络</title>
    <url>/blog/2019/06/21/20190621005014.html</url>
    <content><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><blockquote>
<p>介绍部分docker的网络驱动</p>
</blockquote>
<h2 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h2><h3 id="docker0网桥"><a href="#docker0网桥" class="headerlink" title="docker0网桥"></a>docker0网桥</h3><blockquote>
<p>当在一台Linux系统的机器上装了Docker后，在宿主机上使用ifconfig命令可以看到多了一块名为docker0的网卡，我本地的docker0 IP是 172.17.0.0/16，宿主机上也多了一条路由：</p>
<p>#<code>route -n</code><br>…<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br>这条路由表示所有目的IP为 172.17.0.0/16的数据包都从docker0发出。使用docker创建一个容器，<code>docker run -d busybox</code>，进入到容器中查看网络设备信息<code>ip addr</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">77: eth0@if78: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span></pre></td></tr><tr><td class="code"><pre><span class="line">    link&#x2F;ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet 172.17.0.2&#x2F;16 brd 172.17.255.255 scope global eth0</span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr></table></figure>
<blockquote>
<p>该容器网卡eth0连接在 if78这个设备上（不同测试环境可能不一样），在宿主机上执行<code>ip addr</code>，查看网络设备：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">78: veth3eb50a6@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span></pre></td></tr><tr><td class="code"><pre><span class="line">    link&#x2F;ether 86:5a:5e:ea:1c:60 brd ff:ff:ff:ff:ff:ff link-netnsid 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet6 fe80::845a:5eff:feea:1c60&#x2F;64 scope link </span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>
<blockquote>
<p>78号设备的设备名称是 veth3eb50a6，然后再执行命令<code>brctl show</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker0         8000.0242f959ef4b       no              veth3eb50a6</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>
<blockquote>
<p>可以发现设备 veth3eb50a6 连在网桥docker0上。</p>
<p>网桥是一个二层设备，veth3eb50a6和容器中的eth0相当于一根网线的两个端口，整个过程可以看做是：用一根网线把容器和网桥docker0连了起来。当创建容器时如果不指定容器连接到的网络，容器都将连到docker0上，那么容器之间是二层互通的，可以之间相互访问。</p>
<p>至于上边主机上为什么添加路由信息：主机通过路由，使其能够访问容器IP，它工作在三层。</p>
</blockquote>
<h3 id="docker多网桥测试"><a href="#docker多网桥测试" class="headerlink" title="docker多网桥测试"></a>docker多网桥测试</h3><blockquote>
<p>本小节测试容器加入不同的网桥，以及它们之间的连通性。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先创建网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker network create backend</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker network create frontend</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器 c1,c2,c3，其中，c1,c2接入网桥backend，c2,c3接入网桥 frontend</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker run -d --name c1 --net backend busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker run -d --name c2 --net backend busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker run -d --name c3 --net frontend busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node ~]# docker network connect frontend c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从以上来看， c1,c2同时接入网桥backend两者二层连通，c2,c3同理接入网桥frontend。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> c2上插了两根网线，分别接入了backend和frontend。</span></span></pre></td></tr></table></figure>
<blockquote>
<p>分别进入 c1 c2 c3测试另外两个容器连通性，结果如下：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>-</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>c2</td>
<td>true</td>
<td>-</td>
<td>true</td>
</tr>
<tr>
<td>c3</td>
<td>false</td>
<td>true</td>
<td>-</td>
</tr>
</tbody></table>
<p>符合预期。</p>
<p>此时在宿主机上使用 <code>ip addr</code>命令可以看到新增的两个网桥和ip，使用<code>route</code>命令可以看到对应的r转发到这两个容器的路由信息。</p>
</blockquote>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><blockquote>
<p>如果需要docker容器访问外部网络，则需要对宿主机进行配置：</p>
<ol>
<li>允许Linux内核IP转发 <code>sysctl net.ipv4.conf.all.forwarding=1</code></li>
<li>将iptables FORWARD的策略从<code>DROP</code>改为<code>AACEPT</code></li>
</ol>
<p>当访问外部时，对其做SNAT（源地址转化），对外部来说，就是宿主机在访问，外部感知不到容器的存在。</p>
<p>如果外部访问容器，则需要做端口映射，在启动容器时指定参数 <code>-p 主机端口:容器端口</code>，在iptables的nat和filter 的DOCKER链中会增加一条规则，将访问宿主机指定端口的流量转发到容器中，所以外界访问Docker容器是通过DNAT（目的地址转换）实现的。可以通过在filter的DOCKER链上添加规则来限制源IP的数据包访问容器。</p>
</blockquote>
<h2 id="overlay网络"><a href="#overlay网络" class="headerlink" title="overlay网络"></a>overlay网络</h2><blockquote>
<p>docker中的overlay驱动使用IETF标准的VXLAN方式。</p>
<p>TODO</p>
</blockquote>
<h1 id="高级网络"><a href="#高级网络" class="headerlink" title="高级网络"></a>高级网络</h1><h2 id="Linux-NetworkNamespace"><a href="#Linux-NetworkNamespace" class="headerlink" title="Linux NetworkNamespace"></a>Linux NetworkNamespace</h2><blockquote>
<p>TODO</p>
</blockquote>
<h2 id="容器跨主机访问方案"><a href="#容器跨主机访问方案" class="headerlink" title="容器跨主机访问方案"></a>容器跨主机访问方案</h2><blockquote>
<p>TODO</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker网络</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s问题总结</title>
    <url>/blog/2019/06/20/20190620225015.html</url>
    <content><![CDATA[<blockquote>
<p>总结遇到的问题及解决方案</p>
</blockquote>
<h1 id="设计类问题"><a href="#设计类问题" class="headerlink" title="设计类问题"></a>设计类问题</h1><h2 id="集群Master高可用"><a href="#集群Master高可用" class="headerlink" title="集群Master高可用"></a>集群Master高可用</h2><blockquote>
<p>创建集群时，使用多个Master就不提了，这是基础。</p>
<ol>
<li>一般做法是使用Keepalived陪VIP，结合health_check来做高可用，但这种做法存在一个问题：所有的rest请求都落到一个Master上，当客户端请求量比较大的时候，会导致apiserver hang死。</li>
</ol>
<p>-<br>2. 使用DNS动态解析：平安证券分享的方案（公众号上看的，公布细节有限，原话是：<code>当Master挂掉，DNS解析可在十分钟内指向新的MasterIP</code>），猜测他们的做法使用脚本去发现apiserver的运行状况，发现挂掉，就切换解析，这种做法在Master挂掉时，会存在无法访问apiserver服务的空窗期（十分钟左右，DNS解析生效时间），无法提供服务，而且所有请求也都落到一个Master上；另一种利用DNS的做法是DNS批量解析到所有Master上，当脚本检测到Master挂掉，然后解除到该Master的解析，虽然比前者好用一些，但在DNS删除解析生效期间，也会有一部分请求落到挂掉的Master上。<br>-<br>3. 使用Nginx+Keepalived方案：首先所有Master上都使用docker启动一个NGINX，并配置自动重启和检查apiserver健康的策略，然后安装好keepalived并配置VIP和设置NGINX的监控检查规则。客户端向集群发送rest请求时使用的是VIP+NGINX端口，所有请求都落到VIP Master的NGINX上，然后由NGINX转发到所有Master的apiserver上。- NGINX配置apiserver健康检查，可以保证其转发的请求都能转发到正常运行的apiserver上，keepalived配置NGINX的健康检查可以保证，每次客户端请求时都能请求到NGINX，通过这么设置，实现了NGINX的高可用和apiserver的高可用，且所有到apiserver的请求不仅仅落到某一台机器上。</p>
</blockquote>
<h2 id="不同集群Pod间网络互通"><a href="#不同集群Pod间网络互通" class="headerlink" title="不同集群Pod间网络互通"></a>不同集群Pod间网络互通</h2><blockquote>
<p>正常情况下，不同集群的Pod之间是无法相互访问的</p>
<p>想要不同集群Pod之间网络互通，必要条件是，两者的网段不能够冲突，如果冲突，无法确定Pod要访问的地址到底是另一个集群的还是当前集群的。</p>
<ol>
<li>使用网络插件。通过对Pod请求出来的数据进行重新封包（目标PodIP所在集群作为新包的目的IP），把数据包发送到目标Pod所在集群，然后网络插件再解包，把解包后的原始数据包发送到指定Pod，实现Pod网络互通的目地。</li>
<li>使用网关+路由的方式。在集群中弄几台机器用作网关，所有到该集群Pod的请求路由到这些机器，这些机器再利用kube-proxy将请求转到Pod内部，实现网络互通，但这种实现方式中，一个Pod请求到外部和外部请求进来的路径不一致。外部请求进来：proxyNode-&gt;Pod；请求到外部：Pod-&gt;Pod所在Node-&gt;外部。这种方式存在问题：对于Pod来说，每次请求的来源IP都是ProxyNode，当应用根据来源IP来做一些策略时可能存在问题。</li>
</ol>
</blockquote>
<h1 id="踩坑系列"><a href="#踩坑系列" class="headerlink" title="踩坑系列"></a>踩坑系列</h1><h2 id="apiserver请求过多，直接hang死"><a href="#apiserver请求过多，直接hang死" class="headerlink" title="apiserver请求过多，直接hang死"></a>apiserver请求过多，直接hang死</h2><blockquote>
<p>使用<code>集群Master高可用方案</code>里的第3点（参照<code>设计类问题</code>中的<code>集群Master高可用部分</code>）。</p>
</blockquote>
<h2 id="k8s-1-12以下版本kubelet使用configmap后无法删除pod"><a href="#k8s-1-12以下版本kubelet使用configmap后无法删除pod" class="headerlink" title="k8s 1.12以下版本kubelet使用configmap后无法删除pod"></a>k8s 1.12以下版本kubelet使用configmap后无法删除pod</h2><blockquote>
<p>原因：kubelet目录使用了软连接，umount时报错。解决：1.升级1.12后修复bug 2. /etc/systemd/system/kubelet.service.d/10-kubeadm.conf中启动命令加上参数 –root-dir=/app/…kubelet 直接将kubelet目录改成实际目录</p>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之资源隔离</title>
    <url>/blog/2019/06/20/20190620225014.html</url>
    <content><![CDATA[<h1 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Linux Namespace是Linux内核提供的一个功能，它可以隔离一系列的系统资源，比如：PID,UserID,NetWork等。</p>
</blockquote>
<p>当前Linux内核一共实现了6种不同类型的Namespace:</p>
<table>
<thead>
<tr>
<th>Namespace类型</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<blockquote>
<p>Namespace 的API主要使用如下三个系统调用：</p>
<ol>
<li>clone() 创建新进程。根据系统调用参数来判断哪些Namespace被创建，而且它们的紫禁城也会被包含到这些Namespace中</li>
<li>unshare() 将进程移除某个Namespace</li>
<li>setns（） 将进程加入到Namespace中</li>
</ol>
</blockquote>
<h2 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h2><blockquote>
<p>UTS Namespace主要用来隔离 nodename和domainname两个系统标识，在UTS Namespace中，每个Namespace允许有自己的hostname。</p>
</blockquote>
<p>golang测试代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file : uts.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>在代码目录下执行命令：<code>go run uts.go</code>，然后进入shell交互页面。</p>
<p>然后执行命令<code>echo $$</code>，打印出当前shell的进程id，然后再执行命令 <code>readlink /proc/$pid/ns/uts</code>，打印出的结果与直接在terminal中执行该命令结果是不一样的，说明已实现了uts隔离。</p>
<p>在该shell中修改hostname：<code>hostname -b test</code>，然后同时在该shell中和直接在terminal中打印<code>hostname</code>，发现两者不一致，说明在uts隔离的shell中对uts修改不会影响宿主机。</p>
</blockquote>
<h2 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h2><blockquote>
<p>IPC Namespace 用来隔离 信号量、消息队列和共享内存，每一个IPC Namespace的这些资源都是隔离的。<br>在上一版本的代码中略作修改：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: ipc.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC, <span class="comment">// 增加一个flag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>IPC隔离测试：</p>
<p>首先在宿主机上打开一个shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看现有 ipc message queues</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">root@master:~# ipcs -q</span></pre></td></tr><tr><td class="code"><pre><span class="line">--------- 消息队列 -----------</span></pre></td></tr><tr><td class="code"><pre><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个message queue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">root@master:~# ipcmk -Q</span></pre></td></tr><tr><td class="code"><pre><span class="line">消息队列 id：0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 然后在查看一下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">root@master:~# ipcs -q</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">--------- 消息队列 -----------</span></pre></td></tr><tr><td class="code"><pre><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span></pre></td></tr><tr><td class="code"><pre><span class="line">0xfee7b418 0          root       644        0            0 </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时能看到一个queue了，再使用另一个shell去运行程序： go run ipc.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipcs -q</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">--------- 消息队列 -----------</span></pre></td></tr><tr><td class="code"><pre><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span></pre></td></tr></table></figure>
<blockquote>
<p>由以上实验可以发现，在新建的Namespace里，看不到宿主机上创建的queue，说明IPC Namespace创建成功，IPC已经被隔离。</p>
</blockquote>
<h2 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h2><blockquote>
<p>PID Namespace是用来隔离进程ID的，同一个进程在不同的PID Namespace里可以有不同的PID，在docker容器里面，使用 <code>ps -ef</code>就会发现，容器内，前台运行的进程PID是1，但在容器外使用<code>ps -ef</code>却发现同一进程有不同的PID，这就是PID Namespace的功劳。</p>
</blockquote>
<p>测试代码，在上一节代码中增加一个CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: pid.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWPID,  <span class="comment">// add</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>同时打开两个shell，其中一个运行： <code>go run pid.go</code></p>
<p>在宿主机shell中执行命令： <code>ps -ef|grep pid.go</code>可以查到另一个shell中运行的go程序的pid，然后在另一个运行go程序的shell中执行命令: <code>echo $$</code>可以得到当前sh的pid，可以发现，在运行go程序的shell中其PID为1，而在宿主机看到该程序的PID不为1。说明PID已隔离。</p>
</blockquote>
<h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><blockquote>
<p>Mount Namespace 用来隔离各个进程看到的挂载点视图，在不同的Namespace中，看到的文件层次是不一样的，在Mount Namespace中调用mount() umount()仅影响当前Namespace的文件系统（注：Mount有传播模式，如果是share模式还是会影响到的，测试时设置private模式可避免影响）</p>
</blockquote>
<p>测试代码，在上一节基础上再增加一个CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: ns.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行程序： <code>go run ns.go</code></p>
<p>在程序shell中执行命令<code>mount --make-private /proc</code>，先修改挂载模式为private</p>
<p>修改 mount 之前，查看 /proc (<code>ls /proc</code>)目录发现里边文件有很多，然后执行命令：<code>mount -t proc proc /proc</code>，在查看 /proc目录，发现里边文件少了很多。此时使用 <code>ps -ef</code>查看系统进程，可以看到只有 <code>sh</code>进程和 <code>ps -ef</code>进程。说明Mount隔离成功。(注：/proc目录下有很多数字的目录，这些每个目录都代表一个进程，数字为进程的PID，里边存储着跟进程相关数据，Mount隔离和PID隔离配合，使得<code>ps -ef</code>命令查看到当前Namespace下的进程，且PID是从1开始编号的)</p>
<h2 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h2><blockquote>
<p>User Namespace主要是隔离用户的用户组ID，可以在宿主机上以一个非root用户运行创建一个User Namespace，并且在这个Namespace下创建root用户，且在namespace下有root权限。</p>
</blockquote>
<p>测试代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: user.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWUSER,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				ContainerID: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				HostID:      syscall.Getuid(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Size:        <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				ContainerID: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				HostID:      syscall.Getgid(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Size:        <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>以普通用户执行：<code>go run user.go</code>，在shell中输入命令<code>id</code>，打印出：<code>uid=0(root) gid=0(root) 组=0(root),65534(nogroup)</code>，但当尝试列出 <code>/root</code>目录时，会提示权限不够。</p>
</blockquote>
<h2 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h2><blockquote>
<p>Network Namespace是用来隔离网络设备，IP地址端口等网络栈的Namespace。</p>
</blockquote>
<p>测试代码：在上一节代码基础上增加CloneFlag：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: network.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"mydocker/tools/logging"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"os/exec"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"syscall"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |</span></pre></td></tr><tr><td class="code"><pre><span class="line">			syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				ContainerID: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				HostID:      syscall.Getuid(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Size:        <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				ContainerID: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				HostID:      syscall.Getgid(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Size:        <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdin = os.Stdin</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stdout = os.Stdout</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cmd.Stderr = os.Stderr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		logging.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>在宿主机上查看网络设备，<code>ifconfig</code>，可以看到很多个网络设备。</p>
<p>执行命令：<code>go run network.go</code>后，在查看网络设备，发现只有 lo 一个网络设备了，说明Network Namespace隔离成功。</p>
</blockquote>
<h1 id="Linux-Cgroup"><a href="#Linux-Cgroup" class="headerlink" title="Linux Cgroup"></a>Linux Cgroup</h1><blockquote>
<p>Linux Cgroup提供了对一组进程及将来子进程的资源限制、控制和统计的能力。</p>
</blockquote>
<h2 id="Cgroup的三个组件："><a href="#Cgroup的三个组件：" class="headerlink" title="Cgroup的三个组件："></a>Cgroup的三个组件：</h2><blockquote>
<ol>
<li>cgroup是对进程分组管理的一种机制，一个cgroup包含一组进程，并可以在这个cgroup上增加subsystem的各种参数配置，将一组进程和一组subsystem的系统参数关联起来</li>
<li>subsystem是一组资源控制的模块，一般包含以下几项：<ol>
<li>blkio：设置对块设备输入输出的访问控制</li>
<li>cpu：设置cgroup中进程的cpu被调度的策略</li>
<li>cpuacct：可以统计cgroup中进程的cpu占用</li>
<li>cpuset：在多核机器上设置cgroup中进程可以使用的cpu和内存</li>
<li>devices：控制cgroup中进程对设备的访问</li>
<li>freezer：用于挂起和恢复cgroup中的进程</li>
<li>memory：用于控制cgroup中进程的内存占用</li>
<li>net_cls：用于将cgroup中进程产生的网络包分类，以便Linux的tc(traffic controller)可以根据分类区分出来自某个cgroup的包并做限流或监控</li>
<li>net_prio：设置cgroup中进程产生的网络流量的优先级</li>
<li>ns：使cgroup中的进程在新的Namespace中fork新进程时，创建一个新的cgroup，这个cgroup包含新的Namespace中的进程</li>
</ol>
</li>
<li>hierarchy的功能是把一组cgroup串成一个树状结构，通过树状结构Cgroup可以做到集成</li>
</ol>
</blockquote>
<h2 id="三个组件相互关系"><a href="#三个组件相互关系" class="headerlink" title="三个组件相互关系"></a>三个组件相互关系</h2><blockquote>
<ol>
<li>系统在创建了新的hierarchy后，系统中所有进程都会加入这个hierarchy的cgroup根节点，这个cgroup根节点是hierarchy默认创建的</li>
<li>一个subsystem只能附加到一个hierarchy上</li>
<li>一个hierarchy能附加多个subsystem</li>
<li>一个进程可以作为多个cgroup成员，但这些cgroup必须在不同的hierarchy中</li>
<li>一个进程fork出子进程时，子进程和父进程是在同一个cgroup中，也可移到其他cgroup中</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker资源隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础之镜像存储</title>
    <url>/blog/2019/06/16/20190616225014.html</url>
    <content><![CDATA[<h1 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h1><h2 id="什么是Union-File-System"><a href="#什么是Union-File-System" class="headerlink" title="什么是Union File System"></a>什么是Union File System</h2><blockquote>
<p>Union File System简称 UnionFS，是一种为Linux，FreeBSD，NetBSD操作系统设计的，把其他文件系统联合到一个挂载点的文件系统服务。它使用<code>branch</code>将不同文件和目录透明地覆盖，形成一个单一一致的文件系统。这些<code>branch</code>都是readonly或read-write的，当对这个虚拟后的联合文件系统进行写操作时，系统是真正写到了一个新的文件中，看起来这个虚拟的联合文件系统是对任何文件进行操作的，但实际上并未改变原来的文件，unionFS使用了写时复制技术。</p>
<p>写时复制（copy on write，简称CoW），也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。主要思想：如果一个资源是重复的，没有任何修改，这时并不需要立即创建一个新资源，这个资源可以被共享，一旦有写操作发生时，就会将该资源复制一份，而且写操作发生在新copy的资源上。通过这种方式，可以减少未修改资源复制带来的消耗和硬盘存储的消耗。</p>
</blockquote>
<h2 id="Aufs"><a href="#Aufs" class="headerlink" title="Aufs"></a>Aufs</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>aufs(Advanced multi layered unification filesystem)是一种支持联合挂载的文件系统，aufs将不同目录分层挂载到同一个目录下，每一层都是一个普通的文件系统。</p>
</blockquote>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><blockquote>
<p>当需要读写一个文件时，会从最顶层开始向下寻找，本层没有，则根据层之间的关系到下一层找，直到找到第一个文件并打开它。</p>
<p>当写入一个文件时，如果文件不存在，则在读写层新建一个，否则向上边一个过程一样从顶层开始查找，直到找到最近的文件，aufs会将其复制到读写层进行修改。</p>
<p>当删除一个文件时，若文件仅存在于读写层，则可以直接删除，否则删除其在读写层的北方，再在读写层创建一个whiteout文件来标识文件不存在。</p>
<p>当新建一个文件时，若文件在读写层存在whiteout文件，则先删除之再新建，否则直接新建。</p>
</blockquote>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Device Mapper是一种从逻辑设备到物理设备的映射框架，通过使用它，用户可以很方便地根据自己的需要制定实现存储资源的管理策略。</p>
<p>它主要包括3个概念：映射设备、映射表、目标设备。</p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote>
<p>docker使用Device Mapper的CopyOnWrite发生在块存储级别。Device mapper驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个叫用时分配。当要修改已有文件时，再使用CoW为容器快照分配块空间，将要修改的数据复制到在容器快照中新的块里再进行修改。Device mapper 驱动默认会创建一个100G的文件包含镜像和容器。每一个容器被限制在10G大小的卷内，可以自己配置调整。</p>
<p>DeviceMapper 根据使用的基础块设备是真正的块设备哈斯稀疏文件挂载的loop设备分为两种模式：direct-lvm模式和loop-lvm模式，两者性能差别很大。</p>
</blockquote>
<h2 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Overlay主要目录结构：lower，upper，work，merge：</p>
<ol>
<li>lower：在docker中用于存放镜像分层文件，只读。可以有多个</li>
<li>upper：在docker中用于存放修改的文件，新增、修改、删除等，对应docker存储的 diff目录</li>
<li>work：</li>
<li>merge：存放多个lower、upper合并后的文件和目录，对应docker的 merge目录</li>
</ol>
<p>对联合挂载在merge目录下的文件操作规则：</p>
<ol>
<li>新增：新增文件会直接将新增的文件写入到upper目录下</li>
<li>修改：如果对lower层中的文件修改，则会引起copy，文件copy到upper目录下，所有修改操作在upper目录下完成；如果对upper目录文件修改（包括新增的文件和已经从底层copy出的文件），则直接修改</li>
<li>删除：在upper目录中会对文件标记删除（使用ll查看文件标识为<code>c --- --- ---</code>，正常文件第一个标识位为-，目录为d），合并到merge目录下的效果为删除。</li>
</ol>
</blockquote>
<h3 id="大文件修改"><a href="#大文件修改" class="headerlink" title="大文件修改"></a>大文件修改</h3><blockquote>
<p>对lower层大文件修改时，会产生一个<code>.file.swp</code>（<code>.</code>前缀和<code>.swp</code>后缀）文件，修改文件在该文件操作，当执行保存时，首先将文件从lower层该文件复制到upper层中，命名为<code>file~</code>（在文件后加<code>~</code>后缀），然后将<code>file~</code>与<code>.file.swp</code>文件合并生成最终文件并删除<code>file~</code>。<br>本地测试显示，当保存文件时，新<code>file</code>和<code>file~</code>与<code>lower</code>层<code>file</code>曾同时共存。当文件从<code>file~</code> 完全copy到<code>file</code>时，会被删除。</p>
</blockquote>
<hr>
<blockquote>
<p>本地测试记录：<br>当使用vim打开大文件时，对应的upper目录中生成了 <code>.file.swp</code>文件，当对其编辑时，所有修改操作都在该文件中记录（随着新增内容，swp文件大小随之改变）；当执行保存时，<code>upper</code>中生成了<code>file~</code>文件，当该文件大小不再变动时查看大小，发现与lower层中文件大小一致，说明该文件为lower层文件的副本。</p>
<p>此过程与Linux写大文件操作基本一致：本地生成.swp文件，然后直接将源文件重命名为<code>file~</code>，再合并两者为最终文件，然后删除<code>file~</code>。在OverlayFS中区别为，<code>file~</code>文件在OverlayFS中是从底层复制的[当修改upper层文件时与Linux中写大文件操作一致]，而在Linux中写大文件时<code>file~</code>是直接把源文件重命名的</p>
</blockquote>
<h3 id="自己动手使用Overlay"><a href="#自己动手使用Overlay" class="headerlink" title="自己动手使用Overlay"></a>自己动手使用Overlay</h3><blockquote>
<p>实验环境：centos7，内核：4.4.169-1.el7.elrepo.x86_64</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">文件路径： /app/overlayfs-test</span></pre></td></tr><tr><td class="code"><pre><span class="line">目录结构：</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer1</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer2</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer3</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer4</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 4.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── mnt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── upper</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── work</span></pre></td></tr><tr><td class="code"><pre><span class="line">   └── work</span></pre></td></tr><tr><td class="code"><pre><span class="line">文件内容： </span></pre></td></tr><tr><td class="code"><pre><span class="line">1. layer&#123;n&#125;/&#123;n&#125;.txt 内容里的内容为 n</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. layer&#123;n&#125;/tmp.txt 内容里的内容为 n </span></pre></td></tr></table></figure>

<p>执行命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t overlay -o lowerdir=/app/overlayfs-test/layer1:/app/overlayfs-test/layer2:/app/overlayfs-test/layer3:/app/overlayfs-test/layer4,upperdir=/app/overlayfs-test/upper,workdir=/app/overlayfs-test/work overlay /app/overlayfs-test/mnt</span></pre></td></tr></table></figure>
<blockquote>
<p>命令格式： <code>(格式：mount -t overlay -o lowerdir=pwd1:pwd2,upperdir=pwd3,workdir=pwd4 overlay pwd5)</code></p>
<p>格式说明：命令中 <code>pwd{n}</code>部分均为变量，根据自己挂载情况修改，lowerdir=pwd1:pwd2，当pwd1和pwd2中有同名文件，则显示的是pwd1中的文件。upperdir指定了upper文件的目录，workdir指定了work目录，最后一个参数指定了merge目录。</p>
<p>执行后的目录结构：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer1</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer2</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer3</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer4</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 4.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── mnt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 4.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── upper</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── work</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── work</span></pre></td></tr></table></figure>
<blockquote>
<p>如上， {n}.txt都挂载到了 mnt目录下，tmp.txt文件则只有一个，<code>cat mnt/tmp.txt</code>输出<code>1</code></p>
<p>在mnt目录新增文件<code>x.txt</code>输入x，删除<code>1.txt</code>，编辑<code>2.txt</code>输入x2，新的目录结构：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer1</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer2</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer3</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── layer4</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 4.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── mnt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 4.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── tmp.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── x.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── upper</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── x.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── work</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── work</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; upper目录中，执行命令：</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;bash</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node2 upper]# ll</span></pre></td></tr><tr><td class="code"><pre><span class="line">总用量 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">c--------- 1 root root 0, 0 6月  16 23:36 1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root    3 6月  16 23:36 2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root    2 6月  16 23:36 x.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node2 upper]# cat 2.txt </span></pre></td></tr><tr><td class="code"><pre><span class="line">x2</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@node2 upper]# cat x.txt </span></pre></td></tr><tr><td class="code"><pre><span class="line">x</span></pre></td></tr></table></figure>
<blockquote>
<p>其中，<code>1.txt</code>标记为删除，<code>2.txt</code>内容改为x2，<code>x.txt</code>是新增的文件</p>
<p>在<code>mnt</code>目录下，文件<code>1.txt</code>也确实被删除了，<code>x.txt</code>文件也添加进来了，<code>2.txt</code>内容也改为x2。反观<code>layer1</code>目录下，<code>1.txt</code>文件还存在，<code>layer2</code>目录中<code>2.txt</code>内容仍然为<code>2</code></p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker镜像存储</tag>
      </tags>
  </entry>
  <entry>
    <title>client-go源码阅读之-controller(+简单实现)</title>
    <url>/blog/2019/06/06/20190606154010.html</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简单介绍controller实现过程中涉及到的client-go中的几个组件，并尝试使用简单的方式手撸一个可以实现一个类似client-go中<code>controller</code>功能的demo。</p>
<p>注：本文client-go是从<code>kubernetes 1.13</code>的项目源码中拷贝出来的，文中标记的代码行数以此为准。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>NewIndexerInformer()是定义在<code>client-go/tools/cache/shared_informer</code>中的一个函数，返回值为<code>indexer,controller</code>，本文主要讲controller的功能实现(也会简单提到indexer)，它用来监听k8s集群中的某一种资源，针对资源对象的不同事件(add/update/delete)执行用户自定义的事件处理函数。</p>
<p>其在k8s中的应用十分广泛</p>
<ol>
<li>k8s里的系统组件：k8s调度器里通过监听pod资源对象来对其进行调度、k8s的kube-proxy通过监听service/endpoints资源对象的变化来配置各个节点的网络等等；</li>
<li><code>CRD</code></li>
<li>使用该组件对k8s中的资源进行状态监控(deployment、daemonSet、pod等)</li>
<li>使用该组件对k8s中的资源配额进行监控</li>
<li>其他</li>
</ol>
</blockquote>
<h1 id="controller-基本组成部分介绍"><a href="#controller-基本组成部分介绍" class="headerlink" title="controller 基本组成部分介绍"></a>controller 基本组成部分介绍</h1><blockquote>
<p>先讲几个在<code>controller</code>中引用到的几个结构体</p>
</blockquote>
<h2 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h2><blockquote>
<p>首先看一下如何<code>New</code>一个<code>Indexer</code>对象：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go  line: 112</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cacheStorage ThreadSafeStore</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// should be deterministic.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	keyFunc KeyFunc</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go  line: 239</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">		keyFunc:      keyFunc,  </span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 注KeyFunc定义： type KeyFunc func(obj interface&#123;&#125;) (string, error)</span></span></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，<code>NewIndexer</code>返回的是一个<code>cache</code>对象，而<code>cache</code>实现了<code>Indexer</code>接口。<br>再结合cache的定义可以知道，此处的<code>Indexer</code>就是一个线程安全的存储，<code>keyFunc</code>的作用就是给定一个对象，然后返回该对象的<code>key</code>值。暂时简单地理解<code>Indexer</code>不去深究其内部其他逻辑，将其视为一个线程安全的<code>map</code>存储即可，这个<code>map</code>的<code>key</code>值可以通过调用<code>keyFunc(val)</code>获得。</p>
</blockquote>
<h2 id="ListWatch"><a href="#ListWatch" class="headerlink" title="ListWatch"></a>ListWatch</h2><blockquote>
<p>首先看下 ListWatch的定义：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListWatch knows how to list and watch a set of apiserver resources.  It satisfies the ListerWatcher interface.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// It is a convenience function for users of NewReflector, etc.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ListFunc and WatchFunc must not be nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListWatch <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ListFunc  ListFunc</span></pre></td></tr><tr><td class="code"><pre><span class="line">	WatchFunc WatchFunc</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// DisableChunking requests no chunking for this list watcher.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	DisableChunking <span class="keyword">bool</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>主要包括两个函数对象(先不去理会DisableChunking)，<code>ListFunc</code>作用主要是列出k8s集群中的资源对象，<code>WatchFunc</code>作用主要是监听k8s集群中的资源对象。</p>
<p>先看下创建<code>ListWatch</code>的代码吧：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredListWatchFromClient</span><span class="params">(c Getter, resource <span class="keyword">string</span>, namespace <span class="keyword">string</span>, optionsModifier <span class="keyword">func</span>(options *metav1.ListOptions)</span>) *<span class="title">ListWatch</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	listFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		optionsModifier(&amp;options)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> c.Get().</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Namespace(namespace).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Resource(resource).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Do().</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Get()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	watchFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		options.Watch = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		optionsModifier(&amp;options)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> c.Get().</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Namespace(namespace).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Resource(resource).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Watch()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;ListWatch&#123;ListFunc: listFunc, WatchFunc: watchFunc&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>从代码中可用看到，这里创建了两个函数对象，ListFunc和WatchFunc，这两个函数返回的都是向apiserver发请求的对象，不过其发送请求的<code>Action</code>不同，一个是<code>Get</code>，一个是<code>Watch</code>，那ListWatch对象如何知道去Get/Watch哪个集群的资源对象呢，这个就是通过参数<code>c</code>来指定了，k8s的ClientSet实现了<code>Getter</code>接口，可以作为参数传进来。</p>
<p>到此处是不是感觉接触到了controller的核心部分了呢？到这里就算是比较接近底层的部分了，再向底层分析就是client-go向apiserver发请求和解析请求结果的部分了，深度上先到此为止<br>（在本篇中，我们不去关心更底层是如何Watch到资源的变化情况的，也不关心数据是怎么在client和apiserver中传输和解析的<br>只需知道ListWatch已经能够<code>Get</code>和<code>Watch</code>到集群的资源就够了）。</p>
</blockquote>
<h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><blockquote>
<p><code>DeltaFIFO</code>，从名字可以看出这是一个变化的队列，且是先进先出的队列。稍微解释一下，这个队列实际包含两层队列。先看下定义的这部分：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/delta_fifo.go  96行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// line：104</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span></pre></td></tr><tr><td class="code"><pre><span class="line">    queue []<span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    keyFunc KeyFunc</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 补充一下Deltas的定义：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Deltas []Delta</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Type   DeltaType  <span class="comment">// 字符串，Added,Updated,Deleted等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>先介绍一下 keyFunc，keyFunc和上边的Indexer里的keyFunc作用类似，都是根据对象返回一个key值，这里求得的key值主要用于 queue中的值，还有items这个map中的键值，从而，当从queue中取出队列头部元素时，可以根据这个元素值从items中取出对应的具体value</p>
<p>以下分析DeltaFIFO的两层队列实现：<br>首先，queue是一个队列，数组保存队列，也很容易实现先进先出，queue队列中元素出队时，从item中取出<code>items[queue[0]]</code>元素并删除，queue也删除0号元素即可完成队列的<code>Pop</code>操作。从Deltas的定义看到，这是一个Delta数组，<code>items[queue[0]]</code>也是一个队列，这个队列存的是Delta对象，既然它们存储在同一个<code>items[key]</code>下，那么表示它们是同一个资源对象的<code>Delta</code>，即：这个队列表示的是同一个对象的事件队列。</p>
<p>综上： queue表示的是不同资源对象的队列，items的value值表示的是同一资源对象的事件队列。</p>
<p>有点拗口，想象一下这个场景： 假设有3个pod资源对象，记为 a,b,c，</p>
<ol>
<li>a发生变化deltaA1，此时a加入到queue队列，a的变化事件加到items[a]这个事件队列</li>
<li>b发生变化deltaB1，此时b假如到queue队列，b的变化事件加到items[b]这个事件队列</li>
<li>a又发生变化deltaA2，此时items中已经存在items[a]了，表示a已经在队列queue中了，此时，获取到items[a]事件队列，然后将这次变化加入队列<br>此时，queue和items中的数据为：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue : [a,b]</span></pre></td></tr><tr><td class="code"><pre><span class="line">items : &#123;a:[deltaA1,deltaA2], b: [deltaB1]&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>如果上边步骤<code>3</code>发生时，queue已经执行过一次出队操作，那么：<br>a发生变化deltaA2时，items中items[a]不存在，表示a不在队列中，便将a加到queue队列，deltaA2加到items[a]这个事件队列中去。此时，queue和items中的数据为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue: [b,a]</span></pre></td></tr><tr><td class="code"><pre><span class="line">items: &#123;a:[deltaA2], b: [deltaB1]&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意：items是map，其内部的&#96;k-v&#96;键值对不分先后顺序，只有v的值分先后顺序，因为v是数组</span></pre></td></tr></table></figure>

<blockquote>
<p>讲了这么多，大概应该能明白DeltaFIFO的作用了吧，简单点说就是存储k8s资源对象变化事件的队列。</p>
</blockquote>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><h3 id="controller初始化"><a href="#controller初始化" class="headerlink" title="controller初始化"></a>controller初始化</h3><blockquote>
<p>在controller里，存储了ListWatch，objType(监听的资源对象类型)，ResourceEventHandler(资源事件handler)，DeltaFIFO，以及Process</p>
<p>代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/controller.go line:345</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexerInformer</span><span class="params">(</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">	lw ListerWatcher,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">	objType runtime.Object,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">	resyncPeriod time.Duration,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">	h ResourceEventHandler,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">	indexers Indexers,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">)</span> <span class="params">(Indexer, Controller)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// This will hold the client state, as we know it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 定义Indexer（线程安全的存储）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	clientState := NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// This will hold incoming changes. Note how we pass clientState in as a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// KeyLister, that way resync operations will result in the correct set</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// of update/delete deltas.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 定义FIFO（事件队列）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cfg := &amp;Config&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Queue:            fifo,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 将ListWatch对象赋值到cfg，传递给controller</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		ListerWatcher:    lw,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ObjectType:       objType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		FullResyncPeriod: resyncPeriod,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		RetryOnError:     <span class="literal">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 资源对象变化处理函数，obj类型是Deltas，就是上边降到DeltaFIFO中 items这个map对象的value的数据类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这个函数是在 fifo.queue这个队列出队的时候调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Process: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// from oldest to newest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">switch</span> d.Type &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">case</span> Sync, Added, Updated:</span></pre></td></tr><tr><td class="code"><pre><span class="line">				    <span class="comment">// 判断Indexer中是否有该元素，有则表示是更新操作，没有表示是新增操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				    <span class="comment">// 该判断逻辑一定对的前提：下边Add事件时，Indexer同步add，Delete事件时，同步delete</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				    <span class="comment">// 此时更新Indexer中的数据，并调用 h.OnUpdate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				    <span class="comment">// Indexer中存储数据的更重要的一点是，本地存储新更新到来之前的最新版本资源对象，那么当更新事件到来时，客户端可以有新旧对象供handler使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> old, exists, err := clientState.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="comment">// update Indexer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> err := clientState.Update(d.Object); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">							<span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="comment">// 调用handler事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						h.OnUpdate(old, d.Object)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					    <span class="comment">// add to Indexer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> err := clientState.Add(d.Object); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">							<span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="comment">// 调用handler事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						h.OnAdd(d.Object)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">case</span> Deleted:</span></pre></td></tr><tr><td class="code"><pre><span class="line">				    <span class="comment">// delete from Indexer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> err := clientState.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// 调用handler事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					h.OnDelete(d.Object)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> clientState, New(cfg)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="controller运行"><a href="#controller运行" class="headerlink" title="controller运行"></a>controller运行</h3><blockquote>
<p>controller启动方法是 controller.Run()，首先看下源码：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/controller.go line:100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;-stopCh</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.config.Queue.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	r := NewReflector(</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.config.ListerWatcher,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.config.ObjectType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.config.Queue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		c.config.FullResyncPeriod,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	r.ShouldResync = c.config.ShouldResync</span></pre></td></tr><tr><td class="code"><pre><span class="line">	r.clock = c.clock</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.reflectorMutex.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.reflector = r</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c.reflectorMutex.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> wg wait.Group</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> wg.Wait()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 此处启动一个协程，运行 r.Run函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// r.Run即Reflector对象的Run方法，定义在 client-go/tools/cache/reflector.go line:121</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 通过查看 r.Run可以知道，它又运行了 r.ListAndWatch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// r.ListAndWatch里的逻辑就是真正获取k8s资源对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 在该函数中又调用r.watchHandler 来监控着资源的事件，并将其加到r.store中(在本文描述场景中，r.store即为DeltaFIFO)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 此处启动processLoop循环处理事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 从队列(DeltaFIFO)中取出数据，执行 process（前边在NewIndexerInformer中定义的process）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// c.config.Queue.Pop方法定义在：client-go/tools/cache/delta_fifo.go line:411</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> err == FIFOClosedError &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>通过 controller.Run方法，整个资源状态监控的过程就完成了。</p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>通过以上讲informer中使用到的各个组件的功能及作用，整个informer工作流程大概如下：</p>
<ol>
<li>首先调用ListWatch中的List方法，初步将k8s中待监听资源拉到本地，将其加到本地存储Indexer和事件队列DeltaFIFO中(初始化时将这些资源的变化事件看做是ADD)</li>
<li>异步1：使用ListWatch中Watch方法不断去监听事件，监听到后将其加到 DeltaFIFO中</li>
<li>异步1：无限循环：<ol>
<li>阻塞方法去从队列中取出数据（使用到了sync.cond）</li>
<li>取到的数据类型是 Deltas，调用 controller中的Process方法（上边的NewIndexerInformer里定义的）</li>
<li>// 在Process方法里调用用户自定义的handler</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p>以上过程讲的比较简单，实际client-go的代码中很多出错逻辑处理、同步数据、以及多协程时的数据存储优化。</p>
</blockquote>
<h1 id="手撸实现"><a href="#手撸实现" class="headerlink" title="手撸实现"></a>手撸实现</h1><blockquote>
<p>client-go中，controller 部分代码使用了很多接口，而且封装的太深，看它的源码时没那么容易。</p>
<p>基于以上对 controller 的分析，自己实现了一个比较简单的 controller，弄懂这个后再去深究 client-go的实现会事半功倍。</p>
<p>代码地址：<a href="https://github.com/geedchin/client-go-src-learning" target="_blank" rel="noopener">https://github.com/geedchin/client-go-src-learning</a><br>核心部分在 02_watch中</p>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>功能组件</category>
        <category>client-go</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>client-go</tag>
        <tag>controller</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的理解与运用</title>
    <url>/blog/2019/05/23/20190523000154.html</url>
    <content><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><blockquote>
<p>堆是一种完全二叉树，且每个节点都大于等于（小于等于）其子节点的值。</p>
<p>大顶堆：每个节点都大于等于其子节点的堆<br>小顶堆：每个节点都小于等于其子节点的堆</p>
</blockquote>
<h1 id="如何存储堆"><a href="#如何存储堆" class="headerlink" title="如何存储堆"></a>如何存储堆</h1><blockquote>
<p>根据堆的定义，其为完全二叉树，则可以使用数组来存储堆。<br>使用数组存储堆相比于链式存储有以下优点：</p>
<ol>
<li>访问任意位置元素时间复杂度为O(1)</li>
<li>访问每个节点的子(父)节点耗时与链式存储几乎无差异。假如某节点在数组的索引是<code>x</code>,则其父节点索引为 <code>(x+1)/2-1</code>，左右子节点分别为<code>(x+1)*2-1</code>与<code>(x+1)*2</code></li>
<li>数组在内存中按顺序存储，对CPU更友好，缓存命中高</li>
</ol>
</blockquote>
<h1 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h1><blockquote>
<p>以下涉及堆均默认为小顶堆，大顶堆与其类似，只是判断大小逻辑需调整</p>
</blockquote>
<h2 id="向堆中增加元素"><a href="#向堆中增加元素" class="headerlink" title="向堆中增加元素"></a>向堆中增加元素</h2><blockquote>
<p>把新的元素放至堆的末位，为使其仍然符合堆的定义，则需要对其进行调整。<br>这个过程叫做堆化(heapify)：</p>
<p>将新元素与其父元素做比较，如果比父节点值小，则与父节点交换位置，以此类推，通过不断的与新父节点作比较与交换，最终到达合适的位置，正好满足堆的定义。</p>
<p>Go语言实现自下而上的堆化过程代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自下而上的堆化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        parent := (x+<span class="number">1</span>)/<span class="number">2</span> - <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> arr[x] &lt; arr[parent] &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            arr[x], arr[parent] = arr[parent], arr[x]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = parent</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><blockquote>
<p>从堆的定义中可知，对顶元素即为堆中的最小值，当删除该值时，需将剩下元素的最小值放到堆顶，而且其最小值必定是堆顶元素的子节点;<br>将最小值移上去后，还需填充该位置以满足其完全二叉树的性质，再去从该位置的子节点中找最小元素… 最终将堆中最后一行中的某个元素移到上一层，但此时可能不满足满二叉树的性质，又要将最后一个位置的值移到该位置（移了之后又可能不满足堆的性质，又要堆化），此过程还是比较麻烦的。</p>
<p>如果考虑将堆顶元素删除后，直接将最后一个元素移到此位置，则只需对其自上而下堆化即可:<br>0. 将堆顶元素删除，并将堆中最后一个元素放到堆顶</p>
<ol>
<li>从堆顶开始，将堆顶视为当前元素</li>
<li>比较当前元素与子节点元素的大小，取出最小的，如果最小的为本身，则直接结束；</li>
<li>否则，交换最小的子节点元素与当前元素值，</li>
<li>将最小子节点作为当前节点，重复2，直到当前节点为叶子节点</li>
</ol>
<p>Go语言实现自上而下的堆化过程代码如下：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify2</span><span class="params">(arr []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arrLen := <span class="built_in">len</span>(arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		right := (n + <span class="number">1</span>) * <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		left := right - <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> left &gt;= arrLen &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		mini := n</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 判断左右子节点，找出最小节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> right &lt; arrLen &amp;&amp; arr[right] &lt; arr[mini] &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mini = right</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> arr[left] &lt; arr[mini] &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mini = left</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 如果最小节点是当前节点，则退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> mini == n &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 将最小位置的值与当前位置交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr[mini], arr[n] = arr[n], arr[mini]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n = mini</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="如何基于堆实现排序"><a href="#如何基于堆实现排序" class="headerlink" title="如何基于堆实现排序"></a>如何基于堆实现排序</h1><blockquote>
<p>大致过程分为两步：建堆和排序</p>
</blockquote>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><blockquote>
<p>建堆有两种方法：</p>
<ol>
<li>堆中元素从1个不断增加，增加到指定长度，这个过程使用了自下向上的堆化过程。时间复杂度为O(nlg(n))</li>
<li>从数组中间开始遍历到数组0索引位置，对每个位置实行自上而下的堆化过程。时间复杂度O(n)</li>
</ol>
<p>第二种建堆方法Go实现：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitHeap</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arrLen := <span class="built_in">len</span>(arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := arrLen/<span class="number">2</span> + <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		heapify(arr, i) <span class="comment">// 调前边的实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>不断从堆中取出最小值，取得数据的序列即为从小到大的排序结果</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveTop</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ret := arr[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr[<span class="number">0</span>] = arr[<span class="built_in">len</span><span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr = arr[<span class="number">0</span> : <span class="built_in">len</span><span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	heapify(arr, <span class="number">0</span>) <span class="comment">// 调前边的实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> ret</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>go接口中的‘陷阱’</title>
    <url>/blog/2019/04/10/20190410140732.html</url>
    <content><![CDATA[<h1 id="接口值陷阱"><a href="#接口值陷阱" class="headerlink" title="接口值陷阱"></a>接口值陷阱</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>接口值共有两部分组成：具体的类型、该类型的值。它们称之为接口值的动态类型和动态值。</p>
</blockquote>
<h2 id="接口值判断陷阱"><a href="#接口值判断陷阱" class="headerlink" title="接口值判断陷阱"></a>接口值判断陷阱</h2><blockquote>
<p>既然接口值有两部分组成，那么，接口值的相等性判断是否也要类型及值均相等才算相等呢？</p>
<p>答案是肯定的，以下两个示例：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公共部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 均无方法，方便测试</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看作Student Teacher都实现了 People接口</span></span></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1, p2 People</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s *Student</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t *Teacher</span></pre></td></tr><tr><td class="code"><pre><span class="line">fmt.Println(s == <span class="literal">nil</span>, t == <span class="literal">nil</span>) <span class="comment">// true true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">p1 = s</span></pre></td></tr><tr><td class="code"><pre><span class="line">p2 = t</span></pre></td></tr><tr><td class="code"><pre><span class="line">fmt.Println(p1 == p2) <span class="comment">// false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// p1 p2 值均为空，但其类型不同，因此判断相等结果为false</span></span></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 People</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s *Student</span></pre></td></tr><tr><td class="code"><pre><span class="line">fmt.Println(p1 == <span class="literal">nil</span>) <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fmt.Println(s == <span class="literal">nil</span>)  <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">p1 = s</span></pre></td></tr><tr><td class="code"><pre><span class="line">fmt.Println(p1 == <span class="literal">nil</span>) <span class="comment">// false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// p1 值为nil，但类型不为nil，所以p1与nil做相等比较结果false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 此处要注意，在函数中用接口类型做为形参时，如果直接将其与nil做比较来判断其是否为空，可能会有意想不到的结果，且不易排查</span></span></pre></td></tr></table></figure>

<h1 id="接口不同实现方式"><a href="#接口不同实现方式" class="headerlink" title="接口不同实现方式"></a>接口不同实现方式</h1><ol>
<li>使用指针接收者实现</li>
<li>使用类型接收者实现</li>
</ol>
<h2 id="指针接收者实现"><a href="#指针接收者实现" class="headerlink" title="指针接收者实现"></a>指针接收者实现</h2><blockquote>
<p>使用指针接收者实现，则只有该实体类型的指针实现了该接口。<br>不能将实体类型的值赋值给该接口类型变量。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	SayHello()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Student)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> p People</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// p =  Student&#123;&#125; // 编译报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	p = &amp;Student&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p.SayHello()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="类型接收者实现"><a href="#类型接收者实现" class="headerlink" title="类型接收者实现"></a>类型接收者实现</h2><blockquote>
<p>能够将实体类型和实体类型的指针赋值给接口类型变量。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	SayHello()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Student)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> p People</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p =  Student&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p.SayHello()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p = &amp;Student&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p.SayHello()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go接口</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言接口简介</title>
    <url>/blog/2019/04/10/20190410133551.html</url>
    <content><![CDATA[<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><br> 

<blockquote>
<p>接口是一种描述一类事物具有相同操作的抽象：即某一类的事物都具有相同的操作合集。</p>
</blockquote>
<h2 id="go接口"><a href="#go接口" class="headerlink" title="go接口"></a>go接口</h2><br> 

<blockquote>
<p>在大多数语言中，实现某接口必须用 implement 显示地声明自己实现的是声明接口，而在go语言中，则无需声明实现接口，这种特性可称之为 <code>duck typing</code>。<br>比如，假设一只鸭子类型的接口有 <code>游泳</code> <code>呱呱叫</code> <code>走路</code> 等方法，任何一个对象如果包含这些方法，我们可以认为它是鸭子。</p>
</blockquote>
<h2 id="go接口类型"><a href="#go接口类型" class="headerlink" title="go接口类型"></a>go接口类型</h2><br> 

<blockquote>
<p>在go语言中，可以定义接口类型，它描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。<br>有点抽象，可以这么理解：现在定义一个接口类型叫 <code>Animal</code>，其包含方法 <code>Breath</code>，那么所有包含 <code>Breath</code>方法的具体类型可视为一个<code>Animal</code>的实例。</p>
<p>接口类型还可以嵌套，例如，go自带io包里的接口 <code>io.Writer</code>、<code>io.Reader</code>、<code>io.ReadWriter</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Writer interface&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Write(p []byte) (n int, err error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">type Reader interface &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Read(p []byte) (n int, err error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">type ReadWriter interface &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Reader</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Writer</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><br> 

<blockquote>
<p>一个类型如果拥有一个接口的所有方法，那么这个类型就实现了这个接口。</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>go接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile</title>
    <url>/blog/2019/04/01/20190401023114.html</url>
    <content><![CDATA[<p>#逐步介绍 Dockerfile里的命令</p>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><code>ENV</code></h2><blockquote>
<p>格式： <code>ENV &lt;key&gt; &lt;val&gt;</code> 或 ENV <code>&lt;key&gt;=&lt;val&gt; ...</code></p>
<p><code>ENV</code>指令可以为镜像创建出来的容器声明环境变量，可被后边的指令解释使用，<br>使用格式为 <code>$variable_name</code>或<code>${variable_name}</code>。如果是带<code>$</code>的字符串，可使用<code>\</code>来转义。</p>
</blockquote>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><blockquote>
<p>格式： <code>FROM &lt;image&gt;</code> 或 <code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<p><code>FROM</code>指令为后边的指令提供基础镜像</p>
</blockquote>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><code>COPY</code></h2><blockquote>
<p>格式:  <code>COPY &lt;src&gt; &lt;dest&gt;</code></p>
<p><code>COPY</code>指令复制<code>&lt;src&gt;</code>所指向的文件或目录，将它添加到新镜像中，<code>src</code>所指向的源必须在上下文中。</p>
<p><code>context</code>上下文： 当构建镜像时，会执行 <code>docker build PATH|-|URL</code>命令，最后的<code>PATH|-|URL</code>即为上下文环境，在构建过程中，<br><code>docker</code>程序会将指定目录的所有文件(可用.dockerignore文件来忽略文件)复制到构建环境(实际是由docker-client提交到daemon去构建镜像)，这些文件作为构建镜像的上下文。</p>
<p>可同时拷贝多个文件，如 <code>COPY src1 src2 workdir/</code>，如果<code>src1</code>,<code>src2</code>是目录，则执行时会将<code>src1</code>,<code>src2</code>两个目录下的文件复制到 <code>workdir/</code>中去。</p>
</blockquote>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><code>ADD</code></h2><blockquote>
<p>格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code><br><code>ADD</code>与<code>COPY</code> 功能上很相似，都支持将本地文件复制到镜像中，但<code>ADD</code>还支持其他功能，<br><code>src</code>可以是一个指向网络文件的 URL，此时若<code>dest</code>指向目录，则URL必须是完全路径；还可以是本地压缩归档文件，该文件复制到容器时会被解压提取，但URL中的归档文件不会被解压。</p>
<p>推荐使用<code>COPY</code>，相比之下它更透明</p>
</blockquote>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><code>RUN</code></h2><blockquote>
<p>两种格式：</p>
<ol>
<li><code>RUN &lt;command&gt;</code> shell格式</li>
<li><code>RUN [&quot;exec&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> exec格式</li>
</ol>
</blockquote>
<blockquote>
<p>RUN命令会在前一条命令创建的镜像基础上创建一个容器，并在容器中运行命令，在命令结束后提交容器为新镜像，新镜像被Dockerfile中的下一条指令使用。</p>
<p>当使用shell格式，时，命令通过 <code>/bin/sh -c</code>运行，当使用exec格式时，命令是直接运行的，exec中参数会被当成json数组解析，因此必须使用双引号。因为其不在shell中执行，因此环境变量不会被替换。如果希望运行shell程序，可写成<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;progress&quot;]</code></p>
</blockquote>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><code>CMD</code></h2><blockquote>
<p>三种格式：</p>
<ol>
<li><code>CMD &lt;command&gt;</code> shell格式</li>
<li><code>CMD [&quot;exec&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> exec格式，推荐</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 为ENTRYPOINT指令提供参数</li>
</ol>
<p>可以有多条CMD命令，但只有一条会被执行。前两种执行方式一致，但执行时机不通：RUN 是在构建过程中执行命令并生成新镜像，CMD 在构建时不执行而是在容器启动时作为第一条命令执行。<br>使用第三种格式时，会将值作为参数传给ENTRYPOINT指令</p>
</blockquote>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a><code>ENTRYPOINT</code></h2><blockquote>
<p>两种格式：</p>
<ol>
<li><code>ENTRYPOINT &lt;command&gt;</code> shell格式</li>
<li><code>ENTRYPOINT [&quot;exec&quot;,&quot;param&quot;]</code> exec格式，推荐</li>
</ol>
<p><code>ENTRYPOINT</code>与<code>CMD</code>命令类似，都可以让容器在启动时执行相同的命令，但又有区别。<code>ENTRYPOINT</code>指令可以有多条，但只有最后一条有效，当使用shell格式时，<br>会忽略所有<code>CMD</code>指令和<code>docker run</code>参数，并运行在 <code>/bin/sh -c</code>中，这意味着该指令进程是 <code>/bin/sh -c</code>的子进程，在容器中的PID将不再是1，且不能接受UNIX信号，即使使用<code>docker stop</code>命令，也收不到SIGTERM信号。</p>
</blockquote>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a><code>ONBUILD</code></h2><blockquote>
<p>格式： <code>ONBUILD [INSTRUCTION]</code></p>
<p>添加一个将来执行的触发器指令到镜像中，当该镜像作为FROM指令的参数时，这些触发器指令就会在FROM指令执行时假如到构建过程中。</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s网络插件——flannel</title>
    <url>/blog/2019/01/10/20190110150506.html</url>
    <content><![CDATA[<h1 id="pod容器间通信"><a href="#pod容器间通信" class="headerlink" title="pod容器间通信"></a>pod容器间通信</h1><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>功能组件</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s网络</tag>
        <tag>flannel</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-ha 搭建</title>
    <url>/blog/2019/01/07/20190107123609.html</url>
    <content><![CDATA[<h1 id="机器准备"><a href="#机器准备" class="headerlink" title="机器准备"></a>机器准备</h1><blockquote>
<p>6台虚拟机<br>IP地址：</p>
<ol>
<li>10.1.1.10~12</li>
<li>10.1.1.20~22</li>
</ol>
<p>内核：4.4.169-1.el7.elrepo.x86_64（3.10以上能装docker都可）  </p>
</blockquote>
<h1 id="基本软件安装"><a href="#基本软件安装" class="headerlink" title="基本软件安装"></a>基本软件安装</h1><h2 id="keepalived安装"><a href="#keepalived安装" class="headerlink" title="keepalived安装"></a>keepalived安装</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="ssh实现集群机器间互相访问"><a href="#ssh实现集群机器间互相访问" class="headerlink" title="ssh实现集群机器间互相访问"></a>ssh实现集群机器间互相访问</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><blockquote>
<p>本文用的<code>docker</code>版本：19.03.0-ce<br>过程：略<br>安装成功后继续下一步</p>
</blockquote>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><blockquote>
<p>进入 <code>step2-conf</code> 目录下，执行 <code>basic_conf.sh</code>（脚本代码如下，加了注释）：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置docker开机启动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl restart docker</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl enable docker</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙并关闭开机启动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 永久关闭 selinux</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">setenforce 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed "s/^SELINUX=enforcing$/SELINUX=disabled/g" /etc/selinux/config</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭swap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">swapoff -a</span></pre></td></tr><tr><td class="code"><pre><span class="line">yes|cp /etc/fstab /etc/fstab.bak</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat /etc/fstab.bak |grep -v swap &gt; /etc/fstab</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo '''</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables = 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.swappiness=0''' &gt; /etc/sysctl.d/k8s.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span></pre></td></tr><tr><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 ipvs的依赖模块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe -- ip_vs</span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe -- ip_vs_rr</span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe -- ip_vs_wrr</span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe -- ip_vs_sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">modprobe -- nf_conntrack_ipv4</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装ipset 和ipvsadm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y ipset</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y ipvsadm</span></pre></td></tr></table></figure>

<h2 id="导入系统镜像"><a href="#导入系统镜像" class="headerlink" title="导入系统镜像"></a>导入系统镜像</h2><blockquote>
<p>k8s集群master需要镜像：kube-apiserver  kube-controller-manager   kube-scheduler kube-proxy pause，根据安装k8s版本选取对应版本的镜像<br>k8s 组件安装：<br>master节点组件： kubeadm、kubectl、kubelet、<br>node节点组件： kubelet</p>
<p>配置开机启动<code>kubelet</code> </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start kubelet</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl enable kubelet</span></pre></td></tr></table></figure>
<h2 id="安装外部etcd集群（不使用kubeadm自动生成的etcd）"><a href="#安装外部etcd集群（不使用kubeadm自动生成的etcd）" class="headerlink" title="安装外部etcd集群（不使用kubeadm自动生成的etcd）"></a>安装外部etcd集群（不使用kubeadm自动生成的etcd）</h2><h3 id="安装cfslsl工具"><a href="#安装cfslsl工具" class="headerlink" title="安装cfslsl工具"></a>安装cfslsl工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssl https:&#x2F;&#x2F;pkg.cfssl.org&#x2F;R1.2&#x2F;cfssl_linux-amd64</span></pre></td></tr><tr><td class="code"><pre><span class="line">wget -O &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssljson https:&#x2F;&#x2F;pkg.cfssl.org&#x2F;R1.2&#x2F;cfssljson_linux-amd64</span></pre></td></tr><tr><td class="code"><pre><span class="line">wget -O &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssl-certinfo  https:&#x2F;&#x2F;pkg.cfssl.org&#x2F;R1.2&#x2F;cfssl-certinfo_linux-amd64</span></pre></td></tr><tr><td class="code"><pre><span class="line">for cfssl in &#96;ls &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssl*&#96;;do chmod +x $cfssl;done;</span></pre></td></tr></table></figure>
<h3 id="生成etcd证书："><a href="#生成etcd证书：" class="headerlink" title="生成etcd证书："></a>生成etcd证书：</h3><blockquote>
<p>根据实际情况修改shell中的hosts</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gen-cert.sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p /opt/etcd/&#123;ssl,bin,cfg&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cd /opt/etcd/ssl</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ca config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &gt; ca-config.json &lt;&lt;EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  "signing": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "default": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      "expiry": "87600h"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "profiles": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      "www": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         "expiry": "87600h",</span></pre></td></tr><tr><td class="code"><pre><span class="line">         "usages": [</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "signing",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "key encipherment",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "server auth",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "client auth"</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ca csr config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &gt; ca-csr.json &lt;&lt;EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "CN": "etcd CA",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "key": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "algo": "rsa",</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "size": 2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "names": [</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "C": "CN",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "L": "SZ",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "ST": "SZ"</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gen</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据实际情况修改hosts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &gt; server-csr.json &lt;&lt;EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "CN": "etcd",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "hosts": [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      "10.1.1.10",</span></pre></td></tr><tr><td class="code"><pre><span class="line">      "10.1.1.20",</span></pre></td></tr><tr><td class="code"><pre><span class="line">      "10.1.1.21"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "key": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "algo": "rsa",</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "size": 2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "names": [</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "C": "CN",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "L": "SZ",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "ST": "SZ"</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ca.csr            <span class="comment">#ca证书签名请求</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ca.pem            <span class="comment">#ca证书（公钥）</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ca-key.pem      <span class="comment">#ca私钥</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> server.csr        <span class="comment">#server证书签名请求</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> server.pem        <span class="comment">#server证书（公钥）</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> server-key.pem    <span class="comment">#server私钥</span></span></span></pre></td></tr></table></figure>

<h3 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h3><h4 id="节点1："><a href="#节点1：" class="headerlink" title="节点1："></a>节点1：</h4><blockquote>
<p>从github上下载etcd的release版本，解压后进入目录，将etcd二进制文件复制到 /opt/etcd/bin 目录下</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cp bin/etcd bin/etcdctl /opt/etcd/bin</span></pre></td></tr></table></figure>
<blockquote>
<p>安装脚本 install-etcd.sh：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> example: ./etcd.sh etcd01 IP1 etcd02=https://IP2:2380,etcd03=https://IP3:2380</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_NAME=$1</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_IP=$2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_CLUSTER=$3</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">WORK_DIR=/opt/etcd</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建etcd配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;$WORK_DIR/cfg/etcd</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">[Member]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_NAME="$&#123;ETCD_NAME&#125;"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_DATA_DIR="/var/lib/etcd/default.etcd" # </span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_LISTEN_PEER_URLS="https://$&#123;ETCD_IP&#125;:2380"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_LISTEN_CLIENT_URLS="https://$&#123;ETCD_IP&#125;:2379"</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">[Clustering]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS="https://$&#123;ETCD_IP&#125;:2380"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_ADVERTISE_CLIENT_URLS="https://$&#123;ETCD_IP&#125;:2379"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_INITIAL_CLUSTER="etcd01=https://$&#123;ETCD_IP&#125;:2380,$&#123;ETCD_CLUSTER&#125;"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"</span></pre></td></tr><tr><td class="code"><pre><span class="line">ETCD_INITIAL_CLUSTER_STATE="new"</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建systemctl服务管理etcd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/usr/lib/systemd/system/etcd.service</span></pre></td></tr><tr><td class="code"><pre><span class="line">[Unit]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Description=Etcd Server</span></pre></td></tr><tr><td class="code"><pre><span class="line">After=network.target</span></pre></td></tr><tr><td class="code"><pre><span class="line">After=network-online.target</span></pre></td></tr><tr><td class="code"><pre><span class="line">Wants=network-online.target</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[Service]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Type=notify</span></pre></td></tr><tr><td class="code"><pre><span class="line">EnvironmentFile=$&#123;WORK_DIR&#125;/cfg/etcd</span></pre></td></tr><tr><td class="code"><pre><span class="line">ExecStart=$&#123;WORK_DIR&#125;/bin/etcd \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--name=\$&#123;ETCD_NAME&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--data-dir=\$&#123;ETCD_DATA_DIR&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--listen-peer-urls=\$&#123;ETCD_LISTEN_PEER_URLS&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--listen-client-urls=\$&#123;ETCD_LISTEN_CLIENT_URLS&#125;,http://127.0.0.1:2379 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--advertise-client-urls=\$&#123;ETCD_ADVERTISE_CLIENT_URLS&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--initial-advertise-peer-urls=\$&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--initial-cluster=\$&#123;ETCD_INITIAL_CLUSTER&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--initial-cluster-token=\$&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--initial-cluster-state=new \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--cert-file=$&#123;WORK_DIR&#125;/ssl/server.pem \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--key-file=$&#123;WORK_DIR&#125;/ssl/server-key.pem \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--peer-cert-file=$&#123;WORK_DIR&#125;/ssl/server.pem \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--peer-key-file=$&#123;WORK_DIR&#125;/ssl/server-key.pem \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--trusted-ca-file=$&#123;WORK_DIR&#125;/ssl/ca.pem \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--peer-trusted-ca-file=$&#123;WORK_DIR&#125;/ssl/ca.pem</span></pre></td></tr><tr><td class="code"><pre><span class="line">Restart=on-failure</span></pre></td></tr><tr><td class="code"><pre><span class="line">LimitNOFILE=65536</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[Install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">WantedBy=multi-user.target</span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl enable etcd</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl restart etcd</span></pre></td></tr></table></figure>
<blockquote>
<p>此处我使用的IP是 10.1.1.10-12 ，所以执行命令就是 <code>./install-etcd.sh etcd01 10.1.1.10 etcd02=https://10.1.1.11:2380,etcd03=10.1.1.12:2380</code></p>
</blockquote>
<h4 id="节点2、3"><a href="#节点2、3" class="headerlink" title="节点2、3"></a>节点2、3</h4><blockquote>
<p>将etcd执行文件及配置复制到其他两个节点：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /opt/etcd/  root@10.1.1.11:/opt/etcd/</span></pre></td></tr><tr><td class="code"><pre><span class="line">scp -r /opt/etcd/  root@10.1.1.12:/opt/etcd/</span></pre></td></tr><tr><td class="code"><pre><span class="line">scp /usr/lib/systemd/system/etcd.service root@10.1.1.11:/usr/lib/systemd/system/</span></pre></td></tr><tr><td class="code"><pre><span class="line">scp /usr/lib/systemd/system/etcd.service root@10.1.1.12:/usr/lib/systemd/system/</span></pre></td></tr></table></figure>
<blockquote>
<p>修改配置：</p>
<ol>
<li>修改/opt/etcd/cfg/etcd 配置文件，MEMBER配置块内容改为该节点自身的配置</li>
<li>Clustering配置块中，ETCD_INITIAL_ADVERTISE_PEER_URLS  ETCD_ADVERTISE_CLIENT_URLS 的IP改成当前机器的IP</li>
</ol>
</blockquote>
<h4 id="节点状态查看"><a href="#节点状态查看" class="headerlink" title="节点状态查看"></a>节点状态查看</h4><blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=https://10.1.1.10:2379 member list</span></pre></td></tr></table></figure>
<blockquote>
<p>结果显示：<br>66a8527f13b8fecc, started, etcd03, <a href="https://10.1.1.12:2380" target="_blank" rel="noopener">https://10.1.1.12:2380</a>, <a href="https://10.1.1.12:2379" target="_blank" rel="noopener">https://10.1.1.12:2379</a><br>a6a292fe93a0085d, started, etcd01, <a href="https://10.1.1.10:2380" target="_blank" rel="noopener">https://10.1.1.10:2380</a>, <a href="https://10.1.1.10:2379" target="_blank" rel="noopener">https://10.1.1.10:2379</a><br>da873601634f4a11, started, etcd02, <a href="https://10.1.1.11:2380" target="_blank" rel="noopener">https://10.1.1.11:2380</a>, <a href="https://10.1.1.11:2379" target="_blank" rel="noopener">https://10.1.1.11:2379</a></p>
</blockquote>
<h2 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h2><blockquote>
<p>进入 /etc/kubernetes 目录，<code>vim kubeadm-config.yaml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">controlPlaneEndpoint:</span> <span class="string">"10.1.1.10:6443"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">apiServer:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">certSANs:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="string">k8s.local</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">etcd:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">external:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">endpoints:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.10:2379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.11:2379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">https://10.1.1.12:2379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">caFile:</span> <span class="string">/opt/etcd/ssl/ca.pem</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">certFile:</span> <span class="string">/opt/etcd/ssl/server.pem</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">keyFile:</span> <span class="string">/opt/etcd/ssl/server-key.pem</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">mode:</span> <span class="string">ipvs</span></span></pre></td></tr></table></figure>
<blockquote>
<p>执行初始化命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --config /etc/kubernetes/kubeadm-config.yaml --upload-certs</span></pre></td></tr></table></figure>
<blockquote>
<p>命令执行完会生成两个带token 的join命令</p>
<ol>
<li>kubeadm join xxxx –control-plane xxxx</li>
<li>kubeadm join xxxx<br>分别用于master节点、node节点加入集群。当加入master节点时如果报证书错误，把执行init节点的 /etc/kubernetes/pki 文件夹复制到待加入的master节点。</li>
</ol>
</blockquote>
<h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><h2 id="初始化集群失败后，清理etcd数据："><a href="#初始化集群失败后，清理etcd数据：" class="headerlink" title="初始化集群失败后，清理etcd数据："></a>初始化集群失败后，清理etcd数据：</h2><blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=https://10.1.1.10:2379  del /  --prefix</span></pre></td></tr></table></figure>


<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>[1]. <a href="https://www.cnblogs.com/LouisZJ/articles/11178153.html" target="_blank" rel="noopener">etcd集群安装</a></p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s高可用搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine(1)</title>
    <url>/blog/2019/01/06/20190106083354.html</url>
    <content><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote>
<p>介绍协程之前，首先回顾一下进程与线程</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote>
<p><red>进程</red>： 通俗点讲，进程就是一个程序运行的实例，进程拥有自己运行时打开的各种资源和独立的内存空间。每个进程通过PCB（process control block）来保存自己的基本信息（在Linux中，该结构叫task_struct）<br>PCB包含了进程运行的基本信息：标示符、状态、优先级、程序计数器、内存指针、上下文、IO信息、记账信息等  </p>
<p><red>线程</red>： 线程属于进程，是程序的实际执行者，一个程序可以包含多个线程，线程具有自己的栈空间，其基本信息存储在TCB（thread control block）  </p>
<p>对OS来说，进程是最小的资源管理单元，线程是最小的执行单元</p>
<p>线程切换比进程切换更加轻量：线程进程切换时，都会调用内核切换上下文，不同进程之间内存空间相互独立，而不同线程之间共享进程的内存空间，因此线程上下文切换效率更高</p>
<p>进程和线程的切换都是抢占式的，由OS管理</p>
</blockquote>
<h2 id="go语言协程"><a href="#go语言协程" class="headerlink" title="go语言协程"></a>go语言协程</h2><blockquote>
<p>协程,是一种比线程更轻量级的运行单元。<br>主要特点：</p>
<ol>
<li>轻量级“线程”</li>
<li>非抢占式多任务处理，由协程调度器来调度任务也可主动交出控制权</li>
<li>编译器、解释器、虚拟机层面的多任务</li>
<li>多个协程可以在一个或多个线程上运行</li>
</ol>
</blockquote>
<h3 id="非抢占式测试"><a href="#非抢占式测试" class="headerlink" title="非抢占式测试"></a>非抢占式测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"testing"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"time"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 结束时间大于2秒，因为是非抢占式，main的协程无法及时得到执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印属于IO操作，执行打印时会释放CPU资源给其他协程使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_01</span><span class="params">(t *testing.T)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				fmt.Println(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 该程序不会退出，执行到最后一行打印之前，启动了4个协程，这些协程均不会释放CPU资源，没有空闲的线程用于主协程执行，因此不会退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 当启动的协程数 &lt; runtime.NumCPU() ，可以正常退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_02</span><span class="params">(t *testing.T)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// N值要大于等于机器支持线程数（大于等于runtime.NumCPU()）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 测试机为2核4线程，这里设置成4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> N = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> a [N]<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				a[x]++</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 此处休眠1秒是为了让前边循环中的协程都启动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	time.Sleep(time.Second)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 主动交出控制权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_03</span><span class="params">(t *testing.T)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> N = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> a [N]<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				a[x]++</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">// 主动交出控制权</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				runtime.Gosched()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	time.Sleep(time.Second)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>任何函数只要加上<code>go</code>就可以交给调度器执行</li>
<li>调度器会在指定的点进行切换<br> 可能切换点：（可能切换）<ol>
<li>IO,select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用(当协程运行过长时会打标记，在函数调用时检测标记并根据标记决定是否调度)</li>
<li>runtime.Gosched()</li>
<li>系统调用</li>
</ol>
</li>
<li>可以通过使用 <code>-race</code>参数来进行数据多线程的读写竞争进行检测 </li>
</ol>
</blockquote>
<h1 id="go语言协程模型"><a href="#go语言协程模型" class="headerlink" title="go语言协程模型"></a>go语言协程模型</h1><!--[图片来源](https://stackoverflow.com/questions/48638663/what-is-relationship-between-goroutine-and-thread-in-kernel-and-user-state)
-->
<h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><blockquote>
<p>如下图，go语言协程的模型<br><img src="/resources/post_pic/2019/01/goroutine_model.jpg" alt="go协程模型" title="go协程模型"></p>
</blockquote>
<blockquote>
<ol>
<li>M：系统线程（内核线程）</li>
<li>P：执行Go协程所必须的资源（上下文环境，逻辑处理器）</li>
<li>G：Go协程  </li>
</ol>
<p>可以把<code>Go协程</code>视为“用户线程”，它由用户态的Go调度器来实现在P上的调度，由于P中的协程队列同处于一个上下文环境（在同一个线程）没有内核切换的开销。调度器通过将Go协程映射到内核线程中，使程序运行时“看起来”是在并发执行。</p>
<p>由于Go协程是非抢占式的，而且基本在指定的几种情况下才会释放CPU，所以在协程之间切换时程序上下文复制开销较小且不用进行内核调用，因此更轻量级。</p>
</blockquote>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><blockquote>
<p>在并发执行程序时，调度器除了正常从协程队列里取出协程放到自己的执行队里中外，还有其他的执行调度行为：</p>
<ol>
<li>Work-sharing：当处理器生成新线程时，它会尝试着将一些工作任务交给其他闲置的线程执行，充分利用资源</li>
<li>Work-stealing：调度器主动“偷取”其他线程上执行任务来执行</li>
</ol>
</blockquote>
<blockquote>
<p>在Go语言中有一个<code>global goroutine queue</code>，每个内核线程又有一个<code>local goroutine queue</code>，<br>对于每一个内核线程来说，在该线程上等待执行的协程是串行的，而对于外部来说，这些协程是并发的。</p>
<p>协程之于内核线程，有点像进程之于CPU（单核CPU上对于CPU来说进程是串行的，对于外部来说是并行的）</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>go协程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>列表(list)——可快速增删的非连续空间的容器</title>
    <url>/blog/2018/12/23/20181223104815.html</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element is an element of a linked list.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// To simplify the implementation, internally a list l is implemented</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// list element (l.Back()) and the previous element of the first list</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// element (l.Front()).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	next, prev *Element</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// The list to which this element belongs.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	list *List</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// The value stored with this element.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// List represents a doubly linked list.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>Element</code>，封装保存在<code>list</code>中的值，  <ol>
<li><code>Element</code>中的变量<code>next</code>,<code>prev</code>是指针，分别指向当前元素的下一个元素与前一个元素  </li>
<li><code>Element</code>中的变量<code>list</code>是指针，指向该<code>Element</code>所属的<code>list</code></li>
<li><code>Value</code>存储的为<code>List</code>中存放的值</li>
</ol>
</li>
<li><code>List</code>，<code>list</code>本身<ol>
<li><code>List</code>中的变量<code>root</code>变量存储着<code>List</code>中的第一个元素，该元素<code>Value</code>为<code>nil</code>，只做为根，不存储数据</li>
<li><code>List</code>中的变量<code>len</code>变量表示<code>List</code>的长度</li>
</ol>
</li>
<li>本质就是数据结构中的双向循环链表</li>
</ol>
</blockquote>
<h1 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h1><h2 id="Remove-e-Element"><a href="#Remove-e-Element" class="headerlink" title="Remove(e *Element)"></a><code>Remove(e *Element)</code></h2><blockquote>
<p>移除元素</p>
</blockquote>
<h2 id="PushFront-v-interface"><a href="#PushFront-v-interface" class="headerlink" title="PushFront(v interface{})"></a><code>PushFront(v interface{})</code></h2><blockquote>
<p>在列表头部增加元素</p>
</blockquote>
<h2 id="PushBack-v-interface"><a href="#PushBack-v-interface" class="headerlink" title="PushBack(v interface{})"></a><code>PushBack(v interface{})</code></h2><blockquote>
<p>在列表尾部增加元素</p>
</blockquote>
<h2 id="InsertBefore-v-interface-mark-Element-Element"><a href="#InsertBefore-v-interface-mark-Element-Element" class="headerlink" title="InsertBefore(v interface{},mark *Element)*Element"></a><code>InsertBefore(v interface{},mark *Element)*Element</code></h2><blockquote>
<p>在<code>mark</code>前增加元素</p>
</blockquote>
<h2 id="InsertAfter-v-interface-mark-Element-Element"><a href="#InsertAfter-v-interface-mark-Element-Element" class="headerlink" title="InsertAfter(v interface{},mark *Element)*Element"></a><code>InsertAfter(v interface{},mark *Element)*Element</code></h2><blockquote>
<p>在<code>mark</code>后增加元素</p>
</blockquote>
<h2 id="MoveToFront-e-Element"><a href="#MoveToFront-e-Element" class="headerlink" title="MoveToFront(e *Element)"></a><code>MoveToFront(e *Element)</code></h2><blockquote>
<p>将元素移至列表头部</p>
</blockquote>
<h2 id="MoveToBack-e-Element"><a href="#MoveToBack-e-Element" class="headerlink" title="MoveToBack(e *Element)"></a><code>MoveToBack(e *Element)</code></h2><blockquote>
<p>将元素移至列表尾部</p>
</blockquote>
<h2 id="MoveBefore-e-mark-Element"><a href="#MoveBefore-e-mark-Element" class="headerlink" title="MoveBefore(e mark *Element)"></a><code>MoveBefore(e mark *Element)</code></h2><blockquote>
<p>将元素<code>e</code>移至<code>mark</code>前边</p>
</blockquote>
<h2 id="MoveAfter-e-mark-Element"><a href="#MoveAfter-e-mark-Element" class="headerlink" title="MoveAfter(e mark *Element)"></a><code>MoveAfter(e mark *Element)</code></h2><blockquote>
<p>将元素<code>e</code>移至<code>mark</code>后边</p>
</blockquote>
<h2 id="PushBackList-other-List"><a href="#PushBackList-other-List" class="headerlink" title="PushBackList(other *List)"></a><code>PushBackList(other *List)</code></h2><blockquote>
<p>将列表<code>other</code>放入当前列表尾部</p>
</blockquote>
<h2 id="PushFrontList-other-List"><a href="#PushFrontList-other-List" class="headerlink" title="PushFrontList(other *List)"></a><code>PushFrontList(other *List)</code></h2><blockquote>
<p>将列表<code>other</code>放至当前列表头部</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sync.Map 底层实现分析</title>
    <url>/blog/2018/12/17/20181217141509.html</url>
    <content><![CDATA[<h1 id="sync-Map的数据结构"><a href="#sync-Map的数据结构" class="headerlink" title="sync.Map的数据结构"></a>sync.Map的数据结构</h1><blockquote>
<p>首先看一下<code>sync.Map</code>的底层数据结构</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 互斥锁，锁定 dirty</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mu Mutex                        </span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 优先读</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	read atomic.Value               </span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 保存最新map</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry   </span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 记录从read中读取不到数据次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 当misses&gt;=len(dirty)时，会将dirty作为read,然后dirty=nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// (源码中 missLocked函数)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	misses <span class="keyword">int</span>                      </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 主要用于存储</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果数据在dirty中但没有在read中，该值为true,作为修改标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    amended <span class="keyword">bool</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// nil: 表示为被删除，调用Delete()可以将read map中的元素置为nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// expunged: 也是表示被删除，但是该键只在read而没有在dirty中，这种情况出现在将read复制到dirty中，即复制的过程会先将nil标记为expunged，然后不将其复制到dirty</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//  其他: 表示存着真正的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>mu</code> 用于数据存取数据加锁</li>
<li><code>read</code> </li>
<li><code>dirty</code></li>
<li><code>misses</code></li>
</ol>
</blockquote>
<h1 id="sync-Map的操作"><a href="#sync-Map的操作" class="headerlink" title="sync.Map的操作"></a>sync.Map的操作</h1><h2 id="存数据，Store-key-val"><a href="#存数据，Store-key-val" class="headerlink" title="存数据，Store(key,val)"></a>存数据，<code>Store(key,val)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store sets the value for a key.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	read, _ := m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	read, _ = m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// The entry was previously expunged, which implies that there is a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// non-nil dirty map and this entry is not in it.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			m.dirty[key] = e</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		e.storeLocked(&amp;value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		e.storeLocked(&amp;value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// We're adding the first new key to the dirty map.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			m.dirtyLocked()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		m.dirty[key] = newEntry(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	m.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>首先判断是否在<code>map.read</code>中，如果在，则调用<code>entry</code>的<code>tryStore</code>方法，<code>tryStore</code>方法使用了<code>atomic.CompareAndSwapPointer</code>操作，保证了操作原子性。如果成功，则直接返回<sup>①</sup>。当该<code>key</code>值已删去时<code>tryStore</code>方法返回<code>false</code>继续执行<sup>②</sup></li>
<li>加锁，重新获取<code>map.read</code>值保证锁定操作期间数据最新且不会发生变化。</li>
<li>如果<code>key</code>存在于<code>map.read</code>中：<ol>
<li>如果<code>read</code>中数据被删除<sup>③</sup>，则将<code>k-v</code>放到<code>dirty</code>中(<code>dirty</code>中没有该<code>key</code>)</li>
<li>如果<code>read</code>中数据未被删除<sup>④</sup>不处理</li>
<li>将<code>v</code>放到<code>read</code>中</li>
</ol>
</li>
<li>如果<code>key</code>不存在于<code>map.read</code>中，存在于<code>dirty</code>中<sup>⑤</sup>，更新<code>dirty</code>中的值</li>
<li>如果<code>key</code>既不存在于<code>map.read</code>中，也不存在于<code>map.dirty</code>中：<ol>
<li><code>read</code>与<code>dirty</code>中<code>key</code>一致（<code>amended</code>为<code>false</code>）<sup>⑥</sup>，初始化<code>read</code>，并标记<code>amended</code>参数为<code>true</code>，将数据存到<code>dirty</code>中</li>
<li>否则不做处理 <sup>⑦</sup></li>
<li>将数据存入<code>dirty</code>中</li>
</ol>
</li>
<li>解锁返回</li>
</ol>
</blockquote>
<h2 id="删除数据-Delete-key"><a href="#删除数据-Delete-key" class="headerlink" title="删除数据 Delete(key)"></a>删除数据 <code>Delete(key)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	read, _ := m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	e, ok := read.m[key]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		m.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		read, _ = m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		e, ok = read.m[key]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		m.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		e.<span class="built_in">delete</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>判断如果待删除的<code>key</code>不在<code>map.read</code>中且<code>map.dirty</code>中含有<code>map.read</code>中不存在的<code>key</code>，则：<ol>
<li>锁定，重新判断<code>map.read</code>中是否有<code>key</code>，如果同上，则调用从<code>map.dirty</code>中删除的函数，然后解锁</li>
</ol>
</li>
<li>否则，若<code>key</code>存在于<code>map.read</code>中，则调用<code>entry</code>中的<code>delete</code>（<code>entry</code>里只有一个参数，应该是<code>val</code>的指针）</li>
</ol>
</blockquote>
<h2 id="访问map数据-Load-key"><a href="#访问map数据-Load-key" class="headerlink" title="访问map数据 Load(key)"></a>访问map数据 <code>Load(key)</code></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load returns the value stored in the map for a key, or nil if no</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// value is present.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// The ok result indicates whether value was found in the map.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	read, _ := m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	e, ok := read.m[key]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		m.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it's</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// not worth copying the dirty map for this key.)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		read, _ = m.read.Load().(readOnly)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		e, ok = read.m[key]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			e, ok = m.dirty[key]</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// map.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			m.missLocked()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		m.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> !ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> e.load()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>判断如果待访问的<code>key</code>不在<code>map.read</code>中且<code>map.dirty</code>中含有<code>map.read</code>中不存在的<code>key</code>，则<ol>
<li>对<code>map</code>加锁，再次判断为真，则调用<code>map.missLocked()</code>，（通过判断在<code>map.read</code>中miss的次数来决定是否将<code>map.dirty</code>替换掉<code>map.read</code>）</li>
<li>解锁</li>
</ol>
</li>
<li>判断前边是否获得到<code>val</code>值，未获取到，则返回 <code>nil,false</code></li>
<li>若前边取到<code>val</code>，则返回</li>
</ol>
</blockquote>
<h2 id="LoadOrStore-key-val"><a href="#LoadOrStore-key-val" class="headerlink" title="LoadOrStore(key,val)"></a>LoadOrStore(key,val)</h2><blockquote>
<ol>
<li>如果<code>map</code>中存在<code>key</code>，则返回对应的<code>val</code></li>
<li>否则，保存参数中的<code>key,val</code>，并返回参数中的<code>val</code></li>
</ol>
</blockquote>
<h2 id="遍历Map-range"><a href="#遍历Map-range" class="headerlink" title="遍历Map: range"></a>遍历Map: range</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"sync"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m := sync.Map&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	m.Store(<span class="string">"k1"</span>, <span class="string">"v1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	m.Store(<span class="string">"k2"</span>, <span class="string">"v2"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(k, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="map-read与map-dirty中数据一致性："><a href="#map-read与map-dirty中数据一致性：" class="headerlink" title="map.read与map.dirty中数据一致性："></a><code>map.read</code>与<code>map.dirty</code>中数据一致性：</h2><blockquote>
<ol>
<li><code>map.dirty</code>包含<code>map.read</code>中没有的<code>key</code>，<code>map.read.amended</code>为<code>false</code>，表明两者底层<code>val</code>引用是一致的，此时对数据的 更新、删除（此时删除操作实际是将底层<code>val</code>的指针置位<code>nil</code>，相当于只删除了<code>val</code>未删除<code>key</code>） 做<code>cas</code>操作即可</li>
<li>否则，<code>map.read.amended</code>为<code>true</code>，此时操作数据要考虑<code>map.read</code>与<code>map.dirty</code>中数据一致性<ol>
<li><code>load</code>数据时，在<code>map.read</code>中访问不到次数大于等于<code>map.dirty</code>长度时，会用<code>map.dirty</code>替换<code>map.read</code>，并将<code>map.dirty</code>置为<code>nil</code>，此时<code>map.read.amended</code>为<code>false</code>（因为<code>map.dirty</code>中不包含<code>map.read</code>中不存在的<code>key</code>）</li>
<li><code>store</code>数据时，当<code>map.dirty</code>数据为空时，会将<code>map.read</code>中的<code>key</code>的<code>val</code>引用复制过来（此时会判断是否标记未删除，标记删除则不复制，删除了<code>val</code>的<code>key</code>也删除掉），再在<code>map.dirty</code>中增加<code>k-v</code>，此时<code>map.read.amended</code>为<code>true</code></li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>map基础</title>
    <url>/blog/2018/12/16/20181216153850.html</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map实现方式"><a href="#map实现方式" class="headerlink" title="map实现方式"></a><code>map</code>实现方式</h2><blockquote>
<p>go语言中<code>map</code>使用<code>hash</code>（散列表）实现</p>
</blockquote>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个 map 变量，其值为nil，(m1==nil)为true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空map （可在&#123;&#125;中填写map中的元素）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空map</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span></pre></td></tr></table></figure>
<h2 id="map的key类型限制"><a href="#map的key类型限制" class="headerlink" title="map的key类型限制"></a><code>map</code>的<code>key</code>类型限制</h2><blockquote>
<p><code>map</code>使用<code>hash表</code>存储实现，<code>key</code>类型必须可比较相等。<br><code>map</code>的<code>key</code>类型必须不为<code>function</code>,<code>slice</code>,<code>map</code>，在定义时，如果使用这些类型会报错。<br><code>struct类型</code>也可作为<code>key</code>类型，但如果使用带有这些类型属性的<code>struct</code>不可以作为<code>key</code>。可能编译不会报错，但运行时会报错。</p>
<p><img src="/resources/post_pic/2018/12/keyOfMapCantBeTheseTypes.png" alt="map使用错误的key类型报错" title="map使用错误的key类型报错"></p>
</blockquote>
<h2 id="Map操作"><a href="#Map操作" class="headerlink" title="Map操作"></a><code>Map</code>操作</h2><h3 id="map长度"><a href="#map长度" class="headerlink" title="map长度"></a><code>map</code>长度</h3><blockquote>
<p>获取长度方法：<code>len(map)</code></p>
</blockquote>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">3</span>: <span class="number">6</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">5</span>: <span class="literal">nil</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 直接访问不存在的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m4v := m[<span class="number">4</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(m4v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 使用ok参数接收是否取得正确的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m4v, ok := m[<span class="number">4</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(m4v, ok)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 使用ok参数接收是否取得正确的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m5v, ok := m[<span class="number">5</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(m5v, ok)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;nil&gt; false</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;nil&gt; true</span></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote>
<ol>
<li>不使用<code>ok</code>参数接收是否取得值时，如果不存在<code>key</code>值对应的<code>val</code>，则返回对应类型的空：<code>int</code>返回<code>0</code>，<code>string</code>返回<code>&quot;&quot;</code>，引用类型返回<code>nil</code>等。</li>
<li>使用<code>ok</code>参数可以通过判断<code>ok</code>知道<code>map</code>中是否存在<code>key</code></li>
<li>不使用<code>ok</code>时可能存在的问题，如上代码，<code>m[4]</code>不存在于<code>map</code>中，取得结果为<code>nil</code>，<code>m[5]</code>存在于<code>map</code>中，其本身对应的值为<code>nil</code>所以取得结果也为<code>nil</code>，这种情况下可能会存在问题</li>
</ol>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">3</span>: <span class="number">6</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(k, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><blockquote>
<p>每次运行程序输出顺序可能不一致，<code>map</code>不能保证遍历的顺序性</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><blockquote>
<p>删除方法 <code>delete</code></p>
</blockquote>
<h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">0</span>: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">1</span>: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="number">2</span>: <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">delete</span>(m, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_, ok := m[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(ok)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 测试删除不存在的元素，不会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">delete</span>(m,<span class="number">5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><blockquote>
<p>输出：false</p>
</blockquote>
<h1 id="安全map——sync-Map"><a href="#安全map——sync-Map" class="headerlink" title="安全map——sync.Map"></a>安全map——sync.Map</h1><blockquote>
<p>普通<code>map</code>类型在只读的情况下是线程安全的，但同时读写时非线程安全。</p>
</blockquote>
<h2 id="普通线程安全性"><a href="#普通线程安全性" class="headerlink" title="普通线程安全性"></a>普通线程安全性</h2><h3 id="普通map线程安全测试"><a href="#普通map线程安全测试" class="headerlink" title="普通map线程安全测试"></a>普通<code>map</code>线程安全测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 无限向map写数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			m[<span class="number">1</span>] = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 无限从map读数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			_ = m[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 让主线程不退出，并发程序后台执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_ = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="测试结果-报错"><a href="#测试结果-报错" class="headerlink" title="测试结果:报错"></a>测试结果:报错</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span></pre></td></tr></table></figure>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><blockquote>
<p>方法：<code>Store(key,val)</code>；<code>LoadOrStore(key,val)</code></p>
<ol>
<li><code>Store(key,val)</code>方法，将<code>key:val</code>对存入<code>map</code>中；</li>
<li><code>LoadOrStore(key,val)</code>方法，返回值有两个 <code>(val,ok)</code>，<code>val</code>表示在<code>map</code>中<code>key</code>对应的值（如果已存在，则为原<code>map</code>中的值，如果不存在，则先将<code>key:val</code>对存入<code>map</code>，再返回<code>val</code>）；<code>ok</code>表示<code>map</code>中是否已存在<code>key</code>值及其对应的<code>val</code>。</li>
</ol>
</blockquote>
<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><blockquote>
<p>方法： <code>Delete(key)</code></p>
<p>删除<code>map</code>中<code>key</code>及其对应的<code>val</code></p>
</blockquote>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><blockquote>
<p>方法： <code>Load(key)</code>；<code>LoadOrStore(key,val)</code></p>
<ol>
<li>直接调用<code>Load</code>方法，返回值有两个<code>(val,ok)</code>，值以及是否存在</li>
<li><code>LoadOrStore</code>方法在添加元素部分已解释</li>
</ol>
</blockquote>
<h4 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h4><blockquote>
<p>方法： <code>Range(f func(key, value interface{}) bool)</code></p>
<p>参数是一个函数，在函数中执行遍历操作</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go-slice操作</title>
    <url>/blog/2018/12/16/20181216012715.html</url>
    <content><![CDATA[<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><h2 id="方法：append-slice-elems"><a href="#方法：append-slice-elems" class="headerlink" title="方法：append(slice,elems...)"></a>方法：<code>append(slice,elems...)</code></h2><blockquote>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 未触发扩容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s := arr[<span class="number">0</span>:<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	news := <span class="built_in">append</span>(s, <span class="number">100</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"news ptr : %p\ts ptr : %p\n"</span>,news,s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"s\t"</span>,s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"news\t"</span>,news)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"arr\t"</span>,arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"===================="</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 触发扩容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr = []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s = arr[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	news = <span class="built_in">append</span>(s,<span class="number">100</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"news ptr : %p\ts ptr : %p\n"</span>,news,s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"s\t"</span>,s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"news\t"</span>,news)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"arr\t"</span>,arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">news ptr : 0xc00007a0a0	s ptr : 0xc00007a0a0</span></pre></td></tr><tr><td class="code"><pre><span class="line">s	 [0 1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">news 	 [0 1 100]</span></pre></td></tr><tr><td class="code"><pre><span class="line">arr	 [0 1 100 3 4 5 6 7 8 9]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">news ptr : 0xc000072030	s ptr : 0xc00004a0e0</span></pre></td></tr><tr><td class="code"><pre><span class="line">s	 [0 1 2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">news 	 [0 1 2 100]</span></pre></td></tr><tr><td class="code"><pre><span class="line">arr	 [0 1 2]</span></pre></td></tr></table></figure>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li><code>append</code>方法会创建一个新<code>slice</code>，原<code>slice</code>不变。</li>
<li>调用<code>append</code>方法如果未触发扩容，则底层array对应位置会做出相应改变</li>
<li>调用<code>append</code>方法如果触发扩容，则原底层array对应位置不发生变化，因为新的<code>slice</code>底层array也已变化  </li>
</ol>
</blockquote>
<h1 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h1><h2 id="方法：copy-dst-type-src-type"><a href="#方法：copy-dst-type-src-type" class="headerlink" title="方法：copy(dst []type,src []type)"></a>方法：<code>copy(dst []type,src []type)</code></h2><blockquote>
</blockquote>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// len(src) &gt; len(dst)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"before\tdst :"</span>,s1,<span class="string">"src :"</span>,s2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">copy</span>(s1,s2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"after\tdst :"</span>,s1,<span class="string">"src :"</span>,s2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"====================="</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// len(src) &lt; len(dst)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s1 = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"before\tdst :"</span>,s2,<span class="string">"src :"</span>,s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">copy</span>(s2,s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"after\tdst :"</span>,s2,<span class="string">"src :"</span>,s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="测试结果：-1"><a href="#测试结果：-1" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before	dst : [0] src : [1 2 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">after	dst : [1] src : [1 2 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">before	dst : [1 2 3] src : [0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">after	dst : [0 2 3] src : [0]</span></pre></td></tr></table></figure>
<h2 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li>将<code>src</code>数据拷贝到<code>dst</code>中</li>
<li>如果<code>src</code>长度大于<code>dst</code>长度，则只会复制<code>len(dst)</code>个数据到<code>dst</code>中</li>
<li>如果<code>src</code>长度小于<code>dst</code>长度，则<code>dst</code>的前<code>len(src)</code>个数据会被<code>src</code>的数据覆盖，后边不变</li>
</ol>
</blockquote>
<h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><blockquote>
<p>无默认删除操作，可通过<code>append</code>实现</p>
</blockquote>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"before del s1's ptr :\t%p\n"</span>,s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"============="</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// do delete</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s1 = <span class="built_in">append</span>(s1[:<span class="number">2</span>],s1[<span class="number">3</span>:]...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"after del s1's ptr :\t%p\n"</span>,s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(s1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="测试结果：-2"><a href="#测试结果：-2" class="headerlink" title="测试结果："></a>测试结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before del s1&#39;s ptr :	0xc000072030</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 1 2 3 4 5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">after del s1&#39;s ptr :	0xc000072030</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 1 3 4 5]</span></pre></td></tr></table></figure>
<h2 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<ol>
<li>删除元素<code>slice</code>长度只会减小不会增大，因此底层数组不会发生变化。</li>
</ol>
</blockquote>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><h2 id="方法：无方法，直接通过-slice-i-val-修改"><a href="#方法：无方法，直接通过-slice-i-val-修改" class="headerlink" title="方法：无方法，直接通过 slice[i] = val 修改"></a>方法：无方法，直接通过 <code>slice[i] = val</code> 修改</h2><h2 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h2><blockquote>
<p>略</p>
</blockquote>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="方法：-for-i-v-range-slice遍历"><a href="#方法：-for-i-v-range-slice遍历" class="headerlink" title="方法： for i,v := range slice遍历"></a>方法： <code>for i,v := range slice</code>遍历</h2><h2 id="测试：-2"><a href="#测试：-2" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 只用 index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"%d,"</span>, i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// index,value都用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"%d:%d,\t"</span>, i, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 只用value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"%d,"</span>, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,</span></pre></td></tr><tr><td class="code"><pre><span class="line">0:0,	1:2,	2:4,	3:6,	4:8,	5:10,	</span></pre></td></tr><tr><td class="code"><pre><span class="line">0,2,4,6,8,10,</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>go slice原理</title>
    <url>/blog/2018/12/15/20181215204437.html</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>go语言<code>slice</code>是底层数组的一个视图。<br><code>slice</code>主要参数有3个:</p>
<ol>
<li><code>ptr</code>指向<code>slice</code>的首个元素；</li>
<li><code>len</code>表示<code>slice</code>长度；</li>
<li><code>cap</code>表示<code>slice</code>容量。</li>
</ol>
<p>当向<code>slice</code>里<code>append</code>元素的时候，如果元素个数大于容量的某个百分比，将会扩容。其<code>ptr</code>值也会变。<br><code>slice</code>扩容的原理其实就是更换该<code>slice</code>底层<code>array</code>数组（因为<code>slice</code>只是某一数组的视图）</p>
</blockquote>
<h1 id="定义时与数组的区别"><a href="#定义时与数组的区别" class="headerlink" title="定义时与数组的区别"></a>定义时与数组的区别</h1><blockquote>
<p><code>array</code>与<code>slice</code>的定义</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">array1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">array2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// slice定义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice3 := array1[:] <span class="comment">// array1 := [3]int&#123;1,2,3&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slice4 := slice1[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice5 = []<span class="keyword">int</span></span></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><blockquote>
<p>测试<code>slice</code>与<code>array</code>定义区别</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"reflect"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	array1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	array2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice3 := array1[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice4 := slice1[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> slice5 []<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"array1 type : %v\n"</span>,reflect.TypeOf(array1).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"array2 type : %v\n"</span>,reflect.TypeOf(array2).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"==================="</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"slice1 type : %v\n"</span>,reflect.TypeOf(slice1).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"slice2 type : %v\n"</span>,reflect.TypeOf(slice2).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"slice3 type : %v\n"</span>,reflect.TypeOf(slice3).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"slice4 type : %v\n"</span>,reflect.TypeOf(slice4).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"slice5 type : %v\n"</span>,reflect.TypeOf(slice5).Kind())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array1 type : array</span></pre></td></tr><tr><td class="code"><pre><span class="line">array2 type : array</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice1 type : slice</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice2 type : slice</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice3 type : slice</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice4 type : slice</span></pre></td></tr><tr><td class="code"><pre><span class="line">slice5 type : slice</span></pre></td></tr></table></figure>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><blockquote>
<p>测试<code>slice</code>扩容条件</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr := tmp[<span class="number">1</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Cap := <span class="built_in">cap</span>(arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	lastCap := Cap</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Cap = <span class="built_in">cap</span>(arr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> Cap == lastCap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"%p\tlen:%v\t\tlastCap:%v\t\tcap:%v\n"</span>, arr, <span class="built_in">len</span>(arr), lastCap, Cap)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		lastCap = Cap</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc000072030	len:4		lastCap:3		cap:6</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00003e060	len:7		lastCap:6		cap:12</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00008a000	len:13		lastCap:12		cap:24</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00008c000	len:25		lastCap:24		cap:48</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00008e000	len:49		lastCap:48		cap:96</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc000090000	len:97		lastCap:96		cap:192</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc000092000	len:193		lastCap:192		cap:384</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc000098000	len:385		lastCap:384		cap:768</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00009e000	len:769		lastCap:768		cap:1536</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000a4000	len:1537		lastCap:1536		cap:2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000a8000	len:2049		lastCap:2048		cap:2560</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000b2000	len:2561		lastCap:2560		cap:3408</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000c6000	len:3409		lastCap:3408		cap:5120</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000d0000	len:5121		lastCap:5120		cap:7168</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000de000	len:7169		lastCap:7168		cap:9216</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc0000f0000	len:9217		lastCap:9216		cap:12288</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc000108000	len:12289		lastCap:12288		cap:15360</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc000126000	len:15361		lastCap:15360		cap:19456</span></pre></td></tr><tr><td class="code"><pre><span class="line">0xc00014c000	len:19457		lastCap:19456		cap:24576</span></pre></td></tr></table></figure>
<blockquote>
<p>结论：</p>
<ol>
<li>当扩容时，<code>ptr</code>指针变（即<code>slice</code>这个视图所在的<code>array</code>发生变化）</li>
<li>只有当<code>cap</code>大小等于<code>len</code>的时候才会扩容，扩容大小视<code>cap</code>大小而定：<code>cap</code>较小时，直接扩容一倍，稍大时，扩容比例较小</li>
</ol>
</blockquote>
<h2 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h2><blockquote>
<p>测试扩容前后的<code>slice</code>与原<code>slice</code>有什么不同以及两个相同的<code>slice</code>执行某些操作后，另一个的变化情况</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">16</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr2 := arr</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 扩容前两者地址一样，修改一个，另一个值也修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr[<span class="number">0</span>] = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"arr\t%p\t[0] : %v\tlen : %v\tcap : %v\n"</span>, arr, arr[<span class="number">0</span>], <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"ar2\t%p\t[0] : %v\tlen : %v\tcap : %v\n\n"</span>, arr2, arr2[<span class="number">0</span>], <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 扩容前，当一个增加元素时，另一个slice长度不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"arr\t%p\t[0] : %v\tlen : %v\tcap : %v\n"</span>, arr, arr[<span class="number">0</span>], <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"ar2\t%p\t[0] : %v\tlen : %v\tcap : %v\n\n"</span>, arr2, arr2[<span class="number">0</span>], <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 循环，令arr扩容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr = <span class="built_in">append</span>(arr, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 扩容后，arr变成一个新的slice，修改其中一个slice的值，另一个不会变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"arr\tptr : %p\tlen : %v\tcap : %v\n"</span>, arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"ar2\tptr : %p\tlen : %v\tcap : %v\n\n"</span>, arr2, <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr[<span class="number">0</span>] = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"arr\t[0] : %v\n"</span>, arr[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"ar2\t[0] : %v\n"</span>, arr2[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr	0xc00007e080	[0] : 5	len : 2	cap : 16</span></pre></td></tr><tr><td class="code"><pre><span class="line">ar2	0xc00007e080	[0] : 5	len : 2	cap : 16</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr	0xc00007e080	[0] : 5	len : 3	cap : 16</span></pre></td></tr><tr><td class="code"><pre><span class="line">ar2	0xc00007e080	[0] : 5	len : 2	cap : 16</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr	ptr : 0xc00008c000	len : 103	cap : 128</span></pre></td></tr><tr><td class="code"><pre><span class="line">ar2	ptr : 0xc00007e080	len : 2	cap : 16</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr	[0] : 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">ar2	[0] : 5</span></pre></td></tr></table></figure>
<blockquote>
<p>结论</p>
<ol>
<li>未发生扩容，两个<code>slice</code>相同，改变其中一个<code>slice</code>，另一个也变</li>
<li>未发生扩容，向其中一个增加元素，另一个len不变</li>
<li>发生扩容，新生成<code>slice</code>，地址变，改变其中一个<code>slice</code>另一个不变</li>
</ol>
</blockquote>
<h2 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h2><blockquote>
<p>测试对于两个引用同一个数组但<code>len</code>不同的<code>slice</code>，能否取到超出自身<code>len</code>的元素</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s1 := tmp[<span class="number">2</span>:<span class="number">6</span>]	<span class="comment">// s1 : [2,3,4,5]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="built_in">len</span>(s1))	<span class="comment">// s1 长度只有1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	s2 := s1[<span class="number">3</span>:<span class="number">6</span>]   <span class="comment">// s2 : [5,6,7]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// fmt.Println(s2[3])  // 报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(s2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span></pre></td></tr><tr><td class="code"><pre><span class="line">[5 6 7]</span></pre></td></tr></table></figure>
<blockquote>
<p>结论：</p>
<ol>
<li>如实例，<code>s1</code>长度为<code>1</code>，使用<code>[:]</code>操作，能取到后边的数字</li>
<li>如实例，<code>s1</code>长度为<code>1</code>，无法使用<code>s1[1]</code>取到对应位置的数据</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>博客next主题侧边菜单栏设置</title>
    <url>/blog/2018/12/15/20181215023114.html</url>
    <content><![CDATA[<h1 id="增加菜单"><a href="#增加菜单" class="headerlink" title="增加菜单"></a>增加菜单</h1><blockquote>
<p>增加菜单 tags、categories、等</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo new page tags</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo new page categories</span></pre></td></tr></table></figure>

<h1 id="增加链接"><a href="#增加链接" class="headerlink" title="增加链接"></a>增加链接</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在主题config里去掉menu里相关注释</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span></pre></td></tr></table></figure>
<h1 id="修改新建的tags、categories目录下的md文件"><a href="#修改新建的tags、categories目录下的md文件" class="headerlink" title="修改新建的tags、categories目录下的md文件"></a>修改新建的tags、categories目录下的md文件</h1><blockquote>
<p>在md文件中增加type 属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">title: tags</span></pre></td></tr><tr><td class="code"><pre><span class="line">date: 2018-12-15 02:22:50</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: &quot;tags&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>

<h1 id="使用标签和分类"><a href="#使用标签和分类" class="headerlink" title="使用标签和分类"></a>使用标签和分类</h1><blockquote>
<p>在post里增加tags和categories属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">title: 博客next主题侧边菜单栏设置</span></pre></td></tr><tr><td class="code"><pre><span class="line">date: 2018-12-15 02:31:14</span></pre></td></tr><tr><td class="code"><pre><span class="line">tags: </span></pre></td></tr><tr><td class="code"><pre><span class="line">    - github博客</span></pre></td></tr><tr><td class="code"><pre><span class="line">categories: </span></pre></td></tr><tr><td class="code"><pre><span class="line">    - github博客</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>
<blockquote>
<p>注意：tags、categories均可用数组[1,2,3]的形式代替列表形式。tags列表里内容同级，categories列表里内容不同级</p>
</blockquote>
<h1 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h1><blockquote>
<p>主要在blog根目录下的<code>_config.yml</code>文件中配置，默认配置是 <code>年/月/日/标题/</code>，用标题作为url一部分不是很合理，如果标题发生改变，那链接也跟着变化了。  </p>
<p>所以要使用一个唯一标示且不会发生改变的值作为url。hexo自带的有id，可使用id，但id生成规则不是很清楚，测试过修改题目后，id也发生变化。  </p>
<p>本网站使用的方法是：给每个md文件增加一个属性，记为<code>pid</code>，然后使用<code>pid</code>作为url一部分。</p>
<p>首先，修改blog根目录下的<code>_config.yml</code>文件如下：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 永久化链接。（最后加 .html 有利于搜索引擎收录）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:year/:month/:day/:pid.html</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">permalink_defaults:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">pid:</span> <span class="string">default</span></span></pre></td></tr></table></figure>
<blockquote>
<p>然后，修改新增<code>post</code>时的模板文件<code>blog/scaffolds/post.md</code>，增加<code>pid</code>属性，这里把<code>pid</code>设置成时间了，直接用<code>date</code>在转化后不是我们想要的格式，这里就用这种笨方法。或者留白，新建文件后自己填写也可。  </p>
<p>使用这种方法，<code>pid</code>是与文章内容无任何关系的属性，只要我们不修改<code>pid</code>和永久链接规则，文章的链接就不会变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">date: &#123;&#123; date &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pid: &#123;&#123;date[0]&#125;&#125;&#123;&#123;date[1]&#125;&#125;&#123;&#123;date[2]&#125;&#125;&#123;&#123;date[3]&#125;&#125;&#123;&#123;date[5]&#125;&#125;&#123;&#123;date[6]&#125;&#125;&#123;&#123;date[8]&#125;&#125;&#123;&#123;date[9]&#125;&#125;&#123;&#123;date[11]&#125;&#125;&#123;&#123;date[12]&#125;&#125;&#123;&#123;date[14]&#125;&#125;&#123;&#123;date[15]&#125;&#125;&#123;&#123;date[17]&#125;&#125;&#123;&#123;date[18]&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">tags:</span></pre></td></tr><tr><td class="code"><pre><span class="line">categories:</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>github博客</category>
      </categories>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title>在GitHub上创建博客</title>
    <url>/blog/2018/12/15/20181215005754.html</url>
    <content><![CDATA[<h1 id="GitHub搭建博客"><a href="#GitHub搭建博客" class="headerlink" title="GitHub搭建博客"></a>GitHub搭建博客</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><blockquote>
<p>安装完成后测试</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -v</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6.4.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">node -v</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> v10.14.2</span></span></pre></td></tr></table></figure>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>全局安装hexo</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装完查看</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo -v</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo-cli: 1.1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">os: Windows_NT 10.0.17763 win32 x64</span></pre></td></tr><tr><td class="code"><pre><span class="line">http_parser: 2.8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">node: 10.14.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">v8: 6.8.275.32-node.45</span></pre></td></tr><tr><td class="code"><pre><span class="line">uv: 1.23.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">zlib: 1.2.11</span></pre></td></tr><tr><td class="code"><pre><span class="line">ares: 1.15.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">modules: 64</span></pre></td></tr><tr><td class="code"><pre><span class="line">nghttp2: 1.34.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">napi: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl: 1.1.0j</span></pre></td></tr><tr><td class="code"><pre><span class="line">icu: 62.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">unicode: 11.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">cldr: 33.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">tz: 2018e</span></pre></td></tr></table></figure>
<h2 id="GitHub创建项目，并拉至本地"><a href="#GitHub创建项目，并拉至本地" class="headerlink" title="GitHub创建项目，并拉至本地"></a>GitHub创建项目，并拉至本地</h2><blockquote>
<p>注意：项目名格式必须为    用户名.github.io  </p>
</blockquote>
<h2 id="初始化hexo环境"><a href="#初始化hexo环境" class="headerlink" title="初始化hexo环境"></a>初始化hexo环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建blog目录，在目录下执行命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo init</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 完成后安装依赖</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span></pre></td></tr></table></figure>
<h2 id="配置ssh，让本地可免密push到GitHub"><a href="#配置ssh，让本地可免密push到GitHub" class="headerlink" title="配置ssh，让本地可免密push到GitHub"></a>配置ssh，让本地可免密push到GitHub</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="新建博客，并上传到git"><a href="#新建博客，并上传到git" class="headerlink" title="新建博客，并上传到git"></a>新建博客，并上传到git</h2><h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post "博客名"</span></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在_config.yml最后配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type: git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  repo: git地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">  branch: master</span></pre></td></tr></table></figure>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d -g</span></pre></td></tr></table></figure>

<h2 id="增加搜索功能"><a href="#增加搜索功能" class="headerlink" title="增加搜索功能"></a>增加搜索功能</h2><h3 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 主题配置文件 themes/主题名/_config.yml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span></pre></td></tr></table></figure>
<h3 id="安装mermaid插件："><a href="#安装mermaid插件：" class="headerlink" title="安装mermaid插件："></a>安装mermaid插件：</h3><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams -u</span></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><code>_config.yml</code>中增加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">version:</span> <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#startOnload: true  // default true</span></span></pre></td></tr></table></figure>
<p>在页面加入引用：<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">github地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.mermaid.enable) &#123; %&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;script src&#x3D;&#39;https:&#x2F;&#x2F;unpkg.com&#x2F;mermaid@&lt;%&#x3D; theme.mermaid.version %&gt;&#x2F;dist&#x2F;mermaid.min.js&#39;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (window.mermaid) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      mermaid.initialize(&#123;theme: &#39;forest&#39;&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;% &#125; %&gt;</span></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ol>
<li>ERROR Deployer not found: git<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>github博客</category>
      </categories>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言与其他语言不一样的地方</title>
    <url>/blog/2018/10/23/20181210104815.html</url>
    <content><![CDATA[<h2 id="没有：类、继承、多态、重载-的概念"><a href="#没有：类、继承、多态、重载-的概念" class="headerlink" title="没有：类、继承、多态、重载  的概念"></a>没有：类、继承、多态、重载  的概念</h2><blockquote>
<ol>
<li>不同世界观： go语言中使用 duck typing，面向接口编程、函数式编程</li>
<li>面向对象的世界里，也流行变继承为组合的思维</li>
<li>面向对象的元素容易被滥用</li>
<li>为组合提供了便捷的支持</li>
</ol>
</blockquote>
<h2 id="没有：try-catch-finally"><a href="#没有：try-catch-finally" class="headerlink" title="没有：try/catch/finally"></a>没有：try/catch/finally</h2><blockquote>
<ol>
<li>太多错误被当作异常</li>
<li>很多C++项目组禁用try/catch</li>
<li>正确的使用try/catch处理错误，导致代码混乱</li>
<li>在产品代码中try/catch并不能减小开发人员负担</li>
<li>真正异常情况有 defer/panic/recover 模式处理</li>
</ol>
</blockquote>
<h2 id="没有构造-析构-RAII"><a href="#没有构造-析构-RAII" class="headerlink" title="没有构造/析构/RAII"></a>没有构造/析构/RAII</h2><blockquote>
<ol>
<li>大型项目很少使用构造函数，多使用工厂函数，如果需要，可直接使用结构体初始化语法实现</li>
<li>go有gc，不需要析构</li>
</ol>
</blockquote>
<h2 id="没有泛型"><a href="#没有泛型" class="headerlink" title="没有泛型"></a>没有泛型</h2><blockquote>
<ol>
<li>泛型实际想实现duck typing，go语言提供了duck typing及接口组合支持</li>
<li>使用来约束参数类型：本身复杂，但go自带slice,map,channel 类似泛型参数</li>
<li>type assertion、go generation来实现自己的泛型</li>
<li>泛型支持是作者唯一态度不强硬的点</li>
</ol>
</blockquote>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>]]></content>
      <categories>
        <category>go</category>
        <category>go语言基础</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go语言基础</tag>
      </tags>
  </entry>
</search>
